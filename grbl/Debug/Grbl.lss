
Grbl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00007ac6  00007b5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007ac6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005cc  00800106  00800106  00007b60  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00007b60  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007b90  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000548  00000000  00000000  00007bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000084cf  00000000  00000000  00008118  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002326  00000000  00000000  000105e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004f4f  00000000  00000000  0001290d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001190  00000000  00000000  0001785c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000017f2  00000000  00000000  000189ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e43  00000000  00000000  0001a1de  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000508  00000000  00000000  00020021  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 04 	jmp	0x9ca	; 0x9ca <__ctors_end>
       4:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
       8:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
       c:	0c 94 57 11 	jmp	0x22ae	; 0x22ae <__vector_3>
      10:	0c 94 46 36 	jmp	0x6c8c	; 0x6c8c <__vector_4>
      14:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      18:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      1c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      20:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      24:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      28:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      2c:	0c 94 97 2c 	jmp	0x592e	; 0x592e <__vector_11>
      30:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      34:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      38:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      3c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      40:	0c 94 7a 2e 	jmp	0x5cf4	; 0x5cf4 <__vector_16>
      44:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      48:	0c 94 83 28 	jmp	0x5106	; 0x5106 <__vector_18>
      4c:	0c 94 45 28 	jmp	0x508a	; 0x508a <__vector_19>
      50:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      54:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      58:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      5c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      60:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      64:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      68:	11 07       	cpc	r17, r17
      6a:	11 07       	cpc	r17, r17
      6c:	11 07       	cpc	r17, r17
      6e:	11 07       	cpc	r17, r17
      70:	a6 06       	cpc	r10, r22
      72:	23 10       	cpse	r2, r3
      74:	23 10       	cpse	r2, r3
      76:	23 10       	cpse	r2, r3
      78:	23 10       	cpse	r2, r3
      7a:	23 10       	cpse	r2, r3
      7c:	9a 06       	cpc	r9, r26
      7e:	23 10       	cpse	r2, r3
      80:	23 10       	cpse	r2, r3
      82:	23 10       	cpse	r2, r3
      84:	23 10       	cpse	r2, r3
      86:	23 10       	cpse	r2, r3
      88:	23 10       	cpse	r2, r3
      8a:	64 07       	cpc	r22, r20
      8c:	64 07       	cpc	r22, r20
      8e:	64 07       	cpc	r22, r20
      90:	9c 07       	cpc	r25, r28
      92:	9c 07       	cpc	r25, r28
      94:	23 10       	cpse	r2, r3
      96:	23 10       	cpse	r2, r3
      98:	23 10       	cpse	r2, r3
      9a:	23 10       	cpse	r2, r3
      9c:	23 10       	cpse	r2, r3
      9e:	23 10       	cpse	r2, r3
      a0:	9a 06       	cpc	r9, r26
      a2:	23 10       	cpse	r2, r3
      a4:	9a 06       	cpc	r9, r26
      a6:	23 10       	cpse	r2, r3
      a8:	23 10       	cpse	r2, r3
      aa:	23 10       	cpse	r2, r3
      ac:	23 10       	cpse	r2, r3
      ae:	23 10       	cpse	r2, r3
      b0:	23 10       	cpse	r2, r3
      b2:	23 10       	cpse	r2, r3
      b4:	11 07       	cpc	r17, r17
      b6:	23 10       	cpse	r2, r3
      b8:	ca 07       	cpc	r28, r26
      ba:	23 10       	cpse	r2, r3
      bc:	23 10       	cpse	r2, r3
      be:	a7 07       	cpc	r26, r23
      c0:	23 10       	cpse	r2, r3
      c2:	23 10       	cpse	r2, r3
      c4:	23 10       	cpse	r2, r3
      c6:	23 10       	cpse	r2, r3
      c8:	23 10       	cpse	r2, r3
      ca:	a7 07       	cpc	r26, r23
      cc:	23 10       	cpse	r2, r3
      ce:	23 10       	cpse	r2, r3
      d0:	23 10       	cpse	r2, r3
      d2:	a6 06       	cpc	r10, r22
      d4:	bf 07       	cpc	r27, r31
      d6:	bf 07       	cpc	r27, r31
      d8:	bf 07       	cpc	r27, r31
      da:	bf 07       	cpc	r27, r31
      dc:	bf 07       	cpc	r27, r31
      de:	bf 07       	cpc	r27, r31
      e0:	23 10       	cpse	r2, r3
      e2:	c4 07       	cpc	r28, r20
      e4:	23 10       	cpse	r2, r3
      e6:	23 10       	cpse	r2, r3
      e8:	23 10       	cpse	r2, r3
      ea:	23 10       	cpse	r2, r3
      ec:	23 10       	cpse	r2, r3
      ee:	23 10       	cpse	r2, r3
      f0:	23 10       	cpse	r2, r3
      f2:	23 10       	cpse	r2, r3
      f4:	23 10       	cpse	r2, r3
      f6:	23 10       	cpse	r2, r3
      f8:	23 10       	cpse	r2, r3
      fa:	23 10       	cpse	r2, r3
      fc:	23 10       	cpse	r2, r3
      fe:	23 10       	cpse	r2, r3
     100:	23 10       	cpse	r2, r3
     102:	23 10       	cpse	r2, r3
     104:	23 10       	cpse	r2, r3
     106:	23 10       	cpse	r2, r3
     108:	17 07       	cpc	r17, r23
     10a:	23 10       	cpse	r2, r3
     10c:	23 10       	cpse	r2, r3
     10e:	23 10       	cpse	r2, r3
     110:	23 10       	cpse	r2, r3
     112:	23 10       	cpse	r2, r3
     114:	23 10       	cpse	r2, r3
     116:	23 10       	cpse	r2, r3
     118:	23 10       	cpse	r2, r3
     11a:	23 10       	cpse	r2, r3
     11c:	78 07       	cpc	r23, r24
     11e:	78 07       	cpc	r23, r24
     120:	9a 06       	cpc	r9, r26
     122:	91 07       	cpc	r25, r17
     124:	91 07       	cpc	r25, r17
     126:	f9 07       	cpc	r31, r25
     128:	f9 07       	cpc	r31, r25
     12a:	f9 07       	cpc	r31, r25
     12c:	09 08       	sbc	r0, r9
     12e:	09 08       	sbc	r0, r9
     130:	09 08       	sbc	r0, r9
     132:	41 10       	cpse	r4, r1
     134:	41 10       	cpse	r4, r1
     136:	1d 08       	sbc	r1, r13
     138:	1d 08       	sbc	r1, r13
     13a:	41 10       	cpse	r4, r1
     13c:	41 10       	cpse	r4, r1
     13e:	41 10       	cpse	r4, r1
     140:	41 10       	cpse	r4, r1
     142:	41 10       	cpse	r4, r1
     144:	41 10       	cpse	r4, r1
     146:	41 10       	cpse	r4, r1
     148:	41 10       	cpse	r4, r1
     14a:	41 10       	cpse	r4, r1
     14c:	41 10       	cpse	r4, r1
     14e:	41 10       	cpse	r4, r1
     150:	41 10       	cpse	r4, r1
     152:	41 10       	cpse	r4, r1
     154:	41 10       	cpse	r4, r1
     156:	41 10       	cpse	r4, r1
     158:	41 10       	cpse	r4, r1
     15a:	41 10       	cpse	r4, r1
     15c:	41 10       	cpse	r4, r1
     15e:	41 10       	cpse	r4, r1
     160:	41 10       	cpse	r4, r1
     162:	f9 07       	cpc	r31, r25
     164:	4e 08       	sbc	r4, r14
     166:	45 10       	cpse	r4, r5
     168:	45 10       	cpse	r4, r5
     16a:	58 08       	sbc	r5, r8
     16c:	65 08       	sbc	r6, r5
     16e:	72 08       	sbc	r7, r2
     170:	7f 08       	sbc	r7, r15
     172:	45 10       	cpse	r4, r5
     174:	83 08       	sbc	r8, r3
     176:	45 10       	cpse	r4, r5
     178:	91 08       	sbc	r9, r1
     17a:	45 10       	cpse	r4, r5
     17c:	9b 08       	sbc	r9, r11
     17e:	a5 08       	sbc	r10, r5
     180:	d6 08       	sbc	r13, r6
     182:	45 10       	cpse	r4, r5
     184:	45 10       	cpse	r4, r5
     186:	45 10       	cpse	r4, r5
     188:	af 08       	sbc	r10, r15
     18a:	bc 08       	sbc	r11, r12
     18c:	c9 08       	sbc	r12, r9
     18e:	d7 0e       	add	r13, r23
     190:	ec 0e       	add	r14, r28
     192:	0b 0f       	add	r16, r27
     194:	ec 0e       	add	r14, r28
     196:	11 0f       	add	r17, r17
     198:	28 0f       	add	r18, r24
     19a:	17 0f       	add	r17, r23
     19c:	21 0f       	add	r18, r17
     19e:	3d 0f       	add	r19, r29
     1a0:	47 0f       	add	r20, r23
     1a2:	53 0f       	add	r21, r19
     1a4:	75 0f       	add	r23, r21
     1a6:	96 0f       	add	r25, r22
     1a8:	a4 0f       	add	r26, r20
     1aa:	b3 0f       	add	r27, r19
     1ac:	c1 0f       	add	r28, r17
     1ae:	5f 22       	and	r5, r31
     1b0:	64 22       	and	r6, r20
     1b2:	69 22       	and	r6, r25
     1b4:	6e 22       	and	r6, r30
     1b6:	73 22       	and	r7, r19
     1b8:	78 22       	and	r7, r24
     1ba:	7d 22       	and	r7, r29
     1bc:	82 22       	and	r8, r18
     1be:	87 22       	and	r8, r23
     1c0:	8c 22       	and	r8, r28
     1c2:	91 22       	and	r9, r17
     1c4:	a5 22       	and	r10, r21
     1c6:	a5 22       	and	r10, r21
     1c8:	a5 22       	and	r10, r21
     1ca:	a5 22       	and	r10, r21
     1cc:	a5 22       	and	r10, r21
     1ce:	a5 22       	and	r10, r21
     1d0:	a5 22       	and	r10, r21
     1d2:	a5 22       	and	r10, r21
     1d4:	9b 22       	and	r9, r27
     1d6:	96 22       	and	r9, r22
     1d8:	a0 22       	and	r10, r16
     1da:	f8 22       	and	r15, r24
     1dc:	fd 22       	and	r15, r29
     1de:	02 23       	and	r16, r18
     1e0:	07 23       	and	r16, r23
     1e2:	0c 23       	and	r16, r28
     1e4:	11 23       	and	r17, r17
     1e6:	16 23       	and	r17, r22
     1e8:	1b 23       	and	r17, r27
     1ea:	33 27       	eor	r19, r19
     1ec:	47 27       	eor	r20, r23
     1ee:	4c 27       	eor	r20, r28
     1f0:	55 27       	eor	r21, r21
     1f2:	42 27       	eor	r20, r18
     1f4:	55 27       	eor	r21, r21
     1f6:	55 27       	eor	r21, r21
     1f8:	55 27       	eor	r21, r21
     1fa:	38 27       	eor	r19, r24
     1fc:	55 27       	eor	r21, r21
     1fe:	55 27       	eor	r21, r21
     200:	55 27       	eor	r21, r21
     202:	55 27       	eor	r21, r21
     204:	55 27       	eor	r21, r21
     206:	55 27       	eor	r21, r21
     208:	55 27       	eor	r21, r21
     20a:	3d 27       	eor	r19, r29
     20c:	55 27       	eor	r21, r21
     20e:	55 27       	eor	r21, r21
     210:	55 27       	eor	r21, r21
     212:	55 27       	eor	r21, r21
     214:	55 27       	eor	r21, r21
     216:	55 27       	eor	r21, r21
     218:	55 27       	eor	r21, r21
     21a:	55 27       	eor	r21, r21
     21c:	55 27       	eor	r21, r21
     21e:	55 27       	eor	r21, r21
     220:	55 27       	eor	r21, r21
     222:	55 27       	eor	r21, r21
     224:	55 27       	eor	r21, r21
     226:	55 27       	eor	r21, r21
     228:	55 27       	eor	r21, r21
     22a:	51 27       	eor	r21, r17
     22c:	55 27       	eor	r21, r21
     22e:	55 27       	eor	r21, r21
     230:	55 27       	eor	r21, r21
     232:	55 27       	eor	r21, r21
     234:	55 27       	eor	r21, r21
     236:	55 27       	eor	r21, r21
     238:	55 27       	eor	r21, r21
     23a:	55 27       	eor	r21, r21
     23c:	55 27       	eor	r21, r21
     23e:	55 27       	eor	r21, r21
     240:	55 27       	eor	r21, r21
     242:	55 27       	eor	r21, r21
     244:	55 27       	eor	r21, r21
     246:	55 27       	eor	r21, r21
     248:	55 27       	eor	r21, r21
     24a:	55 27       	eor	r21, r21
     24c:	55 27       	eor	r21, r21
     24e:	55 27       	eor	r21, r21
     250:	55 27       	eor	r21, r21
     252:	55 27       	eor	r21, r21
     254:	55 27       	eor	r21, r21
     256:	55 27       	eor	r21, r21
     258:	55 27       	eor	r21, r21
     25a:	55 27       	eor	r21, r21
     25c:	55 27       	eor	r21, r21
     25e:	55 27       	eor	r21, r21
     260:	55 27       	eor	r21, r21
     262:	55 27       	eor	r21, r21
     264:	55 27       	eor	r21, r21
     266:	55 27       	eor	r21, r21
     268:	55 27       	eor	r21, r21
     26a:	38 27       	eor	r19, r24
     26c:	93 2a       	or	r9, r19
     26e:	99 2a       	or	r9, r25
     270:	9c 2a       	or	r9, r28
     272:	a1 2a       	or	r10, r17
     274:	a6 2a       	or	r10, r22
     276:	b4 2a       	or	r11, r20
     278:	c2 2a       	or	r12, r18
     27a:	4d 2b       	or	r20, r29
     27c:	4d 2b       	or	r20, r29
     27e:	4d 2b       	or	r20, r29
     280:	d0 2a       	or	r13, r16
     282:	d3 2a       	or	r13, r19
     284:	dc 2a       	or	r13, r28
     286:	e5 2a       	or	r14, r21
     288:	4d 2b       	or	r20, r29
     28a:	4d 2b       	or	r20, r29
     28c:	4d 2b       	or	r20, r29
     28e:	4d 2b       	or	r20, r29
     290:	4d 2b       	or	r20, r29
     292:	4d 2b       	or	r20, r29
     294:	f3 2a       	or	r15, r19
     296:	03 2b       	or	r16, r19
     298:	13 2b       	or	r17, r19
     29a:	21 2b       	or	r18, r17
     29c:	24 2b       	or	r18, r20
     29e:	2d 2b       	or	r18, r29
     2a0:	36 2b       	or	r19, r22
     2a2:	3d 2b       	or	r19, r29
     2a4:	08 4a       	sbci	r16, 0xA8	; 168
     2a6:	d7 3b       	cpi	r29, 0xB7	; 183
     2a8:	3b ce       	rjmp	.-906    	; 0xffffff20 <__eeprom_end+0xff7eff20>
     2aa:	01 6e       	ori	r16, 0xE1	; 225
     2ac:	84 bc       	out	0x24, r8	; 36
     2ae:	bf fd       	.word	0xfdbf	; ????
     2b0:	c1 2f       	mov	r28, r17
     2b2:	3d 6c       	ori	r19, 0xCD	; 205
     2b4:	74 31       	cpi	r23, 0x14	; 20
     2b6:	9a bd       	out	0x2a, r25	; 42
     2b8:	56 83       	std	Z+6, r21	; 0x06
     2ba:	3d da       	rcall	.-2950   	; 0xfffff736 <__eeprom_end+0xff7ef736>
     2bc:	3d 00       	.word	0x003d	; ????
     2be:	c7 7f       	andi	r28, 0xF7	; 247
     2c0:	11 be       	out	0x31, r1	; 49
     2c2:	d9 e4       	ldi	r29, 0x49	; 73
     2c4:	bb 4c       	sbci	r27, 0xCB	; 203
     2c6:	3e 91       	ld	r19, -X
     2c8:	6b aa       	std	Y+51, r6	; 0x33
     2ca:	aa be       	out	0x3a, r10	; 58
     2cc:	00 00       	nop
     2ce:	00 80       	ld	r0, Z
     2d0:	3f 05       	cpc	r19, r15
     2d2:	a8 4c       	sbci	r26, 0xC8	; 200
     2d4:	cd b2       	in	r12, 0x1d	; 29
     2d6:	d4 4e       	sbci	r29, 0xE4	; 228
     2d8:	b9 38       	cpi	r27, 0x89	; 137
     2da:	36 a9       	ldd	r19, Z+54	; 0x36
     2dc:	02 0c       	add	r0, r2
     2de:	50 b9       	out	0x00, r21	; 0
     2e0:	91 86       	std	Z+9, r9	; 0x09
     2e2:	88 08       	sbc	r8, r8
     2e4:	3c a6       	std	Y+44, r3	; 0x2c
     2e6:	aa aa       	std	Y+50, r10	; 0x32
     2e8:	2a be       	out	0x3a, r2	; 58
     2ea:	00 00       	nop
     2ec:	00 80       	ld	r0, Z
     2ee:	3f 00       	.word	0x003f	; ????

000002f0 <__trampolines_end>:
     2f0:	3e 0d       	add	r19, r14
     2f2:	0a 00       	.word	0x000a	; ????

000002f4 <__c.2888>:
     2f4:	2c 4c 69 6d 3a 00                                   ,Lim:.

000002fa <__c.2886>:
     2fa:	2c 52 58 3a 00                                      ,RX:.

000002ff <__c.2884>:
     2ff:	2c 42 75 66 3a 00                                   ,Buf:.

00000305 <__c.2879>:
     305:	2c 00                                               ,.

00000307 <__c.2877>:
     307:	2c 57 50 6f 73 3a 00                                ,WPos:.

0000030e <__c.2872>:
     30e:	2c 00                                               ,.

00000310 <__c.2870>:
     310:	2c 4d 50 6f 73 3a 00                                ,MPos:.

00000317 <__c.2868>:
     317:	3c 44 6f 6f 72 00                                   <Door.

0000031d <__c.2865>:
     31d:	3c 43 68 65 63 6b 00                                <Check.

00000324 <__c.2862>:
     324:	3c 41 6c 61 72 6d 00                                <Alarm.

0000032b <__c.2859>:
     32b:	3c 48 6f 6d 65 00                                   <Home.

00000331 <__c.2856>:
     331:	3c 48 6f 6c 64 00                                   <Hold.

00000337 <__c.2853>:
     337:	3c 52 75 6e 00                                      <Run.

0000033c <__c.2848>:
     33c:	3c 49 64 6c 65 00                                   <Idle.

00000342 <__c.2833>:
     342:	5d 0d 0a 00                                         ]...

00000346 <__c.2831>:
     346:	5b 30 2e 39 6a 2e 32 30 31 36 30 37 32 36 3a 00     [0.9j.20160726:.

00000356 <__c.2826>:
     356:	0d 0a 00                                            ...

00000359 <__c.2824>:
     359:	3d 00                                               =.

0000035b <__c.2822>:
     35b:	24 4e 00                                            $N.

0000035e <__c.2816>:
     35e:	5d 0d 0a 00                                         ]...

00000362 <__c.2814>:
     362:	20 53 00                                             S.

00000365 <__c.2812>:
     365:	20 46 00                                             F.

00000368 <__c.2810>:
     368:	20 54 00                                             T.

0000036b <__c.2808>:
     36b:	20 4d 38 00                                          M8.

0000036f <__c.2804>:
     36f:	20 4d 39 00                                          M9.

00000373 <__c.2801>:
     373:	20 4d 35 00                                          M5.

00000377 <__c.2798>:
     377:	20 4d 34 00                                          M4.

0000037b <__c.2794>:
     37b:	20 4d 33 00                                          M3.

0000037f <__c.2791>:
     37f:	20 4d 32 00                                          M2.

00000383 <__c.2788>:
     383:	20 4d 31 00                                          M1.

00000387 <__c.2784>:
     387:	20 4d 30 00                                          M0.

0000038b <__c.2781>:
     38b:	20 47 39 34 00                                       G94.

00000390 <__c.2779>:
     390:	20 47 39 33 00                                       G93.

00000395 <__c.2777>:
     395:	20 47 39 31 00                                       G91.

0000039a <__c.2775>:
     39a:	20 47 39 30 00                                       G90.

0000039f <__c.2773>:
     39f:	20 47 32 30 00                                       G20.

000003a4 <__c.2771>:
     3a4:	20 47 32 31 00                                       G21.

000003a9 <__c.2769>:
     3a9:	20 47 31 39 00                                       G19.

000003ae <__c.2766>:
     3ae:	20 47 31 38 00                                       G18.

000003b3 <__c.2762>:
     3b3:	20 47 31 37 00                                       G17.

000003b8 <__c.2759>:
     3b8:	20 47 00                                             G.

000003bb <__c.2757>:
     3bb:	47 33 38 2e 00                                      G38..

000003c0 <__c.2754>:
     3c0:	47 38 30 00                                         G80.

000003c4 <__c.2751>:
     3c4:	47 33 00                                            G3.

000003c7 <__c.2748>:
     3c7:	47 32 00                                            G2.

000003ca <__c.2745>:
     3ca:	47 31 00                                            G1.

000003cd <__c.2741>:
     3cd:	47 30 00                                            G0.

000003d0 <__c.2738>:
     3d0:	5b 00                                               [.

000003d2 <__c.2734>:
     3d2:	5d 0d 0a 00                                         ]...

000003d6 <__c.2732>:
     3d6:	5b 54 4c 4f 3a 00                                   [TLO:.

000003dc <__c.2727>:
     3dc:	5d 0d 0a 00                                         ]...

000003e0 <__c.2725>:
     3e0:	2c 00                                               ,.

000003e2 <__c.2723>:
     3e2:	5b 47 39 32 3a 00                                   [G92:.

000003e8 <__c.2715>:
     3e8:	5d 0d 0a 00                                         ]...

000003ec <__c.2713>:
     3ec:	2c 00                                               ,.

000003ee <__c.2711>:
     3ee:	3a 00                                               :.

000003f0 <__c.2708>:
     3f0:	33 30 00                                            30.

000003f3 <__c.2704>:
     3f3:	32 38 00                                            28.

000003f6 <__c.2701>:
     3f6:	5b 47 00                                            [G.

000003f9 <__c.2694>:
     3f9:	5d 0d 0a 00                                         ]...

000003fd <__c.2692>:
     3fd:	3a 00                                               :.

000003ff <__c.2687>:
     3ff:	2c 00                                               ,.

00000401 <__c.2685>:
     401:	5b 50 52 42 3a 00                                   [PRB:.

00000407 <__c.2673>:
     407:	29 0d 0a 00                                         )...

0000040b <__c.2671>:
     40b:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

0000041b <__c.2668>:
     41b:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

0000042c <__c.2665>:
     42c:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     43c:	6e 00                                               n.

0000043e <__c.2661>:
     43e:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

00000448 <__c.2658>:
     448:	7a 00                                               z.

0000044a <__c.2655>:
     44a:	79 00                                               y.

0000044c <__c.2651>:
     44c:	78 00                                               x.

0000044e <__c.2648>:
     44e:	20 28 00                                             (.

00000451 <__c.2641>:
     451:	3d 00                                               =.

00000453 <__c.2639>:
     453:	24 00                                               $.

00000455 <__c.2634>:
     455:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     465:	66 2c 20 6d 6d 29 0d 0a 00                          f, mm)...

0000046e <__c.2632>:
     46e:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     47e:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

0000048d <__c.2630>:
     48d:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     49d:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

000004aa <__c.2628>:
     4aa:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4ba:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004c7 <__c.2626>:
     4c7:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004cf <__c.2624>:
     4cf:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4df:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004e9 <__c.2622>:
     4e9:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4f9:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

00000505 <__c.2620>:
     505:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     515:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

00000520 <__c.2618>:
     520:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     530:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

0000053b <__c.2616>:
     53b:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     54b:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000558 <__c.2614>:
     558:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     568:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

00000573 <__c.2612>:
     573:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     583:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

00000593 <__c.2610>:
     593:	29 0d 0a 24 31 31 3d 00                             )..$11=.

0000059b <__c.2608>:
     59b:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     5ab:	6d 61 73 6b 3a 00                                   mask:.

000005b1 <__c.2606>:
     5b1:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5c1:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005d1 <__c.2604>:
     5d1:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5e1:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005f1 <__c.2602>:
     5f1:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     601:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

00000612 <__c.2600>:
     612:	29 0d 0a 24 34 3d 00                                )..$4=.

00000619 <__c.2598>:
     619:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     629:	74 20 6d 61 73 6b 3a 00                             t mask:.

00000631 <__c.2596>:
     631:	29 0d 0a 24 33 3d 00                                )..$3=.

00000638 <__c.2594>:
     638:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     648:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

00000651 <__c.2592>:
     651:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     661:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

0000066f <__c.2590>:
     66f:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     67f:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000688 <__c.2588>:
     688:	24 30 3d 00                                         $0=.

0000068c <__c.2584>:
     68c:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     69c:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     6ac:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6bc:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6cc:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6dc:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6ec:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6fc:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     70c:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     71c:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     72c:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     73c:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     74c:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     75c:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     76c:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     77c:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     78c:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     79c:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     7ac:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7bc:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7cc:	29 0d 0a 00                                         )...

000007d0 <__c.2580>:
     7d0:	0d 0a 47 72 62 6c 20 30 2e 39 6a 20 5b 27 24 27     ..Grbl 0.9j ['$'
     7e0:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

000007ed <__c.2576>:
     7ed:	5d 0d 0a 00                                         ]...

000007f1 <__c.2574>:
     7f1:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     801:	74 73 00                                            ts.

00000804 <__c.2571>:
     804:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000080c <__c.2568>:
     80c:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

00000817 <__c.2565>:
     817:	44 69 73 61 62 6c 65 64 00                          Disabled.

00000820 <__c.2562>:
     820:	45 6e 61 62 6c 65 64 00                             Enabled.

00000828 <__c.2559>:
     828:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     838:	64 00                                               d.

0000083a <__c.2556>:
     83a:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     84a:	6f 63 6b 00                                         ock.

0000084e <__c.2552>:
     84e:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     85e:	65 00                                               e.

00000860 <__c.2549>:
     860:	5b 00                                               [.

00000862 <__c.2544>:
     862:	0d 0a 00                                            ...

00000865 <__c.2542>:
     865:	48 6f 6d 69 6e 67 20 66 61 69 6c 00                 Homing fail.

00000871 <__c.2539>:
     871:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

0000087c <__c.2536>:
     87c:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     88c:	6c 65 00                                            le.

0000088f <__c.2533>:
     88f:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

0000089a <__c.2529>:
     89a:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

000008a5 <__c.2526>:
     8a5:	41 4c 41 52 4d 3a 20 00                             ALARM: .

000008ad <__c.2521>:
     8ad:	0d 0a 00                                            ...

000008b0 <__c.2519>:
     8b0:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     8c0:	3a 00                                               :.

000008c2 <__c.2516>:
     8c2:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     8d2:	61 74 65 00                                         ate.

000008d6 <__c.2513>:
     8d6:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8e6:	61 6e 64 00                                         and.

000008ea <__c.2510>:
     8ea:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8fa:	61 74 69 6f 6e 00                                   ation.

00000900 <__c.2507>:
     900:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

0000090e <__c.2504>:
     90e:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     91e:	65 64 00                                            ed.

00000921 <__c.2501>:
     921:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

0000092c <__c.2498>:
     92c:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000935 <__c.2495>:
     935:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     945:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000956 <__c.2492>:
     956:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000965 <__c.2489>:
     965:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000976 <__c.2486>:
     976:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

00000980 <__c.2483>:
     980:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     990:	74 00                                               t.

00000992 <__c.2480>:
     992:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     9a2:	74 00                                               t.

000009a4 <__c.2476>:
     9a4:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9b4:	20 6c 65 74 74 65 72 00                              letter.

000009bc <__c.2473>:
     9bc:	65 72 72 6f 72 3a 20 00                             error: .

000009c4 <__c.2471>:
     9c4:	6f 6b 0d 0a 00 00                                   ok....

000009ca <__ctors_end>:
     9ca:	11 24       	eor	r1, r1
     9cc:	1f be       	out	0x3f, r1	; 63
     9ce:	cf ef       	ldi	r28, 0xFF	; 255
     9d0:	d8 e0       	ldi	r29, 0x08	; 8
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	cd bf       	out	0x3d, r28	; 61

000009d6 <__do_copy_data>:
     9d6:	11 e0       	ldi	r17, 0x01	; 1
     9d8:	a0 e0       	ldi	r26, 0x00	; 0
     9da:	b1 e0       	ldi	r27, 0x01	; 1
     9dc:	e6 ec       	ldi	r30, 0xC6	; 198
     9de:	fa e7       	ldi	r31, 0x7A	; 122
     9e0:	02 c0       	rjmp	.+4      	; 0x9e6 <__do_copy_data+0x10>
     9e2:	05 90       	lpm	r0, Z+
     9e4:	0d 92       	st	X+, r0
     9e6:	a6 30       	cpi	r26, 0x06	; 6
     9e8:	b1 07       	cpc	r27, r17
     9ea:	d9 f7       	brne	.-10     	; 0x9e2 <__do_copy_data+0xc>

000009ec <__do_clear_bss>:
     9ec:	26 e0       	ldi	r18, 0x06	; 6
     9ee:	a6 e0       	ldi	r26, 0x06	; 6
     9f0:	b1 e0       	ldi	r27, 0x01	; 1
     9f2:	01 c0       	rjmp	.+2      	; 0x9f6 <.do_clear_bss_start>

000009f4 <.do_clear_bss_loop>:
     9f4:	1d 92       	st	X+, r1

000009f6 <.do_clear_bss_start>:
     9f6:	a2 3d       	cpi	r26, 0xD2	; 210
     9f8:	b2 07       	cpc	r27, r18
     9fa:	e1 f7       	brne	.-8      	; 0x9f4 <.do_clear_bss_loop>
     9fc:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <main>
     a00:	0c 94 61 3d 	jmp	0x7ac2	; 0x7ac2 <_exit>

00000a04 <__bad_interrupt>:
     a04:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a08 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
     a08:	43 98       	cbi	0x08, 3	; 8
     a0a:	08 95       	ret

00000a0c <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
     a0c:	3b 9a       	sbi	0x07, 3	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
     a0e:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
     a12:	08 95       	ret

00000a14 <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
     a14:	82 30       	cpi	r24, 0x02	; 2
     a16:	11 f4       	brne	.+4      	; 0xa1c <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
     a18:	43 9a       	sbi	0x08, 3	; 8
     a1a:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
     a1c:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
     a20:	08 95       	ret

00000a22 <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
     a22:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
     a24:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <sys+0x1>
     a28:	92 30       	cpi	r25, 0x02	; 2
     a2a:	31 f0       	breq	.+12     	; 0xa38 <coolant_run+0x16>
     a2c:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
     a2e:	0e 94 31 22 	call	0x4462	; 0x4462 <protocol_buffer_synchronize>
  coolant_set_state(mode);
     a32:	8c 2f       	mov	r24, r28
     a34:	0e 94 0a 05 	call	0xa14	; 0xa14 <coolant_set_state>
}
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
     a3c:	f9 99       	sbic	0x1f, 1	; 31
     a3e:	fe cf       	rjmp	.-4      	; 0xa3c <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
     a40:	92 bd       	out	0x22, r25	; 34
     a42:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
     a44:	81 e0       	ldi	r24, 0x01	; 1
     a46:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
     a48:	80 b5       	in	r24, 0x20	; 32
}
     a4a:	08 95       	ret

00000a4c <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
     a4c:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
     a4e:	f9 99       	sbic	0x1f, 1	; 31
     a50:	fe cf       	rjmp	.-4      	; 0xa4e <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
     a52:	92 bd       	out	0x22, r25	; 34
     a54:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
     a5a:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
     a5c:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
     a5e:	96 2f       	mov	r25, r22
     a60:	98 23       	and	r25, r24
     a62:	59 f0       	breq	.+22     	; 0xa7a <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
     a64:	6f 3f       	cpi	r22, 0xFF	; 255
     a66:	29 f0       	breq	.+10     	; 0xa72 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
     a68:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a6a:	84 e0       	ldi	r24, 0x04	; 4
     a6c:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
     a6e:	f9 9a       	sbi	0x1f, 1	; 31
     a70:	0a c0       	rjmp	.+20     	; 0xa86 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a72:	84 e1       	ldi	r24, 0x14	; 20
     a74:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
     a76:	f9 9a       	sbi	0x1f, 1	; 31
     a78:	06 c0       	rjmp	.+12     	; 0xa86 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
     a7a:	88 23       	and	r24, r24
     a7c:	21 f0       	breq	.+8      	; 0xa86 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
     a7e:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a80:	84 e2       	ldi	r24, 0x24	; 36
     a82:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
     a84:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
     a86:	78 94       	sei
     a88:	08 95       	ret

00000a8a <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
     a8a:	8f 92       	push	r8
     a8c:	9f 92       	push	r9
     a8e:	af 92       	push	r10
     a90:	bf 92       	push	r11
     a92:	cf 92       	push	r12
     a94:	df 92       	push	r13
     a96:	ef 92       	push	r14
     a98:	ff 92       	push	r15
     a9a:	0f 93       	push	r16
     a9c:	1f 93       	push	r17
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
     aa2:	7c 01       	movw	r14, r24
     aa4:	8b 01       	movw	r16, r22
     aa6:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
     aa8:	41 15       	cp	r20, r1
     aaa:	51 05       	cpc	r21, r1
     aac:	09 f1       	breq	.+66     	; 0xaf0 <memcpy_to_eeprom_with_checksum+0x66>
     aae:	5a 01       	movw	r10, r20
     ab0:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
     ab2:	d1 e0       	ldi	r29, 0x01	; 1
     ab4:	01 c0       	rjmp	.+2      	; 0xab8 <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
     ab6:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
     ab8:	c1 11       	cpse	r28, r1
     aba:	08 c0       	rjmp	.+16     	; 0xacc <memcpy_to_eeprom_with_checksum+0x42>
     abc:	6c 2f       	mov	r22, r28
     abe:	cc 0f       	add	r28, r28
     ac0:	77 0b       	sbc	r23, r23
     ac2:	c7 2f       	mov	r28, r23
     ac4:	cc 1f       	adc	r28, r28
     ac6:	cc 27       	eor	r28, r28
     ac8:	cc 1f       	adc	r28, r28
     aca:	01 c0       	rjmp	.+2      	; 0xace <memcpy_to_eeprom_with_checksum+0x44>
     acc:	cd 2f       	mov	r28, r29
    checksum += *source;
     ace:	f8 01       	movw	r30, r16
     ad0:	61 91       	ld	r22, Z+
     ad2:	8f 01       	movw	r16, r30
     ad4:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
     ad6:	4c 01       	movw	r8, r24
     ad8:	ff ef       	ldi	r31, 0xFF	; 255
     ada:	8f 1a       	sub	r8, r31
     adc:	9f 0a       	sbc	r9, r31
     ade:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
     ae2:	21 e0       	ldi	r18, 0x01	; 1
     ae4:	a2 1a       	sub	r10, r18
     ae6:	b1 08       	sbc	r11, r1
     ae8:	31 f7       	brne	.-52     	; 0xab6 <memcpy_to_eeprom_with_checksum+0x2c>
     aea:	ec 0c       	add	r14, r12
     aec:	fd 1c       	adc	r15, r13
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <memcpy_to_eeprom_with_checksum+0x68>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
     af0:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
     af2:	6c 2f       	mov	r22, r28
     af4:	c7 01       	movw	r24, r14
     af6:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	ef 90       	pop	r14
     b06:	df 90       	pop	r13
     b08:	cf 90       	pop	r12
     b0a:	bf 90       	pop	r11
     b0c:	af 90       	pop	r10
     b0e:	9f 90       	pop	r9
     b10:	8f 90       	pop	r8
     b12:	08 95       	ret

00000b14 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
     b14:	8f 92       	push	r8
     b16:	9f 92       	push	r9
     b18:	af 92       	push	r10
     b1a:	bf 92       	push	r11
     b1c:	cf 92       	push	r12
     b1e:	df 92       	push	r13
     b20:	ef 92       	push	r14
     b22:	ff 92       	push	r15
     b24:	0f 93       	push	r16
     b26:	1f 93       	push	r17
     b28:	cf 93       	push	r28
     b2a:	df 93       	push	r29
     b2c:	7b 01       	movw	r14, r22
     b2e:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	11 f1       	breq	.+68     	; 0xb7a <memcpy_from_eeprom_with_checksum+0x66>
     b36:	c8 2f       	mov	r28, r24
     b38:	d9 2f       	mov	r29, r25
     b3a:	5a 01       	movw	r10, r20
     b3c:	cb 01       	movw	r24, r22
     b3e:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
     b40:	88 24       	eor	r8, r8
     b42:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
     b44:	8c 01       	movw	r16, r24
     b46:	0f 5f       	subi	r16, 0xFF	; 255
     b48:	1f 4f       	sbci	r17, 0xFF	; 255
     b4a:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
     b4e:	91 10       	cpse	r9, r1
     b50:	08 c0       	rjmp	.+16     	; 0xb62 <memcpy_from_eeprom_with_checksum+0x4e>
     b52:	29 2d       	mov	r18, r9
     b54:	99 0c       	add	r9, r9
     b56:	33 0b       	sbc	r19, r19
     b58:	23 2f       	mov	r18, r19
     b5a:	22 1f       	adc	r18, r18
     b5c:	22 27       	eor	r18, r18
     b5e:	22 1f       	adc	r18, r18
     b60:	01 c0       	rjmp	.+2      	; 0xb64 <memcpy_from_eeprom_with_checksum+0x50>
     b62:	28 2d       	mov	r18, r8
    checksum += data;    
     b64:	98 2e       	mov	r9, r24
     b66:	92 0e       	add	r9, r18
    *(destination++) = data; 
     b68:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	a8 1a       	sub	r10, r24
     b6e:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
     b70:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b72:	41 f7       	brne	.-48     	; 0xb44 <memcpy_from_eeprom_with_checksum+0x30>
     b74:	ec 0c       	add	r14, r12
     b76:	fd 1c       	adc	r15, r13
     b78:	01 c0       	rjmp	.+2      	; 0xb7c <memcpy_from_eeprom_with_checksum+0x68>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
     b7a:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
     b7c:	c7 01       	movw	r24, r14
     b7e:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
     b82:	21 e0       	ldi	r18, 0x01	; 1
     b84:	30 e0       	ldi	r19, 0x00	; 0
     b86:	89 15       	cp	r24, r9
     b88:	11 f0       	breq	.+4      	; 0xb8e <memcpy_from_eeprom_with_checksum+0x7a>
     b8a:	20 e0       	ldi	r18, 0x00	; 0
     b8c:	30 e0       	ldi	r19, 0x00	; 0
}
     b8e:	c9 01       	movw	r24, r18
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	df 90       	pop	r13
     b9e:	cf 90       	pop	r12
     ba0:	bf 90       	pop	r11
     ba2:	af 90       	pop	r10
     ba4:	9f 90       	pop	r9
     ba6:	8f 90       	pop	r8
     ba8:	08 95       	ret

00000baa <gc_check_same_position>:
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
}


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	1f 93       	push	r17
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	7c 01       	movw	r14, r24
     bb8:	06 2f       	mov	r16, r22
     bba:	17 2f       	mov	r17, r23
     bbc:	ec 01       	movw	r28, r24
     bbe:	2c 96       	adiw	r28, 0x0c	; 12
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     bc0:	f7 01       	movw	r30, r14
     bc2:	61 91       	ld	r22, Z+
     bc4:	71 91       	ld	r23, Z+
     bc6:	81 91       	ld	r24, Z+
     bc8:	91 91       	ld	r25, Z+
     bca:	7f 01       	movw	r14, r30
     bcc:	f8 01       	movw	r30, r16
     bce:	21 91       	ld	r18, Z+
     bd0:	31 91       	ld	r19, Z+
     bd2:	41 91       	ld	r20, Z+
     bd4:	51 91       	ld	r21, Z+
     bd6:	8f 01       	movw	r16, r30
     bd8:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
     bdc:	81 11       	cpse	r24, r1
     bde:	05 c0       	rjmp	.+10     	; 0xbea <gc_check_same_position+0x40>


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
     be0:	ec 16       	cp	r14, r28
     be2:	fd 06       	cpc	r15, r29
     be4:	69 f7       	brne	.-38     	; 0xbc0 <gc_check_same_position+0x16>
    if (pos_a[idx] != pos_b[idx]) { return(false); }
  }
  return(true);
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	01 c0       	rjmp	.+2      	; 0xbec <gc_check_same_position+0x42>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     bea:	80 e0       	ldi	r24, 0x00	; 0
  }
  return(true);
}
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	1f 91       	pop	r17
     bf2:	0f 91       	pop	r16
     bf4:	ff 90       	pop	r15
     bf6:	ef 90       	pop	r14
     bf8:	08 95       	ret

00000bfa <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     bfa:	8f e3       	ldi	r24, 0x3F	; 63
     bfc:	ee e2       	ldi	r30, 0x2E	; 46
     bfe:	f5 e0       	ldi	r31, 0x05	; 5
     c00:	df 01       	movw	r26, r30
     c02:	1d 92       	st	X+, r1
     c04:	8a 95       	dec	r24
     c06:	e9 f7       	brne	.-6      	; 0xc02 <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
     c08:	61 e5       	ldi	r22, 0x51	; 81
     c0a:	75 e0       	ldi	r23, 0x05	; 5
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
     c12:	81 11       	cpse	r24, r1
     c14:	03 c0       	rjmp	.+6      	; 0xc1c <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
     c16:	87 e0       	ldi	r24, 0x07	; 7
     c18:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
     c1c:	08 95       	ret

00000c1e <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
     c1e:	6a ea       	ldi	r22, 0xAA	; 170
     c20:	75 e0       	ldi	r23, 0x05	; 5
     c22:	85 e4       	ldi	r24, 0x45	; 69
     c24:	95 e0       	ldi	r25, 0x05	; 5
     c26:	0e 94 b1 38 	call	0x7162	; 0x7162 <system_convert_array_steps_to_mpos>
     c2a:	08 95       	ret

00000c2c <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
     c2c:	2f 92       	push	r2
     c2e:	3f 92       	push	r3
     c30:	4f 92       	push	r4
     c32:	5f 92       	push	r5
     c34:	6f 92       	push	r6
     c36:	7f 92       	push	r7
     c38:	8f 92       	push	r8
     c3a:	9f 92       	push	r9
     c3c:	af 92       	push	r10
     c3e:	bf 92       	push	r11
     c40:	cf 92       	push	r12
     c42:	df 92       	push	r13
     c44:	ef 92       	push	r14
     c46:	ff 92       	push	r15
     c48:	0f 93       	push	r16
     c4a:	1f 93       	push	r17
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	cd b7       	in	r28, 0x3d	; 61
     c52:	de b7       	in	r29, 0x3e	; 62
     c54:	ab 97       	sbiw	r28, 0x2b	; 43
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	de bf       	out	0x3e, r29	; 62
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	7c 01       	movw	r14, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     c62:	89 e3       	ldi	r24, 0x39	; 57
     c64:	ed e6       	ldi	r30, 0x6D	; 109
     c66:	f5 e0       	ldi	r31, 0x05	; 5
     c68:	df 01       	movw	r26, r30
     c6a:	1d 92       	st	X+, r1
     c6c:	8a 95       	dec	r24
     c6e:	e9 f7       	brne	.-6      	; 0xc6a <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     c70:	8a e0       	ldi	r24, 0x0A	; 10
     c72:	ee e2       	ldi	r30, 0x2E	; 46
     c74:	f5 e0       	ldi	r31, 0x05	; 5
     c76:	ae e6       	ldi	r26, 0x6E	; 110
     c78:	b5 e0       	ldi	r27, 0x05	; 5
     c7a:	01 90       	ld	r0, Z+
     c7c:	0d 92       	st	X+, r0
     c7e:	8a 95       	dec	r24
     c80:	e1 f7       	brne	.-8      	; 0xc7a <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
     c82:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
     c84:	61 2c       	mov	r6, r1
     c86:	71 2c       	mov	r7, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
     c88:	c1 2c       	mov	r12, r1
     c8a:	d1 2c       	mov	r13, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
     c8c:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
     c8e:	1e 8e       	std	Y+30, r1	; 0x1e
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
     c90:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     c92:	aa 24       	eor	r10, r10
     c94:	a3 94       	inc	r10
     c96:	b1 2c       	mov	r11, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     c98:	0f 2e       	mov	r0, r31
     c9a:	f1 e6       	ldi	r31, 0x61	; 97
     c9c:	8f 2e       	mov	r8, r31
     c9e:	f3 e0       	ldi	r31, 0x03	; 3
     ca0:	9f 2e       	mov	r9, r31
     ca2:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
     ca4:	a5 c2       	rjmp	.+1354   	; 0x11f0 <gc_execute_line+0x5c4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     ca6:	9f eb       	ldi	r25, 0xBF	; 191
     ca8:	91 0f       	add	r25, r17
     caa:	9a 31       	cpi	r25, 0x1A	; 26
     cac:	10 f0       	brcs	.+4      	; 0xcb2 <gc_execute_line+0x86>
     cae:	0c 94 1f 10 	jmp	0x203e	; 0x203e <gc_execute_line+0x1412>
    char_counter++;
     cb2:	8f 5f       	subi	r24, 0xFF	; 255
     cb4:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     cb6:	ae 01       	movw	r20, r28
     cb8:	46 5e       	subi	r20, 0xE6	; 230
     cba:	5f 4f       	sbci	r21, 0xFF	; 255
     cbc:	be 01       	movw	r22, r28
     cbe:	67 5e       	subi	r22, 0xE7	; 231
     cc0:	7f 4f       	sbci	r23, 0xFF	; 255
     cc2:	c7 01       	movw	r24, r14
     cc4:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <read_float>
     cc8:	88 23       	and	r24, r24
     cca:	11 f4       	brne	.+4      	; 0xcd0 <gc_execute_line+0xa4>
     ccc:	0c 94 21 10 	jmp	0x2042	; 0x2042 <gc_execute_line+0x1416>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
     cd0:	2a 8c       	ldd	r2, Y+26	; 0x1a
     cd2:	3b 8c       	ldd	r3, Y+27	; 0x1b
     cd4:	4c 8c       	ldd	r4, Y+28	; 0x1c
     cd6:	5d 8c       	ldd	r5, Y+29	; 0x1d
     cd8:	c2 01       	movw	r24, r4
     cda:	b1 01       	movw	r22, r2
     cdc:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <trunc>
     ce0:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
     ce4:	06 2f       	mov	r16, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     ce6:	70 e0       	ldi	r23, 0x00	; 0
     ce8:	80 e0       	ldi	r24, 0x00	; 0
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	0e 94 76 3a 	call	0x74ec	; 0x74ec <__floatsisf>
     cf0:	9b 01       	movw	r18, r22
     cf2:	ac 01       	movw	r20, r24
     cf4:	c2 01       	movw	r24, r4
     cf6:	b1 01       	movw	r22, r2
     cf8:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
     cfc:	20 e0       	ldi	r18, 0x00	; 0
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	48 ec       	ldi	r20, 0xC8	; 200
     d02:	52 e4       	ldi	r21, 0x42	; 66
     d04:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
     d08:	0e 94 91 3c 	call	0x7922	; 0x7922 <round>
     d0c:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     d10:	17 34       	cpi	r17, 0x47	; 71
     d12:	21 f0       	breq	.+8      	; 0xd1c <gc_execute_line+0xf0>
     d14:	1d 34       	cpi	r17, 0x4D	; 77
     d16:	09 f4       	brne	.+2      	; 0xd1a <gc_execute_line+0xee>
     d18:	5c c1       	rjmp	.+696    	; 0xfd2 <gc_execute_line+0x3a6>
     d1a:	b2 c1       	rjmp	.+868    	; 0x1080 <gc_execute_line+0x454>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     d1c:	80 2f       	mov	r24, r16
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	8f 35       	cpi	r24, 0x5F	; 95
     d22:	91 05       	cpc	r25, r1
     d24:	10 f0       	brcs	.+4      	; 0xd2a <gc_execute_line+0xfe>
     d26:	0c 94 23 10 	jmp	0x2046	; 0x2046 <gc_execute_line+0x141a>
     d2a:	fc 01       	movw	r30, r24
     d2c:	ec 5c       	subi	r30, 0xCC	; 204
     d2e:	ff 4f       	sbci	r31, 0xFF	; 255
     d30:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     d34:	61 15       	cp	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	11 f0       	breq	.+4      	; 0xd3e <gc_execute_line+0x112>
     d3a:	0c 94 a4 10 	jmp	0x2148	; 0x2148 <gc_execute_line+0x151c>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     d3e:	ba a1       	ldd	r27, Y+34	; 0x22
     d40:	bb 23       	and	r27, r27
     d42:	11 f4       	brne	.+4      	; 0xd48 <gc_execute_line+0x11c>
     d44:	0c 94 87 10 	jmp	0x210e	; 0x210e <gc_execute_line+0x14e2>
     d48:	0c 94 25 10 	jmp	0x204a	; 0x204a <gc_execute_line+0x141e>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
     d4c:	0c 31       	cpi	r16, 0x1C	; 28
     d4e:	09 f1       	breq	.+66     	; 0xd92 <gc_execute_line+0x166>
     d50:	28 f4       	brcc	.+10     	; 0xd5c <gc_execute_line+0x130>
     d52:	04 30       	cpi	r16, 0x04	; 4
     d54:	71 f0       	breq	.+28     	; 0xd72 <gc_execute_line+0x146>
     d56:	0a 30       	cpi	r16, 0x0A	; 10
     d58:	a1 f0       	breq	.+40     	; 0xd82 <gc_execute_line+0x156>
     d5a:	1e c1       	rjmp	.+572    	; 0xf98 <gc_execute_line+0x36c>
     d5c:	05 33       	cpi	r16, 0x35	; 53
     d5e:	09 f4       	brne	.+2      	; 0xd62 <gc_execute_line+0x136>
     d60:	44 c0       	rjmp	.+136    	; 0xdea <gc_execute_line+0x1be>
     d62:	0c 35       	cpi	r16, 0x5C	; 92
     d64:	09 f4       	brne	.+2      	; 0xd68 <gc_execute_line+0x13c>
     d66:	49 c0       	rjmp	.+146    	; 0xdfa <gc_execute_line+0x1ce>
     d68:	0e 31       	cpi	r16, 0x1E	; 30
     d6a:	49 f1       	breq	.+82     	; 0xdbe <gc_execute_line+0x192>
     d6c:	15 c1       	rjmp	.+554    	; 0xf98 <gc_execute_line+0x36c>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d6e:	e1 e0       	ldi	r30, 0x01	; 1
     d70:	ea a3       	std	Y+34, r30	; 0x22
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d72:	e1 e0       	ldi	r30, 0x01	; 1
     d74:	ad e6       	ldi	r26, 0x6D	; 109
     d76:	b5 e0       	ldi	r27, 0x05	; 5
     d78:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d7a:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d7c:	12 c1       	rjmp	.+548    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d7e:	f1 e0       	ldi	r31, 0x01	; 1
     d80:	fa a3       	std	Y+34, r31	; 0x22
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d82:	82 e0       	ldi	r24, 0x02	; 2
     d84:	ad e6       	ldi	r26, 0x6D	; 109
     d86:	b5 e0       	ldi	r27, 0x05	; 5
     d88:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d8a:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d8c:	0a c1       	rjmp	.+532    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d8e:	b1 e0       	ldi	r27, 0x01	; 1
     d90:	ba a3       	std	Y+34, r27	; 0x22
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
     d92:	61 15       	cp	r22, r1
     d94:	71 05       	cpc	r23, r1
     d96:	29 f0       	breq	.+10     	; 0xda2 <gc_execute_line+0x176>
     d98:	6a 30       	cpi	r22, 0x0A	; 10
     d9a:	71 05       	cpc	r23, r1
     d9c:	41 f0       	breq	.+16     	; 0xdae <gc_execute_line+0x182>
     d9e:	0c 94 27 10 	jmp	0x204e	; 0x204e <gc_execute_line+0x1422>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     da2:	23 e0       	ldi	r18, 0x03	; 3
     da4:	ed e6       	ldi	r30, 0x6D	; 109
     da6:	f5 e0       	ldi	r31, 0x05	; 5
     da8:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     daa:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     dac:	01 c1       	rjmp	.+514    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     dae:	84 e0       	ldi	r24, 0x04	; 4
     db0:	ad e6       	ldi	r26, 0x6D	; 109
     db2:	b5 e0       	ldi	r27, 0x05	; 5
     db4:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     db6:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     db8:	fb c0       	rjmp	.+502    	; 0xfb0 <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     dba:	b1 e0       	ldi	r27, 0x01	; 1
     dbc:	ba a3       	std	Y+34, r27	; 0x22
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
     dbe:	61 15       	cp	r22, r1
     dc0:	71 05       	cpc	r23, r1
     dc2:	29 f0       	breq	.+10     	; 0xdce <gc_execute_line+0x1a2>
     dc4:	6a 30       	cpi	r22, 0x0A	; 10
     dc6:	71 05       	cpc	r23, r1
     dc8:	41 f0       	breq	.+16     	; 0xdda <gc_execute_line+0x1ae>
     dca:	0c 94 29 10 	jmp	0x2052	; 0x2052 <gc_execute_line+0x1426>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     dce:	25 e0       	ldi	r18, 0x05	; 5
     dd0:	ed e6       	ldi	r30, 0x6D	; 109
     dd2:	f5 e0       	ldi	r31, 0x05	; 5
     dd4:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     dd6:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     dd8:	eb c0       	rjmp	.+470    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     dda:	e6 e0       	ldi	r30, 0x06	; 6
     ddc:	ad e6       	ldi	r26, 0x6D	; 109
     dde:	b5 e0       	ldi	r27, 0x05	; 5
     de0:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     de2:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     de4:	e5 c0       	rjmp	.+458    	; 0xfb0 <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     de6:	f1 e0       	ldi	r31, 0x01	; 1
     de8:	fa a3       	std	Y+34, r31	; 0x22
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     dea:	e7 e0       	ldi	r30, 0x07	; 7
     dec:	ad e6       	ldi	r26, 0x6D	; 109
     dee:	b5 e0       	ldi	r27, 0x05	; 5
     df0:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     df2:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     df4:	d6 c0       	rjmp	.+428    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     df6:	f1 e0       	ldi	r31, 0x01	; 1
     df8:	fa a3       	std	Y+34, r31	; 0x22
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
     dfa:	61 15       	cp	r22, r1
     dfc:	71 05       	cpc	r23, r1
     dfe:	29 f0       	breq	.+10     	; 0xe0a <gc_execute_line+0x1de>
     e00:	6a 30       	cpi	r22, 0x0A	; 10
     e02:	71 05       	cpc	r23, r1
     e04:	41 f0       	breq	.+16     	; 0xe16 <gc_execute_line+0x1ea>
     e06:	0c 94 2b 10 	jmp	0x2056	; 0x2056 <gc_execute_line+0x142a>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     e0a:	e8 e0       	ldi	r30, 0x08	; 8
     e0c:	ad e6       	ldi	r26, 0x6D	; 109
     e0e:	b5 e0       	ldi	r27, 0x05	; 5
     e10:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     e12:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     e14:	cd c0       	rjmp	.+410    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e16:	e9 e0       	ldi	r30, 0x09	; 9
     e18:	ad e6       	ldi	r26, 0x6D	; 109
     e1a:	b5 e0       	ldi	r27, 0x05	; 5
     e1c:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     e1e:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e20:	c7 c0       	rjmp	.+398    	; 0xfb0 <gc_execute_line+0x384>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     e22:	fa a1       	ldd	r31, Y+34	; 0x22
     e24:	f1 11       	cpse	r31, r1
     e26:	0c 94 2d 10 	jmp	0x205a	; 0x205a <gc_execute_line+0x142e>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
     e2a:	22 e0       	ldi	r18, 0x02	; 2
     e2c:	2a a3       	std	Y+34, r18	; 0x22
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
     e2e:	02 30       	cpi	r16, 0x02	; 2
     e30:	b9 f0       	breq	.+46     	; 0xe60 <gc_execute_line+0x234>
     e32:	28 f4       	brcc	.+10     	; 0xe3e <gc_execute_line+0x212>
     e34:	00 23       	and	r16, r16
     e36:	59 f0       	breq	.+22     	; 0xe4e <gc_execute_line+0x222>
     e38:	01 30       	cpi	r16, 0x01	; 1
     e3a:	69 f0       	breq	.+26     	; 0xe56 <gc_execute_line+0x22a>
     e3c:	af c0       	rjmp	.+350    	; 0xf9c <gc_execute_line+0x370>
     e3e:	06 32       	cpi	r16, 0x26	; 38
     e40:	c9 f0       	breq	.+50     	; 0xe74 <gc_execute_line+0x248>
     e42:	00 35       	cpi	r16, 0x50	; 80
     e44:	e1 f1       	breq	.+120    	; 0xebe <gc_execute_line+0x292>
     e46:	03 30       	cpi	r16, 0x03	; 3
     e48:	09 f0       	breq	.+2      	; 0xe4c <gc_execute_line+0x220>
     e4a:	a8 c0       	rjmp	.+336    	; 0xf9c <gc_execute_line+0x370>
     e4c:	0e c0       	rjmp	.+28     	; 0xe6a <gc_execute_line+0x23e>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e4e:	10 92 6e 05 	sts	0x056E, r1	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e52:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e54:	a6 c0       	rjmp	.+332    	; 0xfa2 <gc_execute_line+0x376>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e56:	31 e0       	ldi	r19, 0x01	; 1
     e58:	30 93 6e 05 	sts	0x056E, r19	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e5c:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e5e:	a1 c0       	rjmp	.+322    	; 0xfa2 <gc_execute_line+0x376>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e60:	82 e0       	ldi	r24, 0x02	; 2
     e62:	80 93 6e 05 	sts	0x056E, r24	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e66:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e68:	9c c0       	rjmp	.+312    	; 0xfa2 <gc_execute_line+0x376>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e6a:	83 e0       	ldi	r24, 0x03	; 3
     e6c:	80 93 6e 05 	sts	0x056E, r24	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e70:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e72:	97 c0       	rjmp	.+302    	; 0xfa2 <gc_execute_line+0x376>
              case 38: 
                switch(mantissa) {
     e74:	6e 31       	cpi	r22, 0x1E	; 30
     e76:	71 05       	cpc	r23, r1
     e78:	99 f0       	breq	.+38     	; 0xea0 <gc_execute_line+0x274>
     e7a:	28 f4       	brcc	.+10     	; 0xe86 <gc_execute_line+0x25a>
     e7c:	64 31       	cpi	r22, 0x14	; 20
     e7e:	71 05       	cpc	r23, r1
     e80:	51 f0       	breq	.+20     	; 0xe96 <gc_execute_line+0x26a>
     e82:	0c 94 2f 10 	jmp	0x205e	; 0x205e <gc_execute_line+0x1432>
     e86:	68 32       	cpi	r22, 0x28	; 40
     e88:	71 05       	cpc	r23, r1
     e8a:	79 f0       	breq	.+30     	; 0xeaa <gc_execute_line+0x27e>
     e8c:	62 33       	cpi	r22, 0x32	; 50
     e8e:	71 05       	cpc	r23, r1
     e90:	89 f0       	breq	.+34     	; 0xeb4 <gc_execute_line+0x288>
     e92:	0c 94 2f 10 	jmp	0x205e	; 0x205e <gc_execute_line+0x1432>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e96:	84 e0       	ldi	r24, 0x04	; 4
     e98:	80 93 6e 05 	sts	0x056E, r24	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e9c:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e9e:	88 c0       	rjmp	.+272    	; 0xfb0 <gc_execute_line+0x384>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     ea0:	95 e0       	ldi	r25, 0x05	; 5
     ea2:	90 93 6e 05 	sts	0x056E, r25	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     ea6:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     ea8:	83 c0       	rjmp	.+262    	; 0xfb0 <gc_execute_line+0x384>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     eaa:	a6 e0       	ldi	r26, 0x06	; 6
     eac:	a0 93 6e 05 	sts	0x056E, r26	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     eb0:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     eb2:	7e c0       	rjmp	.+252    	; 0xfb0 <gc_execute_line+0x384>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     eb4:	b7 e0       	ldi	r27, 0x07	; 7
     eb6:	b0 93 6e 05 	sts	0x056E, r27	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     eba:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     ebc:	79 c0       	rjmp	.+242    	; 0xfb0 <gc_execute_line+0x384>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     ebe:	e8 e0       	ldi	r30, 0x08	; 8
     ec0:	e0 93 6e 05 	sts	0x056E, r30	; 0x80056e <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     ec4:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     ec6:	6d c0       	rjmp	.+218    	; 0xfa2 <gc_execute_line+0x376>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
     ec8:	02 31       	cpi	r16, 0x12	; 18
     eca:	49 f0       	breq	.+18     	; 0xede <gc_execute_line+0x2b2>
     ecc:	03 31       	cpi	r16, 0x13	; 19
     ece:	61 f0       	breq	.+24     	; 0xee8 <gc_execute_line+0x2bc>
     ed0:	01 31       	cpi	r16, 0x11	; 17
     ed2:	09 f0       	breq	.+2      	; 0xed6 <gc_execute_line+0x2aa>
     ed4:	65 c0       	rjmp	.+202    	; 0xfa0 <gc_execute_line+0x374>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     ed6:	10 92 72 05 	sts	0x0572, r1	; 0x800572 <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     eda:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     edc:	62 c0       	rjmp	.+196    	; 0xfa2 <gc_execute_line+0x376>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ede:	f1 e0       	ldi	r31, 0x01	; 1
     ee0:	f0 93 72 05 	sts	0x0572, r31	; 0x800572 <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     ee4:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ee6:	5d c0       	rjmp	.+186    	; 0xfa2 <gc_execute_line+0x376>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
     ee8:	82 e0       	ldi	r24, 0x02	; 2
     eea:	80 93 72 05 	sts	0x0572, r24	; 0x800572 <gc_block+0x5>
     eee:	59 c0       	rjmp	.+178    	; 0xfa2 <gc_execute_line+0x376>
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
     ef0:	61 15       	cp	r22, r1
     ef2:	71 05       	cpc	r23, r1
     ef4:	59 f4       	brne	.+22     	; 0xf0c <gc_execute_line+0x2e0>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
     ef6:	0a 35       	cpi	r16, 0x5A	; 90
     ef8:	21 f4       	brne	.+8      	; 0xf02 <gc_execute_line+0x2d6>
     efa:	10 92 71 05 	sts	0x0571, r1	; 0x800571 <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     efe:	83 e0       	ldi	r24, 0x03	; 3
     f00:	57 c0       	rjmp	.+174    	; 0xfb0 <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
     f02:	21 e0       	ldi	r18, 0x01	; 1
     f04:	20 93 71 05 	sts	0x0571, r18	; 0x800571 <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     f08:	83 e0       	ldi	r24, 0x03	; 3
     f0a:	52 c0       	rjmp	.+164    	; 0xfb0 <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     f0c:	6a 30       	cpi	r22, 0x0A	; 10
     f0e:	71 05       	cpc	r23, r1
     f10:	11 f0       	breq	.+4      	; 0xf16 <gc_execute_line+0x2ea>
     f12:	0c 94 31 10 	jmp	0x2062	; 0x2062 <gc_execute_line+0x1436>
     f16:	0a 35       	cpi	r16, 0x5A	; 90
     f18:	11 f4       	brne	.+4      	; 0xf1e <gc_execute_line+0x2f2>
     f1a:	0c 94 33 10 	jmp	0x2066	; 0x2066 <gc_execute_line+0x143a>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
     f1e:	84 e0       	ldi	r24, 0x04	; 4
     f20:	47 c0       	rjmp	.+142    	; 0xfb0 <gc_execute_line+0x384>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
     f22:	0d 35       	cpi	r16, 0x5D	; 93
     f24:	29 f4       	brne	.+10     	; 0xf30 <gc_execute_line+0x304>
     f26:	31 e0       	ldi	r19, 0x01	; 1
     f28:	30 93 6f 05 	sts	0x056F, r19	; 0x80056f <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f2c:	85 e0       	ldi	r24, 0x05	; 5
     f2e:	39 c0       	rjmp	.+114    	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
     f30:	10 92 6f 05 	sts	0x056F, r1	; 0x80056f <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f34:	85 e0       	ldi	r24, 0x05	; 5
     f36:	35 c0       	rjmp	.+106    	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
     f38:	04 31       	cpi	r16, 0x14	; 20
     f3a:	29 f4       	brne	.+10     	; 0xf46 <gc_execute_line+0x31a>
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	80 93 70 05 	sts	0x0570, r24	; 0x800570 <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f42:	86 e0       	ldi	r24, 0x06	; 6
     f44:	2e c0       	rjmp	.+92     	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
     f46:	10 92 70 05 	sts	0x0570, r1	; 0x800570 <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f4a:	86 e0       	ldi	r24, 0x06	; 6
     f4c:	2a c0       	rjmp	.+84     	; 0xfa2 <gc_execute_line+0x376>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     f4e:	9a a1       	ldd	r25, Y+34	; 0x22
     f50:	91 11       	cpse	r25, r1
     f52:	0c 94 35 10 	jmp	0x206a	; 0x206a <gc_execute_line+0x143e>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     f56:	01 33       	cpi	r16, 0x31	; 49
     f58:	31 f4       	brne	.+12     	; 0xf66 <gc_execute_line+0x33a>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
     f5a:	10 92 73 05 	sts	0x0573, r1	; 0x800573 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f5e:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f60:	a3 e0       	ldi	r26, 0x03	; 3
     f62:	aa a3       	std	Y+34, r26	; 0x22
     f64:	25 c0       	rjmp	.+74     	; 0xfb0 <gc_execute_line+0x384>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
     f66:	6a 30       	cpi	r22, 0x0A	; 10
     f68:	71 05       	cpc	r23, r1
     f6a:	11 f0       	breq	.+4      	; 0xf70 <gc_execute_line+0x344>
     f6c:	0c 94 37 10 	jmp	0x206e	; 0x206e <gc_execute_line+0x1442>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
     f70:	b1 e0       	ldi	r27, 0x01	; 1
     f72:	b0 93 73 05 	sts	0x0573, r27	; 0x800573 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f76:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f78:	e3 e0       	ldi	r30, 0x03	; 3
     f7a:	ea a3       	std	Y+34, r30	; 0x22
     f7c:	19 c0       	rjmp	.+50     	; 0xfb0 <gc_execute_line+0x384>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
     f7e:	06 53       	subi	r16, 0x36	; 54
     f80:	00 93 74 05 	sts	0x0574, r16	; 0x800574 <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
     f84:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
     f86:	0d c0       	rjmp	.+26     	; 0xfa2 <gc_execute_line+0x376>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
     f88:	67 2b       	or	r22, r23
     f8a:	11 f0       	breq	.+4      	; 0xf90 <gc_execute_line+0x364>
     f8c:	0c 94 39 10 	jmp	0x2072	; 0x2072 <gc_execute_line+0x1446>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
     f90:	8a e0       	ldi	r24, 0x0A	; 10
     f92:	0e c0       	rjmp	.+28     	; 0xfb0 <gc_execute_line+0x384>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
     f94:	87 e0       	ldi	r24, 0x07	; 7
     f96:	05 c0       	rjmp	.+10     	; 0xfa2 <gc_execute_line+0x376>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	03 c0       	rjmp	.+6      	; 0xfa2 <gc_execute_line+0x376>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <gc_execute_line+0x376>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     fa0:	82 e0       	ldi	r24, 0x02	; 2
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
     fa2:	67 2b       	or	r22, r23
     fa4:	29 f0       	breq	.+10     	; 0xfb0 <gc_execute_line+0x384>
     fa6:	0c 94 3b 10 	jmp	0x2076	; 0x2076 <gc_execute_line+0x144a>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     faa:	80 e0       	ldi	r24, 0x00	; 0
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     fac:	f1 e0       	ldi	r31, 0x01	; 1
     fae:	fa a3       	std	Y+34, r31	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     fb0:	95 01       	movw	r18, r10
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <gc_execute_line+0x38c>
     fb4:	22 0f       	add	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	8a 95       	dec	r24
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <gc_execute_line+0x388>
     fbc:	c9 01       	movw	r24, r18
     fbe:	96 01       	movw	r18, r12
     fc0:	28 23       	and	r18, r24
     fc2:	39 23       	and	r19, r25
     fc4:	23 2b       	or	r18, r19
     fc6:	11 f0       	breq	.+4      	; 0xfcc <gc_execute_line+0x3a0>
     fc8:	0c 94 3d 10 	jmp	0x207a	; 0x207a <gc_execute_line+0x144e>
        command_words |= bit(word_bit);
     fcc:	c8 2a       	or	r12, r24
     fce:	d9 2a       	or	r13, r25
        break;
     fd0:	0f c1       	rjmp	.+542    	; 0x11f0 <gc_execute_line+0x5c4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
     fd2:	67 2b       	or	r22, r23
     fd4:	11 f0       	breq	.+4      	; 0xfda <gc_execute_line+0x3ae>
     fd6:	0c 94 3f 10 	jmp	0x207e	; 0x207e <gc_execute_line+0x1452>
        switch(int_value) {
     fda:	80 2f       	mov	r24, r16
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	8f 31       	cpi	r24, 0x1F	; 31
     fe0:	91 05       	cpc	r25, r1
     fe2:	10 f0       	brcs	.+4      	; 0xfe8 <gc_execute_line+0x3bc>
     fe4:	0c 94 41 10 	jmp	0x2082	; 0x2082 <gc_execute_line+0x1456>
     fe8:	fc 01       	movw	r30, r24
     fea:	ed 56       	subi	r30, 0x6D	; 109
     fec:	ff 4f       	sbci	r31, 0xFF	; 255
     fee:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
     ff2:	02 30       	cpi	r16, 0x02	; 2
     ff4:	49 f0       	breq	.+18     	; 0x1008 <gc_execute_line+0x3dc>
     ff6:	0e 31       	cpi	r16, 0x1E	; 30
     ff8:	39 f0       	breq	.+14     	; 0x1008 <gc_execute_line+0x3dc>
     ffa:	01 11       	cpse	r16, r1
     ffc:	2c c0       	rjmp	.+88     	; 0x1056 <gc_execute_line+0x42a>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     ffe:	31 e0       	ldi	r19, 0x01	; 1
    1000:	30 93 75 05 	sts	0x0575, r19	; 0x800575 <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1004:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1006:	2c c0       	rjmp	.+88     	; 0x1060 <gc_execute_line+0x434>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1008:	82 e0       	ldi	r24, 0x02	; 2
    100a:	80 93 75 05 	sts	0x0575, r24	; 0x800575 <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    100e:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1010:	27 c0       	rjmp	.+78     	; 0x1060 <gc_execute_line+0x434>
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    1012:	04 30       	cpi	r16, 0x04	; 4
    1014:	49 f0       	breq	.+18     	; 0x1028 <gc_execute_line+0x3fc>
    1016:	05 30       	cpi	r16, 0x05	; 5
    1018:	61 f0       	breq	.+24     	; 0x1032 <gc_execute_line+0x406>
    101a:	03 30       	cpi	r16, 0x03	; 3
    101c:	f1 f4       	brne	.+60     	; 0x105a <gc_execute_line+0x42e>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	80 93 77 05 	sts	0x0577, r24	; 0x800577 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1024:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1026:	1c c0       	rjmp	.+56     	; 0x1060 <gc_execute_line+0x434>
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1028:	82 e0       	ldi	r24, 0x02	; 2
    102a:	80 93 77 05 	sts	0x0577, r24	; 0x800577 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    102e:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1030:	17 c0       	rjmp	.+46     	; 0x1060 <gc_execute_line+0x434>
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1032:	10 92 77 05 	sts	0x0577, r1	; 0x800577 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1036:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1038:	13 c0       	rjmp	.+38     	; 0x1060 <gc_execute_line+0x434>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    103a:	08 30       	cpi	r16, 0x08	; 8
    103c:	19 f0       	breq	.+6      	; 0x1044 <gc_execute_line+0x418>
    103e:	09 30       	cpi	r16, 0x09	; 9
    1040:	31 f0       	breq	.+12     	; 0x104e <gc_execute_line+0x422>
    1042:	0d c0       	rjmp	.+26     	; 0x105e <gc_execute_line+0x432>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1044:	82 e0       	ldi	r24, 0x02	; 2
    1046:	80 93 76 05 	sts	0x0576, r24	; 0x800576 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    104a:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    104c:	09 c0       	rjmp	.+18     	; 0x1060 <gc_execute_line+0x434>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    104e:	10 92 76 05 	sts	0x0576, r1	; 0x800576 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1052:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1054:	05 c0       	rjmp	.+10     	; 0x1060 <gc_execute_line+0x434>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1056:	8b e0       	ldi	r24, 0x0B	; 11
    1058:	03 c0       	rjmp	.+6      	; 0x1060 <gc_execute_line+0x434>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    105a:	8c e0       	ldi	r24, 0x0C	; 12
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <gc_execute_line+0x434>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    105e:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1060:	d5 01       	movw	r26, r10
    1062:	02 c0       	rjmp	.+4      	; 0x1068 <gc_execute_line+0x43c>
    1064:	aa 0f       	add	r26, r26
    1066:	bb 1f       	adc	r27, r27
    1068:	8a 95       	dec	r24
    106a:	e2 f7       	brpl	.-8      	; 0x1064 <gc_execute_line+0x438>
    106c:	96 01       	movw	r18, r12
    106e:	2a 23       	and	r18, r26
    1070:	3b 23       	and	r19, r27
    1072:	23 2b       	or	r18, r19
    1074:	11 f0       	breq	.+4      	; 0x107a <gc_execute_line+0x44e>
    1076:	0c 94 43 10 	jmp	0x2086	; 0x2086 <gc_execute_line+0x145a>
        command_words |= bit(word_bit);
    107a:	ca 2a       	or	r12, r26
    107c:	db 2a       	or	r13, r27
        break;
    107e:	b8 c0       	rjmp	.+368    	; 0x11f0 <gc_execute_line+0x5c4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1080:	81 2f       	mov	r24, r17
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	fc 01       	movw	r30, r24
    1086:	e6 54       	subi	r30, 0x46	; 70
    1088:	f1 09       	sbc	r31, r1
    108a:	e5 31       	cpi	r30, 0x15	; 21
    108c:	f1 05       	cpc	r31, r1
    108e:	10 f0       	brcs	.+4      	; 0x1094 <gc_execute_line+0x468>
    1090:	0c 94 45 10 	jmp	0x208a	; 0x208a <gc_execute_line+0x145e>
    1094:	ee 54       	subi	r30, 0x4E	; 78
    1096:	ff 4f       	sbci	r31, 0xFF	; 255
    1098:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    109c:	20 92 78 05 	sts	0x0578, r2	; 0x800578 <gc_block+0xb>
    10a0:	30 92 79 05 	sts	0x0579, r3	; 0x800579 <gc_block+0xc>
    10a4:	40 92 7a 05 	sts	0x057A, r4	; 0x80057a <gc_block+0xd>
    10a8:	50 92 7b 05 	sts	0x057B, r5	; 0x80057b <gc_block+0xe>
    10ac:	80 e0       	ldi	r24, 0x00	; 0
    10ae:	7f c0       	rjmp	.+254    	; 0x11ae <gc_execute_line+0x582>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    10b0:	20 92 7c 05 	sts	0x057C, r2	; 0x80057c <gc_block+0xf>
    10b4:	30 92 7d 05 	sts	0x057D, r3	; 0x80057d <gc_block+0x10>
    10b8:	40 92 7e 05 	sts	0x057E, r4	; 0x80057e <gc_block+0x11>
    10bc:	50 92 7f 05 	sts	0x057F, r5	; 0x80057f <gc_block+0x12>
    10c0:	bb a1       	ldd	r27, Y+35	; 0x23
    10c2:	b1 60       	ori	r27, 0x01	; 1
    10c4:	bb a3       	std	Y+35, r27	; 0x23
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	72 c0       	rjmp	.+228    	; 0x11ae <gc_execute_line+0x582>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    10ca:	20 92 80 05 	sts	0x0580, r2	; 0x800580 <gc_block+0x13>
    10ce:	30 92 81 05 	sts	0x0581, r3	; 0x800581 <gc_block+0x14>
    10d2:	40 92 82 05 	sts	0x0582, r4	; 0x800582 <gc_block+0x15>
    10d6:	50 92 83 05 	sts	0x0583, r5	; 0x800583 <gc_block+0x16>
    10da:	eb a1       	ldd	r30, Y+35	; 0x23
    10dc:	e2 60       	ori	r30, 0x02	; 2
    10de:	eb a3       	std	Y+35, r30	; 0x23
    10e0:	82 e0       	ldi	r24, 0x02	; 2
    10e2:	65 c0       	rjmp	.+202    	; 0x11ae <gc_execute_line+0x582>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    10e4:	20 92 84 05 	sts	0x0584, r2	; 0x800584 <gc_block+0x17>
    10e8:	30 92 85 05 	sts	0x0585, r3	; 0x800585 <gc_block+0x18>
    10ec:	40 92 86 05 	sts	0x0586, r4	; 0x800586 <gc_block+0x19>
    10f0:	50 92 87 05 	sts	0x0587, r5	; 0x800587 <gc_block+0x1a>
    10f4:	fb a1       	ldd	r31, Y+35	; 0x23
    10f6:	f4 60       	ori	r31, 0x04	; 4
    10f8:	fb a3       	std	Y+35, r31	; 0x23
    10fa:	83 e0       	ldi	r24, 0x03	; 3
    10fc:	58 c0       	rjmp	.+176    	; 0x11ae <gc_execute_line+0x582>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    10fe:	00 93 88 05 	sts	0x0588, r16	; 0x800588 <gc_block+0x1b>
    1102:	84 e0       	ldi	r24, 0x04	; 4
    1104:	54 c0       	rjmp	.+168    	; 0x11ae <gc_execute_line+0x582>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1106:	c2 01       	movw	r24, r4
    1108:	b1 01       	movw	r22, r2
    110a:	0e 94 3e 3a 	call	0x747c	; 0x747c <__fixsfsi>
    110e:	60 93 89 05 	sts	0x0589, r22	; 0x800589 <gc_block+0x1c>
    1112:	70 93 8a 05 	sts	0x058A, r23	; 0x80058a <gc_block+0x1d>
    1116:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <gc_block+0x1e>
    111a:	90 93 8c 05 	sts	0x058C, r25	; 0x80058c <gc_block+0x1f>
    111e:	85 e0       	ldi	r24, 0x05	; 5
    1120:	46 c0       	rjmp	.+140    	; 0x11ae <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1122:	20 92 8d 05 	sts	0x058D, r2	; 0x80058d <gc_block+0x20>
    1126:	30 92 8e 05 	sts	0x058E, r3	; 0x80058e <gc_block+0x21>
    112a:	40 92 8f 05 	sts	0x058F, r4	; 0x80058f <gc_block+0x22>
    112e:	50 92 90 05 	sts	0x0590, r5	; 0x800590 <gc_block+0x23>
    1132:	86 e0       	ldi	r24, 0x06	; 6
    1134:	3c c0       	rjmp	.+120    	; 0x11ae <gc_execute_line+0x582>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1136:	20 92 91 05 	sts	0x0591, r2	; 0x800591 <gc_block+0x24>
    113a:	30 92 92 05 	sts	0x0592, r3	; 0x800592 <gc_block+0x25>
    113e:	40 92 93 05 	sts	0x0593, r4	; 0x800593 <gc_block+0x26>
    1142:	50 92 94 05 	sts	0x0594, r5	; 0x800594 <gc_block+0x27>
    1146:	87 e0       	ldi	r24, 0x07	; 7
    1148:	32 c0       	rjmp	.+100    	; 0x11ae <gc_execute_line+0x582>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    114a:	20 92 95 05 	sts	0x0595, r2	; 0x800595 <gc_block+0x28>
    114e:	30 92 96 05 	sts	0x0596, r3	; 0x800596 <gc_block+0x29>
    1152:	40 92 97 05 	sts	0x0597, r4	; 0x800597 <gc_block+0x2a>
    1156:	50 92 98 05 	sts	0x0598, r5	; 0x800598 <gc_block+0x2b>
    115a:	88 e0       	ldi	r24, 0x08	; 8
    115c:	28 c0       	rjmp	.+80     	; 0x11ae <gc_execute_line+0x582>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    115e:	20 92 9a 05 	sts	0x059A, r2	; 0x80059a <gc_block+0x2d>
    1162:	30 92 9b 05 	sts	0x059B, r3	; 0x80059b <gc_block+0x2e>
    1166:	40 92 9c 05 	sts	0x059C, r4	; 0x80059c <gc_block+0x2f>
    116a:	50 92 9d 05 	sts	0x059D, r5	; 0x80059d <gc_block+0x30>
    116e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1170:	21 60       	ori	r18, 0x01	; 1
    1172:	2e 8f       	std	Y+30, r18	; 0x1e
    1174:	8a e0       	ldi	r24, 0x0A	; 10
    1176:	1b c0       	rjmp	.+54     	; 0x11ae <gc_execute_line+0x582>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1178:	20 92 9e 05 	sts	0x059E, r2	; 0x80059e <gc_block+0x31>
    117c:	30 92 9f 05 	sts	0x059F, r3	; 0x80059f <gc_block+0x32>
    1180:	40 92 a0 05 	sts	0x05A0, r4	; 0x8005a0 <gc_block+0x33>
    1184:	50 92 a1 05 	sts	0x05A1, r5	; 0x8005a1 <gc_block+0x34>
    1188:	3e 8d       	ldd	r19, Y+30	; 0x1e
    118a:	32 60       	ori	r19, 0x02	; 2
    118c:	3e 8f       	std	Y+30, r19	; 0x1e
    118e:	8b e0       	ldi	r24, 0x0B	; 11
    1190:	0e c0       	rjmp	.+28     	; 0x11ae <gc_execute_line+0x582>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1192:	20 92 a2 05 	sts	0x05A2, r2	; 0x8005a2 <gc_block+0x35>
    1196:	30 92 a3 05 	sts	0x05A3, r3	; 0x8005a3 <gc_block+0x36>
    119a:	40 92 a4 05 	sts	0x05A4, r4	; 0x8005a4 <gc_block+0x37>
    119e:	50 92 a5 05 	sts	0x05A5, r5	; 0x8005a5 <gc_block+0x38>
    11a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11a4:	84 60       	ori	r24, 0x04	; 4
    11a6:	8e 8f       	std	Y+30, r24	; 0x1e
    11a8:	8c e0       	ldi	r24, 0x0C	; 12
    11aa:	01 c0       	rjmp	.+2      	; 0x11ae <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    11ac:	89 e0       	ldi	r24, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    11ae:	85 01       	movw	r16, r10
    11b0:	08 2e       	mov	r0, r24
    11b2:	02 c0       	rjmp	.+4      	; 0x11b8 <gc_execute_line+0x58c>
    11b4:	00 0f       	add	r16, r16
    11b6:	11 1f       	adc	r17, r17
    11b8:	0a 94       	dec	r0
    11ba:	e2 f7       	brpl	.-8      	; 0x11b4 <gc_execute_line+0x588>
    11bc:	93 01       	movw	r18, r6
    11be:	20 23       	and	r18, r16
    11c0:	31 23       	and	r19, r17
    11c2:	23 2b       	or	r18, r19
    11c4:	09 f0       	breq	.+2      	; 0x11c8 <gc_execute_line+0x59c>
    11c6:	63 c7       	rjmp	.+3782   	; 0x208e <gc_execute_line+0x1462>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    11c8:	d4 01       	movw	r26, r8
    11ca:	02 c0       	rjmp	.+4      	; 0x11d0 <gc_execute_line+0x5a4>
    11cc:	b5 95       	asr	r27
    11ce:	a7 95       	ror	r26
    11d0:	8a 95       	dec	r24
    11d2:	e2 f7       	brpl	.-8      	; 0x11cc <gc_execute_line+0x5a0>
    11d4:	a0 ff       	sbrs	r26, 0
    11d6:	0a c0       	rjmp	.+20     	; 0x11ec <gc_execute_line+0x5c0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    11d8:	20 e0       	ldi	r18, 0x00	; 0
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	a9 01       	movw	r20, r18
    11de:	c2 01       	movw	r24, r4
    11e0:	b1 01       	movw	r22, r2
    11e2:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    11e6:	88 23       	and	r24, r24
    11e8:	0c f4       	brge	.+2      	; 0x11ec <gc_execute_line+0x5c0>
    11ea:	53 c7       	rjmp	.+3750   	; 0x2092 <gc_execute_line+0x1466>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    11ec:	60 2a       	or	r6, r16
    11ee:	71 2a       	or	r7, r17
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    11f0:	89 8d       	ldd	r24, Y+25	; 0x19
    11f2:	f7 01       	movw	r30, r14
    11f4:	e8 0f       	add	r30, r24
    11f6:	f1 1d       	adc	r31, r1
    11f8:	10 81       	ld	r17, Z
    11fa:	11 11       	cpse	r17, r1
    11fc:	54 cd       	rjmp	.-1368   	; 0xca6 <gc_execute_line+0x7a>
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    11fe:	be 8d       	ldd	r27, Y+30	; 0x1e
    1200:	bb 23       	and	r27, r27
    1202:	29 f0       	breq	.+10     	; 0x120e <gc_execute_line+0x5e2>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1204:	ea a1       	ldd	r30, Y+34	; 0x22
    1206:	e1 11       	cpse	r30, r1
    1208:	02 c0       	rjmp	.+4      	; 0x120e <gc_execute_line+0x5e2>
    120a:	f2 e0       	ldi	r31, 0x02	; 2
    120c:	fa a3       	std	Y+34, r31	; 0x22
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    120e:	65 fe       	sbrs	r6, 5
    1210:	0e c0       	rjmp	.+28     	; 0x122e <gc_execute_line+0x602>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1212:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <gc_block+0x1c>
    1216:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <gc_block+0x1d>
    121a:	a0 91 8b 05 	lds	r26, 0x058B	; 0x80058b <gc_block+0x1e>
    121e:	b0 91 8c 05 	lds	r27, 0x058C	; 0x80058c <gc_block+0x1f>
    1222:	80 38       	cpi	r24, 0x80	; 128
    1224:	96 49       	sbci	r25, 0x96	; 150
    1226:	a8 49       	sbci	r26, 0x98	; 152
    1228:	b1 05       	cpc	r27, r1
    122a:	0c f0       	brlt	.+2      	; 0x122e <gc_execute_line+0x602>
    122c:	34 c7       	rjmp	.+3688   	; 0x2096 <gc_execute_line+0x146a>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    122e:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <gc_block+0x2>
    1232:	81 30       	cpi	r24, 0x01	; 1
    1234:	31 f4       	brne	.+12     	; 0x1242 <gc_execute_line+0x616>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1236:	3a a1       	ldd	r19, Y+34	; 0x22
    1238:	32 30       	cpi	r19, 0x02	; 2
    123a:	91 f5       	brne	.+100    	; 0x12a0 <gc_execute_line+0x674>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    123c:	60 fe       	sbrs	r6, 0
    123e:	2d c7       	rjmp	.+3674   	; 0x209a <gc_execute_line+0x146e>
    1240:	2f c0       	rjmp	.+94     	; 0x12a0 <gc_execute_line+0x674>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1242:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <gc_state+0x1>
    1246:	81 11       	cpse	r24, r1
    1248:	2b c0       	rjmp	.+86     	; 0x12a0 <gc_execute_line+0x674>
      if (bit_istrue(value_words,bit(WORD_F))) {
    124a:	60 fe       	sbrs	r6, 0
    124c:	19 c0       	rjmp	.+50     	; 0x1280 <gc_execute_line+0x654>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    124e:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x3>
    1252:	81 30       	cpi	r24, 0x01	; 1
    1254:	29 f5       	brne	.+74     	; 0x12a0 <gc_execute_line+0x674>
    1256:	0d e6       	ldi	r16, 0x6D	; 109
    1258:	15 e0       	ldi	r17, 0x05	; 5
    125a:	23 e3       	ldi	r18, 0x33	; 51
    125c:	33 e3       	ldi	r19, 0x33	; 51
    125e:	4b ec       	ldi	r20, 0xCB	; 203
    1260:	51 e4       	ldi	r21, 0x41	; 65
    1262:	d8 01       	movw	r26, r16
    1264:	1b 96       	adiw	r26, 0x0b	; 11
    1266:	6d 91       	ld	r22, X+
    1268:	7d 91       	ld	r23, X+
    126a:	8d 91       	ld	r24, X+
    126c:	9c 91       	ld	r25, X
    126e:	1e 97       	sbiw	r26, 0x0e	; 14
    1270:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1274:	f8 01       	movw	r30, r16
    1276:	63 87       	std	Z+11, r22	; 0x0b
    1278:	74 87       	std	Z+12, r23	; 0x0c
    127a:	85 87       	std	Z+13, r24	; 0x0d
    127c:	96 87       	std	Z+14, r25	; 0x0e
    127e:	10 c0       	rjmp	.+32     	; 0x12a0 <gc_execute_line+0x674>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    1280:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <gc_state+0xe>
    1284:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <gc_state+0xf>
    1288:	a0 91 3e 05 	lds	r26, 0x053E	; 0x80053e <gc_state+0x10>
    128c:	b0 91 3f 05 	lds	r27, 0x053F	; 0x80053f <gc_state+0x11>
    1290:	80 93 78 05 	sts	0x0578, r24	; 0x800578 <gc_block+0xb>
    1294:	90 93 79 05 	sts	0x0579, r25	; 0x800579 <gc_block+0xc>
    1298:	a0 93 7a 05 	sts	0x057A, r26	; 0x80057a <gc_block+0xd>
    129c:	b0 93 7b 05 	sts	0x057B, r27	; 0x80057b <gc_block+0xe>
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    12a0:	70 fc       	sbrc	r7, 0
    12a2:	10 c0       	rjmp	.+32     	; 0x12c4 <gc_execute_line+0x698>
    12a4:	80 91 38 05 	lds	r24, 0x0538	; 0x800538 <gc_state+0xa>
    12a8:	90 91 39 05 	lds	r25, 0x0539	; 0x800539 <gc_state+0xb>
    12ac:	a0 91 3a 05 	lds	r26, 0x053A	; 0x80053a <gc_state+0xc>
    12b0:	b0 91 3b 05 	lds	r27, 0x053B	; 0x80053b <gc_state+0xd>
    12b4:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <gc_block+0x28>
    12b8:	90 93 96 05 	sts	0x0596, r25	; 0x800596 <gc_block+0x29>
    12bc:	a0 93 97 05 	sts	0x0597, r26	; 0x800597 <gc_block+0x2a>
    12c0:	b0 93 98 05 	sts	0x0598, r27	; 0x800598 <gc_block+0x2b>
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    12c4:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <gc_block>
    12c8:	81 30       	cpi	r24, 0x01	; 1
    12ca:	21 f4       	brne	.+8      	; 0x12d4 <gc_execute_line+0x6a8>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    12cc:	66 fe       	sbrs	r6, 6
    12ce:	e7 c6       	rjmp	.+3534   	; 0x209e <gc_execute_line+0x1472>
    bit_false(value_words,bit(WORD_P));
    12d0:	e8 94       	clt
    12d2:	66 f8       	bld	r6, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    12d4:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <gc_block+0x5>
    12d8:	88 23       	and	r24, r24
    12da:	49 f0       	breq	.+18     	; 0x12ee <gc_execute_line+0x6c2>
    12dc:	81 30       	cpi	r24, 0x01	; 1
    12de:	09 f4       	brne	.+2      	; 0x12e2 <gc_execute_line+0x6b6>
    12e0:	4d c7       	rjmp	.+3738   	; 0x217c <gc_execute_line+0x1550>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    12e2:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    12e4:	f2 e0       	ldi	r31, 0x02	; 2
    12e6:	fd a3       	std	Y+37, r31	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    12e8:	21 e0       	ldi	r18, 0x01	; 1
    12ea:	2c a3       	std	Y+36, r18	; 0x24
    12ec:	4c c7       	rjmp	.+3736   	; 0x2186 <gc_execute_line+0x155a>
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    12ee:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x3>
    12f2:	81 30       	cpi	r24, 0x01	; 1
    12f4:	99 f5       	brne	.+102    	; 0x135c <gc_execute_line+0x730>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    12f6:	32 e0       	ldi	r19, 0x02	; 2
    12f8:	3e a3       	std	Y+38, r19	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    12fa:	8d a3       	std	Y+37, r24	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    12fc:	1c a2       	std	Y+36, r1	; 0x24
    12fe:	0f 2e       	mov	r0, r31
    1300:	fd e6       	ldi	r31, 0x6D	; 109
    1302:	af 2e       	mov	r10, r31
    1304:	f5 e0       	ldi	r31, 0x05	; 5
    1306:	bf 2e       	mov	r11, r31
    1308:	f0 2d       	mov	r31, r0
    130a:	00 e0       	ldi	r16, 0x00	; 0
    130c:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    130e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1310:	e9 2e       	mov	r14, r25
    1312:	f1 2c       	mov	r15, r1
    1314:	c7 01       	movw	r24, r14
    1316:	00 2e       	mov	r0, r16
    1318:	02 c0       	rjmp	.+4      	; 0x131e <gc_execute_line+0x6f2>
    131a:	95 95       	asr	r25
    131c:	87 95       	ror	r24
    131e:	0a 94       	dec	r0
    1320:	e2 f7       	brpl	.-8      	; 0x131a <gc_execute_line+0x6ee>
    1322:	80 ff       	sbrs	r24, 0
    1324:	12 c0       	rjmp	.+36     	; 0x134a <gc_execute_line+0x71e>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1326:	23 e3       	ldi	r18, 0x33	; 51
    1328:	33 e3       	ldi	r19, 0x33	; 51
    132a:	4b ec       	ldi	r20, 0xCB	; 203
    132c:	51 e4       	ldi	r21, 0x41	; 65
    132e:	d5 01       	movw	r26, r10
    1330:	9d 96       	adiw	r26, 0x2d	; 45
    1332:	6d 91       	ld	r22, X+
    1334:	7d 91       	ld	r23, X+
    1336:	8d 91       	ld	r24, X+
    1338:	9c 91       	ld	r25, X
    133a:	d0 97       	sbiw	r26, 0x30	; 48
    133c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1340:	f5 01       	movw	r30, r10
    1342:	65 a7       	std	Z+45, r22	; 0x2d
    1344:	76 a7       	std	Z+46, r23	; 0x2e
    1346:	87 a7       	std	Z+47, r24	; 0x2f
    1348:	90 ab       	std	Z+48, r25	; 0x30
    134a:	0f 5f       	subi	r16, 0xFF	; 255
    134c:	1f 4f       	sbci	r17, 0xFF	; 255
    134e:	f4 e0       	ldi	r31, 0x04	; 4
    1350:	af 0e       	add	r10, r31
    1352:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1354:	03 30       	cpi	r16, 0x03	; 3
    1356:	11 05       	cpc	r17, r1
    1358:	e9 f6       	brne	.-70     	; 0x1314 <gc_execute_line+0x6e8>
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <gc_execute_line+0x73a>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    135c:	22 e0       	ldi	r18, 0x02	; 2
    135e:	2e a3       	std	Y+38, r18	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1360:	31 e0       	ldi	r19, 0x01	; 1
    1362:	3d a3       	std	Y+37, r19	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1364:	1c a2       	std	Y+36, r1	; 0x24
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    1366:	8a a1       	ldd	r24, Y+34	; 0x22
    1368:	83 30       	cpi	r24, 0x03	; 3
    136a:	41 f4       	brne	.+16     	; 0x137c <gc_execute_line+0x750>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    136c:	80 91 73 05 	lds	r24, 0x0573	; 0x800573 <gc_block+0x6>
    1370:	81 30       	cpi	r24, 0x01	; 1
    1372:	21 f4       	brne	.+8      	; 0x137c <gc_execute_line+0x750>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    1374:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1376:	94 30       	cpi	r25, 0x04	; 4
    1378:	09 f0       	breq	.+2      	; 0x137c <gc_execute_line+0x750>
    137a:	93 c6       	rjmp	.+3366   	; 0x20a2 <gc_execute_line+0x1476>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    137c:	8c e0       	ldi	r24, 0x0C	; 12
    137e:	e1 e5       	ldi	r30, 0x51	; 81
    1380:	f5 e0       	ldi	r31, 0x05	; 5
    1382:	de 01       	movw	r26, r28
    1384:	11 96       	adiw	r26, 0x01	; 1
    1386:	01 90       	ld	r0, Z+
    1388:	0d 92       	st	X+, r0
    138a:	8a 95       	dec	r24
    138c:	e1 f7       	brne	.-8      	; 0x1386 <gc_execute_line+0x75a>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    138e:	d1 fe       	sbrs	r13, 1
    1390:	11 c0       	rjmp	.+34     	; 0x13b4 <gc_execute_line+0x788>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1392:	80 91 74 05 	lds	r24, 0x0574	; 0x800574 <gc_block+0x7>
    1396:	87 30       	cpi	r24, 0x07	; 7
    1398:	08 f0       	brcs	.+2      	; 0x139c <gc_execute_line+0x770>
    139a:	85 c6       	rjmp	.+3338   	; 0x20a6 <gc_execute_line+0x147a>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    139c:	90 91 34 05 	lds	r25, 0x0534	; 0x800534 <gc_state+0x6>
    13a0:	89 17       	cp	r24, r25
    13a2:	41 f0       	breq	.+16     	; 0x13b4 <gc_execute_line+0x788>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    13a4:	be 01       	movw	r22, r28
    13a6:	6f 5f       	subi	r22, 0xFF	; 255
    13a8:	7f 4f       	sbci	r23, 0xFF	; 255
    13aa:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    13ae:	88 23       	and	r24, r24
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <gc_execute_line+0x788>
    13b2:	7b c6       	rjmp	.+3318   	; 0x20aa <gc_execute_line+0x147e>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    13b4:	50 90 6d 05 	lds	r5, 0x056D	; 0x80056d <gc_block>
    13b8:	a2 e0       	ldi	r26, 0x02	; 2
    13ba:	5a 16       	cp	r5, r26
    13bc:	29 f0       	breq	.+10     	; 0x13c8 <gc_execute_line+0x79c>
    13be:	b8 e0       	ldi	r27, 0x08	; 8
    13c0:	5b 16       	cp	r5, r27
    13c2:	09 f4       	brne	.+2      	; 0x13c6 <gc_execute_line+0x79a>
    13c4:	a8 c0       	rjmp	.+336    	; 0x1516 <gc_execute_line+0x8ea>
    13c6:	1c c1       	rjmp	.+568    	; 0x1600 <gc_execute_line+0x9d4>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    13c8:	ee 8d       	ldd	r30, Y+30	; 0x1e
    13ca:	ee 23       	and	r30, r30
    13cc:	09 f4       	brne	.+2      	; 0x13d0 <gc_execute_line+0x7a4>
    13ce:	6f c6       	rjmp	.+3294   	; 0x20ae <gc_execute_line+0x1482>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    13d0:	c3 01       	movw	r24, r6
    13d2:	80 75       	andi	r24, 0x50	; 80
    13d4:	99 27       	eor	r25, r25
    13d6:	89 2b       	or	r24, r25
    13d8:	09 f4       	brne	.+2      	; 0x13dc <gc_execute_line+0x7b0>
    13da:	6b c6       	rjmp	.+3286   	; 0x20b2 <gc_execute_line+0x1486>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    13dc:	60 91 8d 05 	lds	r22, 0x058D	; 0x80058d <gc_block+0x20>
    13e0:	70 91 8e 05 	lds	r23, 0x058E	; 0x80058e <gc_block+0x21>
    13e4:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <gc_block+0x22>
    13e8:	90 91 90 05 	lds	r25, 0x0590	; 0x800590 <gc_block+0x23>
    13ec:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <trunc>
    13f0:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    13f4:	67 30       	cpi	r22, 0x07	; 7
    13f6:	08 f0       	brcs	.+2      	; 0x13fa <gc_execute_line+0x7ce>
    13f8:	5e c6       	rjmp	.+3260   	; 0x20b6 <gc_execute_line+0x148a>
      if (gc_block.values.l != 20) {
    13fa:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <gc_block+0x1b>
    13fe:	84 31       	cpi	r24, 0x14	; 20
    1400:	29 f0       	breq	.+10     	; 0x140c <gc_execute_line+0x7e0>
        if (gc_block.values.l == 2) {
    1402:	82 30       	cpi	r24, 0x02	; 2
    1404:	09 f0       	breq	.+2      	; 0x1408 <gc_execute_line+0x7dc>
    1406:	59 c6       	rjmp	.+3250   	; 0x20ba <gc_execute_line+0x148e>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1408:	67 fc       	sbrc	r6, 7
    140a:	59 c6       	rjmp	.+3250   	; 0x20be <gc_execute_line+0x1492>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    140c:	ff ea       	ldi	r31, 0xAF	; 175
    140e:	6f 22       	and	r6, r31
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1410:	66 23       	and	r22, r22
    1412:	19 f0       	breq	.+6      	; 0x141a <gc_execute_line+0x7ee>
    1414:	61 50       	subi	r22, 0x01	; 1
    1416:	6f a3       	std	Y+39, r22	; 0x27
    1418:	03 c0       	rjmp	.+6      	; 0x1420 <gc_execute_line+0x7f4>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    141a:	20 91 74 05 	lds	r18, 0x0574	; 0x800574 <gc_block+0x7>
    141e:	2f a3       	std	Y+39, r18	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1420:	be 01       	movw	r22, r28
    1422:	63 5f       	subi	r22, 0xF3	; 243
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	8f a1       	ldd	r24, Y+39	; 0x27
    1428:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    142c:	88 23       	and	r24, r24
    142e:	09 f4       	brne	.+2      	; 0x1432 <gc_execute_line+0x806>
    1430:	48 c6       	rjmp	.+3216   	; 0x20c2 <gc_execute_line+0x1496>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    1432:	30 90 88 05 	lds	r3, 0x0588	; 0x800588 <gc_block+0x1b>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    1436:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <gc_state+0x3b>
    143a:	90 91 6a 05 	lds	r25, 0x056A	; 0x80056a <gc_state+0x3c>
    143e:	a0 91 6b 05 	lds	r26, 0x056B	; 0x80056b <gc_state+0x3d>
    1442:	b0 91 6c 05 	lds	r27, 0x056C	; 0x80056c <gc_state+0x3e>
    1446:	88 a7       	std	Y+40, r24	; 0x28
    1448:	99 a7       	std	Y+41, r25	; 0x29
    144a:	aa a7       	std	Y+42, r26	; 0x2a
    144c:	bb a7       	std	Y+43, r27	; 0x2b
    144e:	8e 01       	movw	r16, r28
    1450:	03 5f       	subi	r16, 0xF3	; 243
    1452:	1f 4f       	sbci	r17, 0xFF	; 255
    1454:	0f 2e       	mov	r0, r31
    1456:	fd e6       	ldi	r31, 0x6D	; 109
    1458:	ef 2e       	mov	r14, r31
    145a:	f5 e0       	ldi	r31, 0x05	; 5
    145c:	ff 2e       	mov	r15, r31
    145e:	f0 2d       	mov	r31, r0
    1460:	0f 2e       	mov	r0, r31
    1462:	fe e2       	ldi	r31, 0x2E	; 46
    1464:	cf 2e       	mov	r12, r31
    1466:	f5 e0       	ldi	r31, 0x05	; 5
    1468:	df 2e       	mov	r13, r31
    146a:	f0 2d       	mov	r31, r0
    146c:	a1 2c       	mov	r10, r1
    146e:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1470:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1472:	89 2e       	mov	r8, r25
    1474:	91 2c       	mov	r9, r1
    1476:	c4 01       	movw	r24, r8
    1478:	0a 2c       	mov	r0, r10
    147a:	02 c0       	rjmp	.+4      	; 0x1480 <gc_execute_line+0x854>
    147c:	95 95       	asr	r25
    147e:	87 95       	ror	r24
    1480:	0a 94       	dec	r0
    1482:	e2 f7       	brpl	.-8      	; 0x147c <gc_execute_line+0x850>
    1484:	80 ff       	sbrs	r24, 0
    1486:	36 c0       	rjmp	.+108    	; 0x14f4 <gc_execute_line+0x8c8>
          if (gc_block.values.l == 20) {
    1488:	a4 e1       	ldi	r26, 0x14	; 20
    148a:	3a 12       	cpse	r3, r26
    148c:	29 c0       	rjmp	.+82     	; 0x14e0 <gc_execute_line+0x8b4>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    148e:	f6 01       	movw	r30, r12
    1490:	27 a5       	ldd	r18, Z+47	; 0x2f
    1492:	30 a9       	ldd	r19, Z+48	; 0x30
    1494:	41 a9       	ldd	r20, Z+49	; 0x31
    1496:	52 a9       	ldd	r21, Z+50	; 0x32
    1498:	67 89       	ldd	r22, Z+23	; 0x17
    149a:	70 8d       	ldd	r23, Z+24	; 0x18
    149c:	81 8d       	ldd	r24, Z+25	; 0x19
    149e:	92 8d       	ldd	r25, Z+26	; 0x1a
    14a0:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    14a4:	d7 01       	movw	r26, r14
    14a6:	9d 96       	adiw	r26, 0x2d	; 45
    14a8:	2d 91       	ld	r18, X+
    14aa:	3d 91       	ld	r19, X+
    14ac:	4d 91       	ld	r20, X+
    14ae:	5c 91       	ld	r21, X
    14b0:	d0 97       	sbiw	r26, 0x30	; 48
    14b2:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    14b6:	f8 01       	movw	r30, r16
    14b8:	60 83       	st	Z, r22
    14ba:	71 83       	std	Z+1, r23	; 0x01
    14bc:	82 83       	std	Z+2, r24	; 0x02
    14be:	93 83       	std	Z+3, r25	; 0x03
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    14c0:	f2 e0       	ldi	r31, 0x02	; 2
    14c2:	af 12       	cpse	r10, r31
    14c4:	17 c0       	rjmp	.+46     	; 0x14f4 <gc_execute_line+0x8c8>
    14c6:	28 a5       	ldd	r18, Y+40	; 0x28
    14c8:	39 a5       	ldd	r19, Y+41	; 0x29
    14ca:	4a a5       	ldd	r20, Y+42	; 0x2a
    14cc:	5b a5       	ldd	r21, Y+43	; 0x2b
    14ce:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    14d2:	d8 01       	movw	r26, r16
    14d4:	6d 93       	st	X+, r22
    14d6:	7d 93       	st	X+, r23
    14d8:	8d 93       	st	X+, r24
    14da:	9c 93       	st	X, r25
    14dc:	13 97       	sbiw	r26, 0x03	; 3
    14de:	0a c0       	rjmp	.+20     	; 0x14f4 <gc_execute_line+0x8c8>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    14e0:	f7 01       	movw	r30, r14
    14e2:	85 a5       	ldd	r24, Z+45	; 0x2d
    14e4:	96 a5       	ldd	r25, Z+46	; 0x2e
    14e6:	a7 a5       	ldd	r26, Z+47	; 0x2f
    14e8:	b0 a9       	ldd	r27, Z+48	; 0x30
    14ea:	f8 01       	movw	r30, r16
    14ec:	80 83       	st	Z, r24
    14ee:	91 83       	std	Z+1, r25	; 0x01
    14f0:	a2 83       	std	Z+2, r26	; 0x02
    14f2:	b3 83       	std	Z+3, r27	; 0x03
    14f4:	ff ef       	ldi	r31, 0xFF	; 255
    14f6:	af 1a       	sub	r10, r31
    14f8:	bf 0a       	sbc	r11, r31
    14fa:	0c 5f       	subi	r16, 0xFC	; 252
    14fc:	1f 4f       	sbci	r17, 0xFF	; 255
    14fe:	24 e0       	ldi	r18, 0x04	; 4
    1500:	e2 0e       	add	r14, r18
    1502:	f1 1c       	adc	r15, r1
    1504:	34 e0       	ldi	r19, 0x04	; 4
    1506:	c3 0e       	add	r12, r19
    1508:	d1 1c       	adc	r13, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    150a:	83 e0       	ldi	r24, 0x03	; 3
    150c:	a8 16       	cp	r10, r24
    150e:	b1 04       	cpc	r11, r1
    1510:	09 f0       	breq	.+2      	; 0x1514 <gc_execute_line+0x8e8>
    1512:	b1 cf       	rjmp	.-158    	; 0x1476 <gc_execute_line+0x84a>
    1514:	56 c6       	rjmp	.+3244   	; 0x21c2 <gc_execute_line+0x1596>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1516:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1518:	99 23       	and	r25, r25
    151a:	09 f4       	brne	.+2      	; 0x151e <gc_execute_line+0x8f2>
    151c:	d4 c5       	rjmp	.+2984   	; 0x20c6 <gc_execute_line+0x149a>
    151e:	0f 2e       	mov	r0, r31
    1520:	fe e2       	ldi	r31, 0x2E	; 46
    1522:	cf 2e       	mov	r12, r31
    1524:	f5 e0       	ldi	r31, 0x05	; 5
    1526:	df 2e       	mov	r13, r31
    1528:	f0 2d       	mov	r31, r0
    152a:	de 01       	movw	r26, r28
    152c:	11 96       	adiw	r26, 0x01	; 1
    152e:	5d 01       	movw	r10, r26
    1530:	0f 2e       	mov	r0, r31
    1532:	fd e6       	ldi	r31, 0x6D	; 109
    1534:	ef 2e       	mov	r14, r31
    1536:	f5 e0       	ldi	r31, 0x05	; 5
    1538:	ff 2e       	mov	r15, r31
    153a:	f0 2d       	mov	r31, r0
    153c:	00 e0       	ldi	r16, 0x00	; 0
    153e:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1540:	89 2e       	mov	r8, r25
    1542:	91 2c       	mov	r9, r1
    1544:	c4 01       	movw	r24, r8
    1546:	00 2e       	mov	r0, r16
    1548:	02 c0       	rjmp	.+4      	; 0x154e <gc_execute_line+0x922>
    154a:	95 95       	asr	r25
    154c:	87 95       	ror	r24
    154e:	0a 94       	dec	r0
    1550:	e2 f7       	brpl	.-8      	; 0x154a <gc_execute_line+0x91e>
    1552:	80 ff       	sbrs	r24, 0
    1554:	3a c0       	rjmp	.+116    	; 0x15ca <gc_execute_line+0x99e>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    1556:	f5 01       	movw	r30, r10
    1558:	20 81       	ld	r18, Z
    155a:	31 81       	ldd	r19, Z+1	; 0x01
    155c:	42 81       	ldd	r20, Z+2	; 0x02
    155e:	53 81       	ldd	r21, Z+3	; 0x03
    1560:	d6 01       	movw	r26, r12
    1562:	57 96       	adiw	r26, 0x17	; 23
    1564:	6d 91       	ld	r22, X+
    1566:	7d 91       	ld	r23, X+
    1568:	8d 91       	ld	r24, X+
    156a:	9c 91       	ld	r25, X
    156c:	5a 97       	sbiw	r26, 0x1a	; 26
    156e:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1572:	f7 01       	movw	r30, r14
    1574:	25 a5       	ldd	r18, Z+45	; 0x2d
    1576:	36 a5       	ldd	r19, Z+46	; 0x2e
    1578:	47 a5       	ldd	r20, Z+47	; 0x2f
    157a:	50 a9       	ldd	r21, Z+48	; 0x30
    157c:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1580:	d7 01       	movw	r26, r14
    1582:	9d 96       	adiw	r26, 0x2d	; 45
    1584:	6d 93       	st	X+, r22
    1586:	7d 93       	st	X+, r23
    1588:	8d 93       	st	X+, r24
    158a:	9c 93       	st	X, r25
    158c:	d0 97       	sbiw	r26, 0x30	; 48
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    158e:	02 30       	cpi	r16, 0x02	; 2
    1590:	31 f5       	brne	.+76     	; 0x15de <gc_execute_line+0x9b2>
    1592:	00 0f       	add	r16, r16
    1594:	11 1f       	adc	r17, r17
    1596:	00 0f       	add	r16, r16
    1598:	11 1f       	adc	r17, r17
    159a:	03 59       	subi	r16, 0x93	; 147
    159c:	1a 4f       	sbci	r17, 0xFA	; 250
    159e:	20 91 69 05 	lds	r18, 0x0569	; 0x800569 <gc_state+0x3b>
    15a2:	30 91 6a 05 	lds	r19, 0x056A	; 0x80056a <gc_state+0x3c>
    15a6:	40 91 6b 05 	lds	r20, 0x056B	; 0x80056b <gc_state+0x3d>
    15aa:	50 91 6c 05 	lds	r21, 0x056C	; 0x80056c <gc_state+0x3e>
    15ae:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    15b2:	f8 01       	movw	r30, r16
    15b4:	65 a7       	std	Z+45, r22	; 0x2d
    15b6:	76 a7       	std	Z+46, r23	; 0x2e
    15b8:	87 a7       	std	Z+47, r24	; 0x2f
    15ba:	90 ab       	std	Z+48, r25	; 0x30
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    15bc:	10 91 6e 05 	lds	r17, 0x056E	; 0x80056e <gc_block+0x1>
    15c0:	18 30       	cpi	r17, 0x08	; 8
    15c2:	09 f4       	brne	.+2      	; 0x15c6 <gc_execute_line+0x99a>
    15c4:	f2 c0       	rjmp	.+484    	; 0x17aa <gc_execute_line+0xb7e>
    15c6:	1f a2       	std	Y+39, r1	; 0x27
    15c8:	f7 c0       	rjmp	.+494    	; 0x17b8 <gc_execute_line+0xb8c>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    15ca:	f6 01       	movw	r30, r12
    15cc:	87 a5       	ldd	r24, Z+47	; 0x2f
    15ce:	90 a9       	ldd	r25, Z+48	; 0x30
    15d0:	a1 a9       	ldd	r26, Z+49	; 0x31
    15d2:	b2 a9       	ldd	r27, Z+50	; 0x32
    15d4:	f7 01       	movw	r30, r14
    15d6:	85 a7       	std	Z+45, r24	; 0x2d
    15d8:	96 a7       	std	Z+46, r25	; 0x2e
    15da:	a7 a7       	std	Z+47, r26	; 0x2f
    15dc:	b0 ab       	std	Z+48, r27	; 0x30
    15de:	0f 5f       	subi	r16, 0xFF	; 255
    15e0:	1f 4f       	sbci	r17, 0xFF	; 255
    15e2:	f4 e0       	ldi	r31, 0x04	; 4
    15e4:	cf 0e       	add	r12, r31
    15e6:	d1 1c       	adc	r13, r1
    15e8:	24 e0       	ldi	r18, 0x04	; 4
    15ea:	a2 0e       	add	r10, r18
    15ec:	b1 1c       	adc	r11, r1
    15ee:	34 e0       	ldi	r19, 0x04	; 4
    15f0:	e3 0e       	add	r14, r19
    15f2:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    15f4:	03 30       	cpi	r16, 0x03	; 3
    15f6:	11 05       	cpc	r17, r1
    15f8:	09 f0       	breq	.+2      	; 0x15fc <gc_execute_line+0x9d0>
    15fa:	a4 cf       	rjmp	.-184    	; 0x1544 <gc_execute_line+0x918>

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    15fc:	1f a2       	std	Y+39, r1	; 0x27
    15fe:	e1 c5       	rjmp	.+3010   	; 0x21c2 <gc_execute_line+0x1596>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    1600:	8a a1       	ldd	r24, Y+34	; 0x22
    1602:	83 30       	cpi	r24, 0x03	; 3
    1604:	09 f4       	brne	.+2      	; 0x1608 <gc_execute_line+0x9dc>
    1606:	9b c0       	rjmp	.+310    	; 0x173e <gc_execute_line+0xb12>
        if (axis_words) {
    1608:	9e 8d       	ldd	r25, Y+30	; 0x1e
    160a:	99 23       	and	r25, r25
    160c:	09 f4       	brne	.+2      	; 0x1610 <gc_execute_line+0x9e4>
    160e:	cd c5       	rjmp	.+2970   	; 0x21aa <gc_execute_line+0x157e>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1610:	40 90 71 05 	lds	r4, 0x0571	; 0x800571 <gc_block+0x4>
    1614:	0f 2e       	mov	r0, r31
    1616:	fe e2       	ldi	r31, 0x2E	; 46
    1618:	cf 2e       	mov	r12, r31
    161a:	f5 e0       	ldi	r31, 0x05	; 5
    161c:	df 2e       	mov	r13, r31
    161e:	f0 2d       	mov	r31, r0
    1620:	0f 2e       	mov	r0, r31
    1622:	fd e6       	ldi	r31, 0x6D	; 109
    1624:	ef 2e       	mov	r14, r31
    1626:	f5 e0       	ldi	r31, 0x05	; 5
    1628:	ff 2e       	mov	r15, r31
    162a:	f0 2d       	mov	r31, r0
    162c:	de 01       	movw	r26, r28
    162e:	11 96       	adiw	r26, 0x01	; 1
    1630:	5d 01       	movw	r10, r26
    1632:	00 e0       	ldi	r16, 0x00	; 0
    1634:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1636:	29 2e       	mov	r2, r25
    1638:	31 2c       	mov	r3, r1
    163a:	c1 01       	movw	r24, r2
    163c:	00 2e       	mov	r0, r16
    163e:	02 c0       	rjmp	.+4      	; 0x1644 <gc_execute_line+0xa18>
    1640:	95 95       	asr	r25
    1642:	87 95       	ror	r24
    1644:	0a 94       	dec	r0
    1646:	e2 f7       	brpl	.-8      	; 0x1640 <gc_execute_line+0xa14>
    1648:	80 fd       	sbrc	r24, 0
    164a:	0b c0       	rjmp	.+22     	; 0x1662 <gc_execute_line+0xa36>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    164c:	f6 01       	movw	r30, r12
    164e:	87 89       	ldd	r24, Z+23	; 0x17
    1650:	90 8d       	ldd	r25, Z+24	; 0x18
    1652:	a1 8d       	ldd	r26, Z+25	; 0x19
    1654:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1656:	f7 01       	movw	r30, r14
    1658:	85 a7       	std	Z+45, r24	; 0x2d
    165a:	96 a7       	std	Z+46, r25	; 0x2e
    165c:	a7 a7       	std	Z+47, r26	; 0x2f
    165e:	b0 ab       	std	Z+48, r27	; 0x30
    1660:	5e c0       	rjmp	.+188    	; 0x171e <gc_execute_line+0xaf2>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    1662:	f7 e0       	ldi	r31, 0x07	; 7
    1664:	5f 16       	cp	r5, r31
    1666:	09 f4       	brne	.+2      	; 0x166a <gc_execute_line+0xa3e>
    1668:	5a c0       	rjmp	.+180    	; 0x171e <gc_execute_line+0xaf2>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    166a:	41 10       	cpse	r4, r1
    166c:	43 c0       	rjmp	.+134    	; 0x16f4 <gc_execute_line+0xac8>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    166e:	d6 01       	movw	r26, r12
    1670:	9f 96       	adiw	r26, 0x2f	; 47
    1672:	2d 91       	ld	r18, X+
    1674:	3d 91       	ld	r19, X+
    1676:	4d 91       	ld	r20, X+
    1678:	5c 91       	ld	r21, X
    167a:	d2 97       	sbiw	r26, 0x32	; 50
    167c:	f5 01       	movw	r30, r10
    167e:	60 81       	ld	r22, Z
    1680:	71 81       	ldd	r23, Z+1	; 0x01
    1682:	82 81       	ldd	r24, Z+2	; 0x02
    1684:	93 81       	ldd	r25, Z+3	; 0x03
    1686:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    168a:	d7 01       	movw	r26, r14
    168c:	9d 96       	adiw	r26, 0x2d	; 45
    168e:	2d 91       	ld	r18, X+
    1690:	3d 91       	ld	r19, X+
    1692:	4d 91       	ld	r20, X+
    1694:	5c 91       	ld	r21, X
    1696:	d0 97       	sbiw	r26, 0x30	; 48
    1698:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    169c:	9b 01       	movw	r18, r22
    169e:	ac 01       	movw	r20, r24
    16a0:	f7 01       	movw	r30, r14
    16a2:	65 a7       	std	Z+45, r22	; 0x2d
    16a4:	76 a7       	std	Z+46, r23	; 0x2e
    16a6:	87 a7       	std	Z+47, r24	; 0x2f
    16a8:	90 ab       	std	Z+48, r25	; 0x30
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    16aa:	02 30       	cpi	r16, 0x02	; 2
    16ac:	c1 f5       	brne	.+112    	; 0x171e <gc_execute_line+0xaf2>
    16ae:	00 0f       	add	r16, r16
    16b0:	11 1f       	adc	r17, r17
    16b2:	00 0f       	add	r16, r16
    16b4:	11 1f       	adc	r17, r17
    16b6:	03 59       	subi	r16, 0x93	; 147
    16b8:	1a 4f       	sbci	r17, 0xFA	; 250
    16ba:	60 91 69 05 	lds	r22, 0x0569	; 0x800569 <gc_state+0x3b>
    16be:	70 91 6a 05 	lds	r23, 0x056A	; 0x80056a <gc_state+0x3c>
    16c2:	80 91 6b 05 	lds	r24, 0x056B	; 0x80056b <gc_state+0x3d>
    16c6:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <gc_state+0x3e>
    16ca:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    16ce:	d8 01       	movw	r26, r16
    16d0:	9d 96       	adiw	r26, 0x2d	; 45
    16d2:	6d 93       	st	X+, r22
    16d4:	7d 93       	st	X+, r23
    16d6:	8d 93       	st	X+, r24
    16d8:	9c 93       	st	X, r25
    16da:	d0 97       	sbiw	r26, 0x30	; 48
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    16dc:	b5 e0       	ldi	r27, 0x05	; 5
    16de:	5b 16       	cp	r5, r27
    16e0:	09 f4       	brne	.+2      	; 0x16e4 <gc_execute_line+0xab8>
    16e2:	46 c0       	rjmp	.+140    	; 0x1770 <gc_execute_line+0xb44>
    16e4:	e7 e0       	ldi	r30, 0x07	; 7
    16e6:	5e 16       	cp	r5, r30
    16e8:	09 f4       	brne	.+2      	; 0x16ec <gc_execute_line+0xac0>
    16ea:	50 c0       	rjmp	.+160    	; 0x178c <gc_execute_line+0xb60>
    16ec:	f3 e0       	ldi	r31, 0x03	; 3
    16ee:	5f 12       	cpse	r5, r31
    16f0:	52 c0       	rjmp	.+164    	; 0x1796 <gc_execute_line+0xb6a>
    16f2:	34 c0       	rjmp	.+104    	; 0x175c <gc_execute_line+0xb30>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    16f4:	d6 01       	movw	r26, r12
    16f6:	57 96       	adiw	r26, 0x17	; 23
    16f8:	2d 91       	ld	r18, X+
    16fa:	3d 91       	ld	r19, X+
    16fc:	4d 91       	ld	r20, X+
    16fe:	5c 91       	ld	r21, X
    1700:	5a 97       	sbiw	r26, 0x1a	; 26
    1702:	f7 01       	movw	r30, r14
    1704:	65 a5       	ldd	r22, Z+45	; 0x2d
    1706:	76 a5       	ldd	r23, Z+46	; 0x2e
    1708:	87 a5       	ldd	r24, Z+47	; 0x2f
    170a:	90 a9       	ldd	r25, Z+48	; 0x30
    170c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    1710:	d7 01       	movw	r26, r14
    1712:	9d 96       	adiw	r26, 0x2d	; 45
    1714:	6d 93       	st	X+, r22
    1716:	7d 93       	st	X+, r23
    1718:	8d 93       	st	X+, r24
    171a:	9c 93       	st	X, r25
    171c:	d0 97       	sbiw	r26, 0x30	; 48
    171e:	0f 5f       	subi	r16, 0xFF	; 255
    1720:	1f 4f       	sbci	r17, 0xFF	; 255
    1722:	b4 e0       	ldi	r27, 0x04	; 4
    1724:	cb 0e       	add	r12, r27
    1726:	d1 1c       	adc	r13, r1
    1728:	e4 e0       	ldi	r30, 0x04	; 4
    172a:	ee 0e       	add	r14, r30
    172c:	f1 1c       	adc	r15, r1
    172e:	f4 e0       	ldi	r31, 0x04	; 4
    1730:	af 0e       	add	r10, r31
    1732:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1734:	03 30       	cpi	r16, 0x03	; 3
    1736:	11 05       	cpc	r17, r1
    1738:	09 f0       	breq	.+2      	; 0x173c <gc_execute_line+0xb10>
    173a:	7f cf       	rjmp	.-258    	; 0x163a <gc_execute_line+0xa0e>
    173c:	2a c5       	rjmp	.+2644   	; 0x2192 <gc_execute_line+0x1566>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    173e:	25 e0       	ldi	r18, 0x05	; 5
    1740:	52 16       	cp	r5, r18
    1742:	b1 f0       	breq	.+44     	; 0x1770 <gc_execute_line+0xb44>
    1744:	37 e0       	ldi	r19, 0x07	; 7
    1746:	53 16       	cp	r5, r19
    1748:	09 f1       	breq	.+66     	; 0x178c <gc_execute_line+0xb60>
    174a:	83 e0       	ldi	r24, 0x03	; 3
    174c:	58 12       	cpse	r5, r24
    174e:	23 c0       	rjmp	.+70     	; 0x1796 <gc_execute_line+0xb6a>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    1750:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1752:	91 11       	cpse	r25, r1
    1754:	03 c0       	rjmp	.+6      	; 0x175c <gc_execute_line+0xb30>
    1756:	1a a2       	std	Y+34, r1	; 0x22
    1758:	01 c0       	rjmp	.+2      	; 0x175c <gc_execute_line+0xb30>
    175a:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    175c:	be 01       	movw	r22, r28
    175e:	63 5f       	subi	r22, 0xF3	; 243
    1760:	7f 4f       	sbci	r23, 0xFF	; 255
    1762:	86 e0       	ldi	r24, 0x06	; 6
    1764:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    1768:	88 23       	and	r24, r24
    176a:	09 f4       	brne	.+2      	; 0x176e <gc_execute_line+0xb42>
    176c:	ae c4       	rjmp	.+2396   	; 0x20ca <gc_execute_line+0x149e>
    176e:	13 c0       	rjmp	.+38     	; 0x1796 <gc_execute_line+0xb6a>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    1770:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1772:	a1 11       	cpse	r26, r1
    1774:	01 c0       	rjmp	.+2      	; 0x1778 <gc_execute_line+0xb4c>
    1776:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1778:	be 01       	movw	r22, r28
    177a:	63 5f       	subi	r22, 0xF3	; 243
    177c:	7f 4f       	sbci	r23, 0xFF	; 255
    177e:	87 e0       	ldi	r24, 0x07	; 7
    1780:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    1784:	88 23       	and	r24, r24
    1786:	09 f4       	brne	.+2      	; 0x178a <gc_execute_line+0xb5e>
    1788:	a2 c4       	rjmp	.+2372   	; 0x20ce <gc_execute_line+0x14a2>
    178a:	05 c0       	rjmp	.+10     	; 0x1796 <gc_execute_line+0xb6a>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    178c:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <gc_block+0x1>
    1790:	82 30       	cpi	r24, 0x02	; 2
    1792:	08 f0       	brcs	.+2      	; 0x1796 <gc_execute_line+0xb6a>
    1794:	9e c4       	rjmp	.+2364   	; 0x20d2 <gc_execute_line+0x14a6>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1796:	10 91 6e 05 	lds	r17, 0x056E	; 0x80056e <gc_block+0x1>
    179a:	18 30       	cpi	r17, 0x08	; 8
    179c:	61 f4       	brne	.+24     	; 0x17b6 <gc_execute_line+0xb8a>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    179e:	be 8d       	ldd	r27, Y+30	; 0x1e
    17a0:	bb 23       	and	r27, r27
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <gc_execute_line+0xb7a>
    17a4:	2f c2       	rjmp	.+1118   	; 0x1c04 <gc_execute_line+0xfd8>
    17a6:	1f a2       	std	Y+39, r1	; 0x27
    17a8:	01 c0       	rjmp	.+2      	; 0x17ac <gc_execute_line+0xb80>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    17aa:	1f a2       	std	Y+39, r1	; 0x27
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    17ac:	ea a1       	ldd	r30, Y+34	; 0x22
    17ae:	e1 30       	cpi	r30, 0x01	; 1
    17b0:	09 f0       	breq	.+2      	; 0x17b4 <gc_execute_line+0xb88>
    17b2:	91 c4       	rjmp	.+2338   	; 0x20d6 <gc_execute_line+0x14aa>
    17b4:	30 c2       	rjmp	.+1120   	; 0x1c16 <gc_execute_line+0xfea>
    17b6:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    17b8:	fa a1       	ldd	r31, Y+34	; 0x22
    17ba:	f2 30       	cpi	r31, 0x02	; 2
    17bc:	09 f0       	breq	.+2      	; 0x17c0 <gc_execute_line+0xb94>
    17be:	23 c2       	rjmp	.+1094   	; 0x1c06 <gc_execute_line+0xfda>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    17c0:	11 11       	cpse	r17, r1
    17c2:	05 c0       	rjmp	.+10     	; 0x17ce <gc_execute_line+0xba2>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    17c4:	2e 8d       	ldd	r18, Y+30	; 0x1e
    17c6:	22 23       	and	r18, r18
    17c8:	09 f4       	brne	.+2      	; 0x17cc <gc_execute_line+0xba0>
    17ca:	01 c5       	rjmp	.+2562   	; 0x21ce <gc_execute_line+0x15a2>
    17cc:	24 c2       	rjmp	.+1096   	; 0x1c16 <gc_execute_line+0xfea>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    17ce:	20 e0       	ldi	r18, 0x00	; 0
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	a9 01       	movw	r20, r18
    17d4:	60 91 78 05 	lds	r22, 0x0578	; 0x800578 <gc_block+0xb>
    17d8:	70 91 79 05 	lds	r23, 0x0579	; 0x800579 <gc_block+0xc>
    17dc:	80 91 7a 05 	lds	r24, 0x057A	; 0x80057a <gc_block+0xd>
    17e0:	90 91 7b 05 	lds	r25, 0x057B	; 0x80057b <gc_block+0xe>
    17e4:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    17e8:	88 23       	and	r24, r24
    17ea:	09 f4       	brne	.+2      	; 0x17ee <gc_execute_line+0xbc2>
    17ec:	76 c4       	rjmp	.+2284   	; 0x20da <gc_execute_line+0x14ae>
     
      switch (gc_block.modal.motion) {
    17ee:	14 30       	cpi	r17, 0x04	; 4
    17f0:	28 f4       	brcc	.+10     	; 0x17fc <gc_execute_line+0xbd0>
    17f2:	12 30       	cpi	r17, 0x02	; 2
    17f4:	60 f4       	brcc	.+24     	; 0x180e <gc_execute_line+0xbe2>
    17f6:	11 30       	cpi	r17, 0x01	; 1
    17f8:	29 f0       	breq	.+10     	; 0x1804 <gc_execute_line+0xbd8>
    17fa:	05 c2       	rjmp	.+1034   	; 0x1c06 <gc_execute_line+0xfda>
    17fc:	18 30       	cpi	r17, 0x08	; 8
    17fe:	08 f4       	brcc	.+2      	; 0x1802 <gc_execute_line+0xbd6>
    1800:	f4 c1       	rjmp	.+1000   	; 0x1bea <gc_execute_line+0xfbe>
    1802:	01 c2       	rjmp	.+1026   	; 0x1c06 <gc_execute_line+0xfda>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1804:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1806:	33 23       	and	r19, r19
    1808:	09 f4       	brne	.+2      	; 0x180c <gc_execute_line+0xbe0>
    180a:	e1 c4       	rjmp	.+2498   	; 0x21ce <gc_execute_line+0x15a2>
    180c:	04 c2       	rjmp	.+1032   	; 0x1c16 <gc_execute_line+0xfea>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    180e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1810:	88 23       	and	r24, r24
    1812:	09 f4       	brne	.+2      	; 0x1816 <gc_execute_line+0xbea>
    1814:	64 c4       	rjmp	.+2248   	; 0x20de <gc_execute_line+0x14b2>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1816:	9c a1       	ldd	r25, Y+36	; 0x24
    1818:	a9 2e       	mov	r10, r25
    181a:	b1 2c       	mov	r11, r1
    181c:	ad a1       	ldd	r26, Y+37	; 0x25
    181e:	8a 2e       	mov	r8, r26
    1820:	91 2c       	mov	r9, r1
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	8c 01       	movw	r16, r24
    1828:	0c a0       	ldd	r0, Y+36	; 0x24
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <gc_execute_line+0xc04>
    182c:	00 0f       	add	r16, r16
    182e:	11 1f       	adc	r17, r17
    1830:	0a 94       	dec	r0
    1832:	e2 f7       	brpl	.-8      	; 0x182c <gc_execute_line+0xc00>
    1834:	02 c0       	rjmp	.+4      	; 0x183a <gc_execute_line+0xc0e>
    1836:	88 0f       	add	r24, r24
    1838:	99 1f       	adc	r25, r25
    183a:	aa 95       	dec	r26
    183c:	e2 f7       	brpl	.-8      	; 0x1836 <gc_execute_line+0xc0a>
    183e:	08 2b       	or	r16, r24
    1840:	19 2b       	or	r17, r25
    1842:	be 8d       	ldd	r27, Y+30	; 0x1e
    1844:	8b 2f       	mov	r24, r27
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	80 23       	and	r24, r16
    184a:	91 23       	and	r25, r17
    184c:	89 2b       	or	r24, r25
    184e:	09 f4       	brne	.+2      	; 0x1852 <gc_execute_line+0xc26>
    1850:	48 c4       	rjmp	.+2192   	; 0x20e2 <gc_execute_line+0x14b6>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1852:	c5 01       	movw	r24, r10
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	88 0f       	add	r24, r24
    185a:	99 1f       	adc	r25, r25
    185c:	fc 01       	movw	r30, r24
    185e:	e3 59       	subi	r30, 0x93	; 147
    1860:	fa 4f       	sbci	r31, 0xFA	; 250
    1862:	dc 01       	movw	r26, r24
    1864:	a2 5d       	subi	r26, 0xD2	; 210
    1866:	ba 4f       	sbci	r27, 0xFA	; 250
    1868:	57 96       	adiw	r26, 0x17	; 23
    186a:	2d 91       	ld	r18, X+
    186c:	3d 91       	ld	r19, X+
    186e:	4d 91       	ld	r20, X+
    1870:	5c 91       	ld	r21, X
    1872:	5a 97       	sbiw	r26, 0x1a	; 26
    1874:	65 a5       	ldd	r22, Z+45	; 0x2d
    1876:	76 a5       	ldd	r23, Z+46	; 0x2e
    1878:	87 a5       	ldd	r24, Z+47	; 0x2f
    187a:	90 a9       	ldd	r25, Z+48	; 0x30
    187c:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1880:	6e 8f       	std	Y+30, r22	; 0x1e
    1882:	7f 8f       	std	Y+31, r23	; 0x1f
    1884:	88 a3       	std	Y+32, r24	; 0x20
    1886:	99 a3       	std	Y+33, r25	; 0x21
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1888:	c4 01       	movw	r24, r8
    188a:	88 0f       	add	r24, r24
    188c:	99 1f       	adc	r25, r25
    188e:	88 0f       	add	r24, r24
    1890:	99 1f       	adc	r25, r25
    1892:	fc 01       	movw	r30, r24
    1894:	e3 59       	subi	r30, 0x93	; 147
    1896:	fa 4f       	sbci	r31, 0xFA	; 250
    1898:	dc 01       	movw	r26, r24
    189a:	a2 5d       	subi	r26, 0xD2	; 210
    189c:	ba 4f       	sbci	r27, 0xFA	; 250
    189e:	57 96       	adiw	r26, 0x17	; 23
    18a0:	2d 91       	ld	r18, X+
    18a2:	3d 91       	ld	r19, X+
    18a4:	4d 91       	ld	r20, X+
    18a6:	5c 91       	ld	r21, X
    18a8:	5a 97       	sbiw	r26, 0x1a	; 26
    18aa:	65 a5       	ldd	r22, Z+45	; 0x2d
    18ac:	76 a5       	ldd	r23, Z+46	; 0x2e
    18ae:	87 a5       	ldd	r24, Z+47	; 0x2f
    18b0:	90 a9       	ldd	r25, Z+48	; 0x30
    18b2:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    18b6:	68 a7       	std	Y+40, r22	; 0x28
    18b8:	79 a7       	std	Y+41, r23	; 0x29
    18ba:	8a a7       	std	Y+42, r24	; 0x2a
    18bc:	9b a7       	std	Y+43, r25	; 0x2b

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    18be:	67 fe       	sbrs	r6, 7
    18c0:	e6 c0       	rjmp	.+460    	; 0x1a8e <gc_execute_line+0xe62>
            bit_false(value_words,bit(WORD_R));
    18c2:	e8 94       	clt
    18c4:	67 f8       	bld	r6, 7
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    18c6:	6a e9       	ldi	r22, 0x9A	; 154
    18c8:	75 e0       	ldi	r23, 0x05	; 5
    18ca:	85 e4       	ldi	r24, 0x45	; 69
    18cc:	95 e0       	ldi	r25, 0x05	; 5
    18ce:	0e 94 d5 05 	call	0xbaa	; 0xbaa <gc_check_same_position>
    18d2:	81 11       	cpse	r24, r1
    18d4:	08 c4       	rjmp	.+2064   	; 0x20e6 <gc_execute_line+0x14ba>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    18d6:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x3>
    18da:	81 30       	cpi	r24, 0x01	; 1
    18dc:	a1 f4       	brne	.+40     	; 0x1906 <gc_execute_line+0xcda>
    18de:	0d e6       	ldi	r16, 0x6D	; 109
    18e0:	15 e0       	ldi	r17, 0x05	; 5
    18e2:	23 e3       	ldi	r18, 0x33	; 51
    18e4:	33 e3       	ldi	r19, 0x33	; 51
    18e6:	4b ec       	ldi	r20, 0xCB	; 203
    18e8:	51 e4       	ldi	r21, 0x41	; 65
    18ea:	f8 01       	movw	r30, r16
    18ec:	64 a1       	ldd	r22, Z+36	; 0x24
    18ee:	75 a1       	ldd	r23, Z+37	; 0x25
    18f0:	86 a1       	ldd	r24, Z+38	; 0x26
    18f2:	97 a1       	ldd	r25, Z+39	; 0x27
    18f4:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    18f8:	d8 01       	movw	r26, r16
    18fa:	94 96       	adiw	r26, 0x24	; 36
    18fc:	6d 93       	st	X+, r22
    18fe:	7d 93       	st	X+, r23
    1900:	8d 93       	st	X+, r24
    1902:	9c 93       	st	X, r25
    1904:	97 97       	sbiw	r26, 0x27	; 39
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1906:	c0 90 91 05 	lds	r12, 0x0591	; 0x800591 <gc_block+0x24>
    190a:	d0 90 92 05 	lds	r13, 0x0592	; 0x800592 <gc_block+0x25>
    190e:	e0 90 93 05 	lds	r14, 0x0593	; 0x800593 <gc_block+0x26>
    1912:	f0 90 94 05 	lds	r15, 0x0594	; 0x800594 <gc_block+0x27>
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	40 e8       	ldi	r20, 0x80	; 128
    191c:	50 e4       	ldi	r21, 0x40	; 64
    191e:	c7 01       	movw	r24, r14
    1920:	b6 01       	movw	r22, r12
    1922:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1926:	a7 01       	movw	r20, r14
    1928:	96 01       	movw	r18, r12
    192a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    192e:	6b 01       	movw	r12, r22
    1930:	7c 01       	movw	r14, r24
    1932:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1934:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1936:	48 a1       	ldd	r20, Y+32	; 0x20
    1938:	59 a1       	ldd	r21, Y+33	; 0x21
    193a:	ca 01       	movw	r24, r20
    193c:	b9 01       	movw	r22, r18
    193e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1942:	9b 01       	movw	r18, r22
    1944:	ac 01       	movw	r20, r24
    1946:	c7 01       	movw	r24, r14
    1948:	b6 01       	movw	r22, r12
    194a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    194e:	6b 01       	movw	r12, r22
    1950:	7c 01       	movw	r14, r24
    1952:	28 a5       	ldd	r18, Y+40	; 0x28
    1954:	39 a5       	ldd	r19, Y+41	; 0x29
    1956:	4a a5       	ldd	r20, Y+42	; 0x2a
    1958:	5b a5       	ldd	r21, Y+43	; 0x2b
    195a:	ca 01       	movw	r24, r20
    195c:	b9 01       	movw	r22, r18
    195e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1962:	9b 01       	movw	r18, r22
    1964:	ac 01       	movw	r20, r24
    1966:	c7 01       	movw	r24, r14
    1968:	b6 01       	movw	r22, r12
    196a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    196e:	6b 01       	movw	r12, r22
    1970:	7c 01       	movw	r14, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1972:	20 e0       	ldi	r18, 0x00	; 0
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	a9 01       	movw	r20, r18
    1978:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    197c:	88 23       	and	r24, r24
    197e:	0c f4       	brge	.+2      	; 0x1982 <gc_execute_line+0xd56>
    1980:	b4 c3       	rjmp	.+1896   	; 0x20ea <gc_execute_line+0x14be>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1982:	c7 01       	movw	r24, r14
    1984:	b6 01       	movw	r22, r12
    1986:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    198a:	6b 01       	movw	r12, r22
    198c:	7c 01       	movw	r14, r24
    198e:	28 a5       	ldd	r18, Y+40	; 0x28
    1990:	39 a5       	ldd	r19, Y+41	; 0x29
    1992:	4a a5       	ldd	r20, Y+42	; 0x2a
    1994:	5b a5       	ldd	r21, Y+43	; 0x2b
    1996:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1998:	7f 8d       	ldd	r23, Y+31	; 0x1f
    199a:	88 a1       	ldd	r24, Y+32	; 0x20
    199c:	99 a1       	ldd	r25, Y+33	; 0x21
    199e:	0e 94 3d 19 	call	0x327a	; 0x327a <hypot_f>
    19a2:	9b 01       	movw	r18, r22
    19a4:	ac 01       	movw	r20, r24
    19a6:	c7 01       	movw	r24, r14
    19a8:	b6 01       	movw	r22, r12
    19aa:	90 58       	subi	r25, 0x80	; 128
    19ac:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    19b0:	6b 01       	movw	r12, r22
    19b2:	7c 01       	movw	r14, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    19b4:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <gc_block+0x1>
    19b8:	83 30       	cpi	r24, 0x03	; 3
    19ba:	21 f4       	brne	.+8      	; 0x19c4 <gc_execute_line+0xd98>
    19bc:	f7 fa       	bst	r15, 7
    19be:	f0 94       	com	r15
    19c0:	f7 f8       	bld	r15, 7
    19c2:	f0 94       	com	r15
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    19c4:	20 90 91 05 	lds	r2, 0x0591	; 0x800591 <gc_block+0x24>
    19c8:	30 90 92 05 	lds	r3, 0x0592	; 0x800592 <gc_block+0x25>
    19cc:	40 90 93 05 	lds	r4, 0x0593	; 0x800593 <gc_block+0x26>
    19d0:	50 90 94 05 	lds	r5, 0x0594	; 0x800594 <gc_block+0x27>
    19d4:	20 e0       	ldi	r18, 0x00	; 0
    19d6:	30 e0       	ldi	r19, 0x00	; 0
    19d8:	a9 01       	movw	r20, r18
    19da:	c2 01       	movw	r24, r4
    19dc:	b1 01       	movw	r22, r2
    19de:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    19e2:	88 23       	and	r24, r24
    19e4:	7c f4       	brge	.+30     	; 0x1a04 <gc_execute_line+0xdd8>
                h_x2_div_d = -h_x2_div_d; 
    19e6:	f7 fa       	bst	r15, 7
    19e8:	f0 94       	com	r15
    19ea:	f7 f8       	bld	r15, 7
    19ec:	f0 94       	com	r15
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    19ee:	d2 01       	movw	r26, r4
    19f0:	c1 01       	movw	r24, r2
    19f2:	b0 58       	subi	r27, 0x80	; 128
    19f4:	80 93 91 05 	sts	0x0591, r24	; 0x800591 <gc_block+0x24>
    19f8:	90 93 92 05 	sts	0x0592, r25	; 0x800592 <gc_block+0x25>
    19fc:	a0 93 93 05 	sts	0x0593, r26	; 0x800593 <gc_block+0x26>
    1a00:	b0 93 94 05 	sts	0x0594, r27	; 0x800594 <gc_block+0x27>
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1a04:	85 01       	movw	r16, r10
    1a06:	00 0f       	add	r16, r16
    1a08:	11 1f       	adc	r17, r17
    1a0a:	00 0f       	add	r16, r16
    1a0c:	11 1f       	adc	r17, r17
    1a0e:	0f 58       	subi	r16, 0x8F	; 143
    1a10:	1a 4f       	sbci	r17, 0xFA	; 250
    1a12:	28 a5       	ldd	r18, Y+40	; 0x28
    1a14:	39 a5       	ldd	r19, Y+41	; 0x29
    1a16:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a18:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a1a:	c7 01       	movw	r24, r14
    1a1c:	b6 01       	movw	r22, r12
    1a1e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1a22:	9b 01       	movw	r18, r22
    1a24:	ac 01       	movw	r20, r24
    1a26:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1a28:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1a2a:	88 a1       	ldd	r24, Y+32	; 0x20
    1a2c:	99 a1       	ldd	r25, Y+33	; 0x21
    1a2e:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1a32:	20 e0       	ldi	r18, 0x00	; 0
    1a34:	30 e0       	ldi	r19, 0x00	; 0
    1a36:	40 e0       	ldi	r20, 0x00	; 0
    1a38:	5f e3       	ldi	r21, 0x3F	; 63
    1a3a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1a3e:	f8 01       	movw	r30, r16
    1a40:	63 87       	std	Z+11, r22	; 0x0b
    1a42:	74 87       	std	Z+12, r23	; 0x0c
    1a44:	85 87       	std	Z+13, r24	; 0x0d
    1a46:	96 87       	std	Z+14, r25	; 0x0e
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1a48:	84 01       	movw	r16, r8
    1a4a:	00 0f       	add	r16, r16
    1a4c:	11 1f       	adc	r17, r17
    1a4e:	00 0f       	add	r16, r16
    1a50:	11 1f       	adc	r17, r17
    1a52:	0f 58       	subi	r16, 0x8F	; 143
    1a54:	1a 4f       	sbci	r17, 0xFA	; 250
    1a56:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1a58:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1a5a:	48 a1       	ldd	r20, Y+32	; 0x20
    1a5c:	59 a1       	ldd	r21, Y+33	; 0x21
    1a5e:	c7 01       	movw	r24, r14
    1a60:	b6 01       	movw	r22, r12
    1a62:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1a66:	28 a5       	ldd	r18, Y+40	; 0x28
    1a68:	39 a5       	ldd	r19, Y+41	; 0x29
    1a6a:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a6c:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a6e:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	40 e0       	ldi	r20, 0x00	; 0
    1a78:	5f e3       	ldi	r21, 0x3F	; 63
    1a7a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1a7e:	d8 01       	movw	r26, r16
    1a80:	1b 96       	adiw	r26, 0x0b	; 11
    1a82:	6d 93       	st	X+, r22
    1a84:	7d 93       	st	X+, r23
    1a86:	8d 93       	st	X+, r24
    1a88:	9c 93       	st	X, r25
    1a8a:	1e 97       	sbiw	r26, 0x0e	; 14
    1a8c:	c4 c0       	rjmp	.+392    	; 0x1c16 <gc_execute_line+0xfea>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1a8e:	bb a1       	ldd	r27, Y+35	; 0x23
    1a90:	cb 2e       	mov	r12, r27
    1a92:	d1 2c       	mov	r13, r1
    1a94:	0c 21       	and	r16, r12
    1a96:	1d 21       	and	r17, r13
    1a98:	01 2b       	or	r16, r17
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <gc_execute_line+0xe72>
    1a9c:	28 c3       	rjmp	.+1616   	; 0x20ee <gc_execute_line+0x14c2>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    1a9e:	e1 ef       	ldi	r30, 0xF1	; 241
    1aa0:	6e 22       	and	r6, r30
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1aa2:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x3>
    1aa6:	81 30       	cpi	r24, 0x01	; 1
    1aa8:	41 f5       	brne	.+80     	; 0x1afa <gc_execute_line+0xece>
    1aaa:	0d e6       	ldi	r16, 0x6D	; 109
    1aac:	15 e0       	ldi	r17, 0x05	; 5
    1aae:	e1 2c       	mov	r14, r1
    1ab0:	f1 2c       	mov	r15, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1ab2:	c6 01       	movw	r24, r12
    1ab4:	0e 2c       	mov	r0, r14
    1ab6:	02 c0       	rjmp	.+4      	; 0x1abc <gc_execute_line+0xe90>
    1ab8:	95 95       	asr	r25
    1aba:	87 95       	ror	r24
    1abc:	0a 94       	dec	r0
    1abe:	e2 f7       	brpl	.-8      	; 0x1ab8 <gc_execute_line+0xe8c>
    1ac0:	80 ff       	sbrs	r24, 0
    1ac2:	12 c0       	rjmp	.+36     	; 0x1ae8 <gc_execute_line+0xebc>
    1ac4:	23 e3       	ldi	r18, 0x33	; 51
    1ac6:	33 e3       	ldi	r19, 0x33	; 51
    1ac8:	4b ec       	ldi	r20, 0xCB	; 203
    1aca:	51 e4       	ldi	r21, 0x41	; 65
    1acc:	d8 01       	movw	r26, r16
    1ace:	1f 96       	adiw	r26, 0x0f	; 15
    1ad0:	6d 91       	ld	r22, X+
    1ad2:	7d 91       	ld	r23, X+
    1ad4:	8d 91       	ld	r24, X+
    1ad6:	9c 91       	ld	r25, X
    1ad8:	52 97       	sbiw	r26, 0x12	; 18
    1ada:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1ade:	f8 01       	movw	r30, r16
    1ae0:	67 87       	std	Z+15, r22	; 0x0f
    1ae2:	70 8b       	std	Z+16, r23	; 0x10
    1ae4:	81 8b       	std	Z+17, r24	; 0x11
    1ae6:	92 8b       	std	Z+18, r25	; 0x12
    1ae8:	ff ef       	ldi	r31, 0xFF	; 255
    1aea:	ef 1a       	sub	r14, r31
    1aec:	ff 0a       	sbc	r15, r31
    1aee:	0c 5f       	subi	r16, 0xFC	; 252
    1af0:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1af2:	23 e0       	ldi	r18, 0x03	; 3
    1af4:	e2 16       	cp	r14, r18
    1af6:	f1 04       	cpc	r15, r1
    1af8:	e1 f6       	brne	.-72     	; 0x1ab2 <gc_execute_line+0xe86>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1afa:	c4 01       	movw	r24, r8
    1afc:	88 0f       	add	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	dc 01       	movw	r26, r24
    1b06:	af 58       	subi	r26, 0x8F	; 143
    1b08:	ba 4f       	sbci	r27, 0xFA	; 250
    1b0a:	7d 01       	movw	r14, r26
            float target_r = hypot_f(x,y); 
    1b0c:	1b 96       	adiw	r26, 0x0b	; 11
    1b0e:	2d 91       	ld	r18, X+
    1b10:	3d 91       	ld	r19, X+
    1b12:	4d 91       	ld	r20, X+
    1b14:	5c 91       	ld	r21, X
    1b16:	1e 97       	sbiw	r26, 0x0e	; 14
    1b18:	68 a5       	ldd	r22, Y+40	; 0x28
    1b1a:	79 a5       	ldd	r23, Y+41	; 0x29
    1b1c:	8a a5       	ldd	r24, Y+42	; 0x2a
    1b1e:	9b a5       	ldd	r25, Y+43	; 0x2b
    1b20:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1b24:	1b 01       	movw	r2, r22
    1b26:	2c 01       	movw	r4, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1b28:	85 01       	movw	r16, r10
    1b2a:	00 0f       	add	r16, r16
    1b2c:	11 1f       	adc	r17, r17
    1b2e:	00 0f       	add	r16, r16
    1b30:	11 1f       	adc	r17, r17
    1b32:	0f 58       	subi	r16, 0x8F	; 143
    1b34:	1a 4f       	sbci	r17, 0xFA	; 250
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    1b36:	f8 01       	movw	r30, r16
    1b38:	23 85       	ldd	r18, Z+11	; 0x0b
    1b3a:	34 85       	ldd	r19, Z+12	; 0x0c
    1b3c:	45 85       	ldd	r20, Z+13	; 0x0d
    1b3e:	56 85       	ldd	r21, Z+14	; 0x0e
    1b40:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1b42:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1b44:	88 a1       	ldd	r24, Y+32	; 0x20
    1b46:	99 a1       	ldd	r25, Y+33	; 0x21
    1b48:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1b4c:	a2 01       	movw	r20, r4
    1b4e:	91 01       	movw	r18, r2
    1b50:	0e 94 3d 19 	call	0x327a	; 0x327a <hypot_f>
    1b54:	4b 01       	movw	r8, r22
    1b56:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    1b58:	d7 01       	movw	r26, r14
    1b5a:	1b 96       	adiw	r26, 0x0b	; 11
    1b5c:	2d 91       	ld	r18, X+
    1b5e:	3d 91       	ld	r19, X+
    1b60:	4d 91       	ld	r20, X+
    1b62:	5c 91       	ld	r21, X
    1b64:	1e 97       	sbiw	r26, 0x0e	; 14
    1b66:	f8 01       	movw	r30, r16
    1b68:	63 85       	ldd	r22, Z+11	; 0x0b
    1b6a:	74 85       	ldd	r23, Z+12	; 0x0c
    1b6c:	85 85       	ldd	r24, Z+13	; 0x0d
    1b6e:	96 85       	ldd	r25, Z+14	; 0x0e
    1b70:	0e 94 3d 19 	call	0x327a	; 0x327a <hypot_f>
    1b74:	6b 01       	movw	r12, r22
    1b76:	7c 01       	movw	r14, r24
    1b78:	60 93 91 05 	sts	0x0591, r22	; 0x800591 <gc_block+0x24>
    1b7c:	70 93 92 05 	sts	0x0592, r23	; 0x800592 <gc_block+0x25>
    1b80:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <gc_block+0x26>
    1b84:	90 93 94 05 	sts	0x0594, r25	; 0x800594 <gc_block+0x27>
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1b88:	9b 01       	movw	r18, r22
    1b8a:	ac 01       	movw	r20, r24
    1b8c:	c5 01       	movw	r24, r10
    1b8e:	b4 01       	movw	r22, r8
    1b90:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    1b94:	4b 01       	movw	r8, r22
    1b96:	5c 01       	movw	r10, r24
    1b98:	e8 94       	clt
    1b9a:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) { 
    1b9c:	2a e0       	ldi	r18, 0x0A	; 10
    1b9e:	37 ed       	ldi	r19, 0xD7	; 215
    1ba0:	43 ea       	ldi	r20, 0xA3	; 163
    1ba2:	5b e3       	ldi	r21, 0x3B	; 59
    1ba4:	c5 01       	movw	r24, r10
    1ba6:	b4 01       	movw	r22, r8
    1ba8:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    1bac:	18 16       	cp	r1, r24
    1bae:	9c f5       	brge	.+102    	; 0x1c16 <gc_execute_line+0xfea>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1bb0:	20 e0       	ldi	r18, 0x00	; 0
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	40 e0       	ldi	r20, 0x00	; 0
    1bb6:	5f e3       	ldi	r21, 0x3F	; 63
    1bb8:	c5 01       	movw	r24, r10
    1bba:	b4 01       	movw	r22, r8
    1bbc:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    1bc0:	18 16       	cp	r1, r24
    1bc2:	0c f4       	brge	.+2      	; 0x1bc6 <gc_execute_line+0xf9a>
    1bc4:	96 c2       	rjmp	.+1324   	; 0x20f2 <gc_execute_line+0x14c6>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1bc6:	2f e6       	ldi	r18, 0x6F	; 111
    1bc8:	32 e1       	ldi	r19, 0x12	; 18
    1bca:	43 e8       	ldi	r20, 0x83	; 131
    1bcc:	5a e3       	ldi	r21, 0x3A	; 58
    1bce:	c7 01       	movw	r24, r14
    1bd0:	b6 01       	movw	r22, r12
    1bd2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    1bd6:	9b 01       	movw	r18, r22
    1bd8:	ac 01       	movw	r20, r24
    1bda:	c5 01       	movw	r24, r10
    1bdc:	b4 01       	movw	r22, r8
    1bde:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    1be2:	18 16       	cp	r1, r24
    1be4:	0c f4       	brge	.+2      	; 0x1be8 <gc_execute_line+0xfbc>
    1be6:	87 c2       	rjmp	.+1294   	; 0x20f6 <gc_execute_line+0x14ca>
    1be8:	16 c0       	rjmp	.+44     	; 0x1c16 <gc_execute_line+0xfea>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1bea:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1bec:	ff 23       	and	r31, r31
    1bee:	09 f4       	brne	.+2      	; 0x1bf2 <gc_execute_line+0xfc6>
    1bf0:	84 c2       	rjmp	.+1288   	; 0x20fa <gc_execute_line+0x14ce>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1bf2:	6a e9       	ldi	r22, 0x9A	; 154
    1bf4:	75 e0       	ldi	r23, 0x05	; 5
    1bf6:	85 e4       	ldi	r24, 0x45	; 69
    1bf8:	95 e0       	ldi	r25, 0x05	; 5
    1bfa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <gc_check_same_position>
    1bfe:	81 11       	cpse	r24, r1
    1c00:	7e c2       	rjmp	.+1276   	; 0x20fe <gc_execute_line+0x14d2>
    1c02:	09 c0       	rjmp	.+18     	; 0x1c16 <gc_execute_line+0xfea>
    1c04:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1c06:	2a a1       	ldd	r18, Y+34	; 0x22
    1c08:	21 11       	cpse	r18, r1
    1c0a:	05 c0       	rjmp	.+10     	; 0x1c16 <gc_execute_line+0xfea>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    1c0c:	3e ed       	ldi	r19, 0xDE	; 222
    1c0e:	63 22       	and	r6, r19
    1c10:	3c ef       	ldi	r19, 0xFC	; 252
    1c12:	73 22       	and	r7, r19
    1c14:	04 c0       	rjmp	.+8      	; 0x1c1e <gc_execute_line+0xff2>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1c16:	8e ed       	ldi	r24, 0xDE	; 222
    1c18:	68 22       	and	r6, r24
    1c1a:	80 ee       	ldi	r24, 0xE0	; 224
    1c1c:	78 22       	and	r7, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1c1e:	67 28       	or	r6, r7
    1c20:	09 f0       	breq	.+2      	; 0x1c24 <gc_execute_line+0xff8>
    1c22:	6f c2       	rjmp	.+1246   	; 0x2102 <gc_execute_line+0x14d6>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    1c24:	ee e2       	ldi	r30, 0x2E	; 46
    1c26:	f5 e0       	ldi	r31, 0x05	; 5
    1c28:	ad e6       	ldi	r26, 0x6D	; 109
    1c2a:	b5 e0       	ldi	r27, 0x05	; 5
    1c2c:	5c 96       	adiw	r26, 0x1c	; 28
    1c2e:	4d 91       	ld	r20, X+
    1c30:	5d 91       	ld	r21, X+
    1c32:	6d 91       	ld	r22, X+
    1c34:	7c 91       	ld	r23, X
    1c36:	5f 97       	sbiw	r26, 0x1f	; 31
    1c38:	43 8b       	std	Z+19, r20	; 0x13
    1c3a:	54 8b       	std	Z+20, r21	; 0x14
    1c3c:	65 8b       	std	Z+21, r22	; 0x15
    1c3e:	76 8b       	std	Z+22, r23	; 0x16
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1c40:	12 96       	adiw	r26, 0x02	; 2
    1c42:	8c 91       	ld	r24, X
    1c44:	12 97       	sbiw	r26, 0x02	; 2
    1c46:	81 83       	std	Z+1, r24	; 0x01
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1c48:	1b 96       	adiw	r26, 0x0b	; 11
    1c4a:	4d 91       	ld	r20, X+
    1c4c:	5d 91       	ld	r21, X+
    1c4e:	6d 91       	ld	r22, X+
    1c50:	7c 91       	ld	r23, X
    1c52:	1e 97       	sbiw	r26, 0x0e	; 14
    1c54:	46 87       	std	Z+14, r20	; 0x0e
    1c56:	57 87       	std	Z+15, r21	; 0x0f
    1c58:	60 8b       	std	Z+16, r22	; 0x10
    1c5a:	71 8b       	std	Z+17, r23	; 0x11

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    1c5c:	98 96       	adiw	r26, 0x28	; 40
    1c5e:	cd 90       	ld	r12, X+
    1c60:	dd 90       	ld	r13, X+
    1c62:	ed 90       	ld	r14, X+
    1c64:	fc 90       	ld	r15, X
    1c66:	9b 97       	sbiw	r26, 0x2b	; 43
    1c68:	a7 01       	movw	r20, r14
    1c6a:	96 01       	movw	r18, r12
    1c6c:	62 85       	ldd	r22, Z+10	; 0x0a
    1c6e:	73 85       	ldd	r23, Z+11	; 0x0b
    1c70:	84 85       	ldd	r24, Z+12	; 0x0c
    1c72:	95 85       	ldd	r25, Z+13	; 0x0d
    1c74:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    1c78:	88 23       	and	r24, r24
    1c7a:	c1 f0       	breq	.+48     	; 0x1cac <gc_execute_line+0x1080>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    1c7c:	80 91 37 05 	lds	r24, 0x0537	; 0x800537 <gc_state+0x9>
    1c80:	88 23       	and	r24, r24
    1c82:	21 f0       	breq	.+8      	; 0x1c8c <gc_execute_line+0x1060>
    1c84:	b7 01       	movw	r22, r14
    1c86:	a6 01       	movw	r20, r12
    1c88:	0e 94 36 2c 	call	0x586c	; 0x586c <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    1c8c:	80 91 95 05 	lds	r24, 0x0595	; 0x800595 <gc_block+0x28>
    1c90:	90 91 96 05 	lds	r25, 0x0596	; 0x800596 <gc_block+0x29>
    1c94:	a0 91 97 05 	lds	r26, 0x0597	; 0x800597 <gc_block+0x2a>
    1c98:	b0 91 98 05 	lds	r27, 0x0598	; 0x800598 <gc_block+0x2b>
    1c9c:	80 93 38 05 	sts	0x0538, r24	; 0x800538 <gc_state+0xa>
    1ca0:	90 93 39 05 	sts	0x0539, r25	; 0x800539 <gc_state+0xb>
    1ca4:	a0 93 3a 05 	sts	0x053A, r26	; 0x80053a <gc_state+0xc>
    1ca8:	b0 93 3b 05 	sts	0x053B, r27	; 0x80053b <gc_state+0xd>
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1cac:	ee e2       	ldi	r30, 0x2E	; 46
    1cae:	f5 e0       	ldi	r31, 0x05	; 5
    1cb0:	ad e6       	ldi	r26, 0x6D	; 109
    1cb2:	b5 e0       	ldi	r27, 0x05	; 5
    1cb4:	9c 96       	adiw	r26, 0x2c	; 44
    1cb6:	8c 91       	ld	r24, X
    1cb8:	9c 97       	sbiw	r26, 0x2c	; 44
    1cba:	82 8b       	std	Z+18, r24	; 0x12

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1cbc:	1a 96       	adiw	r26, 0x0a	; 10
    1cbe:	8c 91       	ld	r24, X
    1cc0:	91 85       	ldd	r25, Z+9	; 0x09
    1cc2:	98 17       	cp	r25, r24
    1cc4:	59 f0       	breq	.+22     	; 0x1cdc <gc_execute_line+0x10b0>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    1cc6:	8f 01       	movw	r16, r30
    1cc8:	42 85       	ldd	r20, Z+10	; 0x0a
    1cca:	53 85       	ldd	r21, Z+11	; 0x0b
    1ccc:	64 85       	ldd	r22, Z+12	; 0x0c
    1cce:	75 85       	ldd	r23, Z+13	; 0x0d
    1cd0:	0e 94 36 2c 	call	0x586c	; 0x586c <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    1cd4:	80 91 77 05 	lds	r24, 0x0577	; 0x800577 <gc_block+0xa>
    1cd8:	f8 01       	movw	r30, r16
    1cda:	81 87       	std	Z+9, r24	; 0x09
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1cdc:	80 91 76 05 	lds	r24, 0x0576	; 0x800576 <gc_block+0x9>
    1ce0:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <gc_state+0x8>
    1ce4:	98 17       	cp	r25, r24
    1ce6:	31 f0       	breq	.+12     	; 0x1cf4 <gc_execute_line+0x10c8>
    coolant_run(gc_block.modal.coolant);
    1ce8:	0e 94 11 05 	call	0xa22	; 0xa22 <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1cec:	80 91 76 05 	lds	r24, 0x0576	; 0x800576 <gc_block+0x9>
    1cf0:	80 93 36 05 	sts	0x0536, r24	; 0x800536 <gc_state+0x8>
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1cf4:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <gc_block>
    1cf8:	81 30       	cpi	r24, 0x01	; 1
    1cfa:	51 f4       	brne	.+20     	; 0x1d10 <gc_execute_line+0x10e4>
    1cfc:	60 91 8d 05 	lds	r22, 0x058D	; 0x80058d <gc_block+0x20>
    1d00:	70 91 8e 05 	lds	r23, 0x058E	; 0x80058e <gc_block+0x21>
    1d04:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <gc_block+0x22>
    1d08:	90 91 90 05 	lds	r25, 0x0590	; 0x800590 <gc_block+0x23>
    1d0c:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    1d10:	ee e2       	ldi	r30, 0x2E	; 46
    1d12:	f5 e0       	ldi	r31, 0x05	; 5
    1d14:	ad e6       	ldi	r26, 0x6D	; 109
    1d16:	b5 e0       	ldi	r27, 0x05	; 5
    1d18:	15 96       	adiw	r26, 0x05	; 5
    1d1a:	8c 91       	ld	r24, X
    1d1c:	15 97       	sbiw	r26, 0x05	; 5
    1d1e:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1d20:	13 96       	adiw	r26, 0x03	; 3
    1d22:	8c 91       	ld	r24, X
    1d24:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1d26:	fa a1       	ldd	r31, Y+34	; 0x22
    1d28:	f3 30       	cpi	r31, 0x03	; 3
    1d2a:	f9 f4       	brne	.+62     	; 0x1d6a <gc_execute_line+0x113e>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1d2c:	80 91 73 05 	lds	r24, 0x0573	; 0x800573 <gc_block+0x6>
    1d30:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    1d34:	81 30       	cpi	r24, 0x01	; 1
    1d36:	89 f4       	brne	.+34     	; 0x1d5a <gc_execute_line+0x112e>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    1d38:	80 91 a2 05 	lds	r24, 0x05A2	; 0x8005a2 <gc_block+0x35>
    1d3c:	90 91 a3 05 	lds	r25, 0x05A3	; 0x8005a3 <gc_block+0x36>
    1d40:	a0 91 a4 05 	lds	r26, 0x05A4	; 0x8005a4 <gc_block+0x37>
    1d44:	b0 91 a5 05 	lds	r27, 0x05A5	; 0x8005a5 <gc_block+0x38>
    1d48:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <gc_state+0x3b>
    1d4c:	90 93 6a 05 	sts	0x056A, r25	; 0x80056a <gc_state+0x3c>
    1d50:	a0 93 6b 05 	sts	0x056B, r26	; 0x80056b <gc_state+0x3d>
    1d54:	b0 93 6c 05 	sts	0x056C, r27	; 0x80056c <gc_state+0x3e>
    1d58:	08 c0       	rjmp	.+16     	; 0x1d6a <gc_execute_line+0x113e>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    1d5a:	10 92 69 05 	sts	0x0569, r1	; 0x800569 <gc_state+0x3b>
    1d5e:	10 92 6a 05 	sts	0x056A, r1	; 0x80056a <gc_state+0x3c>
    1d62:	10 92 6b 05 	sts	0x056B, r1	; 0x80056b <gc_state+0x3d>
    1d66:	10 92 6c 05 	sts	0x056C, r1	; 0x80056c <gc_state+0x3e>
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1d6a:	80 91 74 05 	lds	r24, 0x0574	; 0x800574 <gc_block+0x7>
    1d6e:	90 91 34 05 	lds	r25, 0x0534	; 0x800534 <gc_state+0x6>
    1d72:	98 17       	cp	r25, r24
    1d74:	59 f0       	breq	.+22     	; 0x1d8c <gc_execute_line+0x1160>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    1d76:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <gc_state+0x6>
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    1d7a:	8c e0       	ldi	r24, 0x0C	; 12
    1d7c:	fe 01       	movw	r30, r28
    1d7e:	31 96       	adiw	r30, 0x01	; 1
    1d80:	a1 e5       	ldi	r26, 0x51	; 81
    1d82:	b5 e0       	ldi	r27, 0x05	; 5
    1d84:	01 90       	ld	r0, Z+
    1d86:	0d 92       	st	X+, r0
    1d88:	8a 95       	dec	r24
    1d8a:	e1 f7       	brne	.-8      	; 0x1d84 <gc_execute_line+0x1158>
  
  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    1d8c:	ed e6       	ldi	r30, 0x6D	; 109
    1d8e:	f5 e0       	ldi	r31, 0x05	; 5
    1d90:	84 81       	ldd	r24, Z+4	; 0x04
    1d92:	80 93 31 05 	sts	0x0531, r24	; 0x800531 <gc_state+0x3>
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    1d96:	80 81       	ld	r24, Z
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	32 97       	sbiw	r30, 0x02	; 2
    1d9e:	e8 30       	cpi	r30, 0x08	; 8
    1da0:	f1 05       	cpc	r31, r1
    1da2:	08 f0       	brcs	.+2      	; 0x1da6 <gc_execute_line+0x117a>
    1da4:	55 c0       	rjmp	.+170    	; 0x1e50 <gc_execute_line+0x1224>
    1da6:	e9 53       	subi	r30, 0x39	; 57
    1da8:	ff 4f       	sbci	r31, 0xFF	; 255
    1daa:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    1dae:	be 01       	movw	r22, r28
    1db0:	63 5f       	subi	r22, 0xF3	; 243
    1db2:	7f 4f       	sbci	r23, 0xFF	; 255
    1db4:	8f a1       	ldd	r24, Y+39	; 0x27
    1db6:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    1dba:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <gc_state+0x6>
    1dbe:	2f a1       	ldd	r18, Y+39	; 0x27
    1dc0:	82 13       	cpse	r24, r18
    1dc2:	46 c0       	rjmp	.+140    	; 0x1e50 <gc_execute_line+0x1224>
    1dc4:	8c e0       	ldi	r24, 0x0C	; 12
    1dc6:	fe 01       	movw	r30, r28
    1dc8:	3d 96       	adiw	r30, 0x0d	; 13
    1dca:	a1 e5       	ldi	r26, 0x51	; 81
    1dcc:	b5 e0       	ldi	r27, 0x05	; 5
    1dce:	01 90       	ld	r0, Z+
    1dd0:	0d 92       	st	X+, r0
    1dd2:	8a 95       	dec	r24
    1dd4:	e1 f7       	brne	.-8      	; 0x1dce <gc_execute_line+0x11a2>
    1dd6:	3c c0       	rjmp	.+120    	; 0x1e50 <gc_execute_line+0x1224>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    1dd8:	3a a1       	ldd	r19, Y+34	; 0x22
    1dda:	33 23       	and	r19, r19
    1ddc:	49 f0       	breq	.+18     	; 0x1df0 <gc_execute_line+0x11c4>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	40 e0       	ldi	r20, 0x00	; 0
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	60 e8       	ldi	r22, 0x80	; 128
    1de6:	7f eb       	ldi	r23, 0xBF	; 191
    1de8:	8a e9       	ldi	r24, 0x9A	; 154
    1dea:	95 e0       	ldi	r25, 0x05	; 5
    1dec:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    1df0:	20 e0       	ldi	r18, 0x00	; 0
    1df2:	40 e0       	ldi	r20, 0x00	; 0
    1df4:	50 e0       	ldi	r21, 0x00	; 0
    1df6:	60 e8       	ldi	r22, 0x80	; 128
    1df8:	7f eb       	ldi	r23, 0xBF	; 191
    1dfa:	ce 01       	movw	r24, r28
    1dfc:	0d 96       	adiw	r24, 0x0d	; 13
    1dfe:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    1e02:	8c e0       	ldi	r24, 0x0C	; 12
    1e04:	fe 01       	movw	r30, r28
    1e06:	3d 96       	adiw	r30, 0x0d	; 13
    1e08:	a5 e4       	ldi	r26, 0x45	; 69
    1e0a:	b5 e0       	ldi	r27, 0x05	; 5
    1e0c:	01 90       	ld	r0, Z+
    1e0e:	0d 92       	st	X+, r0
    1e10:	8a 95       	dec	r24
    1e12:	e1 f7       	brne	.-8      	; 0x1e0c <gc_execute_line+0x11e0>
      break;
    1e14:	1d c0       	rjmp	.+58     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    1e16:	65 e4       	ldi	r22, 0x45	; 69
    1e18:	75 e0       	ldi	r23, 0x05	; 5
    1e1a:	86 e0       	ldi	r24, 0x06	; 6
    1e1c:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_write_coord_data>
      break;
    1e20:	17 c0       	rjmp	.+46     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    1e22:	65 e4       	ldi	r22, 0x45	; 69
    1e24:	75 e0       	ldi	r23, 0x05	; 5
    1e26:	87 e0       	ldi	r24, 0x07	; 7
    1e28:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_write_coord_data>
      break;
    1e2c:	11 c0       	rjmp	.+34     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    1e2e:	8c e0       	ldi	r24, 0x0C	; 12
    1e30:	ea e9       	ldi	r30, 0x9A	; 154
    1e32:	f5 e0       	ldi	r31, 0x05	; 5
    1e34:	ad e5       	ldi	r26, 0x5D	; 93
    1e36:	b5 e0       	ldi	r27, 0x05	; 5
    1e38:	01 90       	ld	r0, Z+
    1e3a:	0d 92       	st	X+, r0
    1e3c:	8a 95       	dec	r24
    1e3e:	e1 f7       	brne	.-8      	; 0x1e38 <gc_execute_line+0x120c>
      break;
    1e40:	07 c0       	rjmp	.+14     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    1e42:	8c e0       	ldi	r24, 0x0C	; 12
    1e44:	ed e5       	ldi	r30, 0x5D	; 93
    1e46:	f5 e0       	ldi	r31, 0x05	; 5
    1e48:	df 01       	movw	r26, r30
    1e4a:	1d 92       	st	X+, r1
    1e4c:	8a 95       	dec	r24
    1e4e:	e9 f7       	brne	.-6      	; 0x1e4a <gc_execute_line+0x121e>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    1e50:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <gc_block+0x1>
    1e54:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    1e58:	88 30       	cpi	r24, 0x08	; 8
    1e5a:	09 f4       	brne	.+2      	; 0x1e5e <gc_execute_line+0x1232>
    1e5c:	a9 c0       	rjmp	.+338    	; 0x1fb0 <gc_execute_line+0x1384>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1e5e:	ba a1       	ldd	r27, Y+34	; 0x22
    1e60:	b2 30       	cpi	r27, 0x02	; 2
    1e62:	09 f0       	breq	.+2      	; 0x1e66 <gc_execute_line+0x123a>
    1e64:	a5 c0       	rjmp	.+330    	; 0x1fb0 <gc_execute_line+0x1384>
      switch (gc_state.modal.motion) {
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	88 30       	cpi	r24, 0x08	; 8
    1e6a:	91 05       	cpc	r25, r1
    1e6c:	08 f0       	brcs	.+2      	; 0x1e70 <gc_execute_line+0x1244>
    1e6e:	97 c0       	rjmp	.+302    	; 0x1f9e <gc_execute_line+0x1372>
    1e70:	fc 01       	movw	r30, r24
    1e72:	e1 53       	subi	r30, 0x31	; 49
    1e74:	ff 4f       	sbci	r31, 0xFF	; 255
    1e76:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    1e7a:	20 e0       	ldi	r18, 0x00	; 0
    1e7c:	40 e0       	ldi	r20, 0x00	; 0
    1e7e:	50 e0       	ldi	r21, 0x00	; 0
    1e80:	60 e8       	ldi	r22, 0x80	; 128
    1e82:	7f eb       	ldi	r23, 0xBF	; 191
    1e84:	8a e9       	ldi	r24, 0x9A	; 154
    1e86:	95 e0       	ldi	r25, 0x05	; 5
    1e88:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
          #endif
          break;
    1e8c:	88 c0       	rjmp	.+272    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    1e8e:	ee e2       	ldi	r30, 0x2E	; 46
    1e90:	f5 e0       	ldi	r31, 0x05	; 5
    1e92:	46 85       	ldd	r20, Z+14	; 0x0e
    1e94:	57 85       	ldd	r21, Z+15	; 0x0f
    1e96:	60 89       	ldd	r22, Z+16	; 0x10
    1e98:	71 89       	ldd	r23, Z+17	; 0x11
    1e9a:	21 81       	ldd	r18, Z+1	; 0x01
    1e9c:	8a e9       	ldi	r24, 0x9A	; 154
    1e9e:	95 e0       	ldi	r25, 0x05	; 5
    1ea0:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
          #endif
          break;
    1ea4:	7c c0       	rjmp	.+248    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1ea6:	ee e2       	ldi	r30, 0x2E	; 46
    1ea8:	f5 e0       	ldi	r31, 0x05	; 5
    1eaa:	c6 84       	ldd	r12, Z+14	; 0x0e
    1eac:	d7 84       	ldd	r13, Z+15	; 0x0f
    1eae:	e0 88       	ldd	r14, Z+16	; 0x10
    1eb0:	f1 88       	ldd	r15, Z+17	; 0x11
    1eb2:	00 91 91 05 	lds	r16, 0x0591	; 0x800591 <gc_block+0x24>
    1eb6:	10 91 92 05 	lds	r17, 0x0592	; 0x800592 <gc_block+0x25>
    1eba:	20 91 93 05 	lds	r18, 0x0593	; 0x800593 <gc_block+0x26>
    1ebe:	30 91 94 05 	lds	r19, 0x0594	; 0x800594 <gc_block+0x27>
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	8f 93       	push	r24
    1ec6:	8e a1       	ldd	r24, Y+38	; 0x26
    1ec8:	8f 93       	push	r24
    1eca:	9d a1       	ldd	r25, Y+37	; 0x25
    1ecc:	9f 93       	push	r25
    1ece:	8c a0       	ldd	r8, Y+36	; 0x24
    1ed0:	a1 80       	ldd	r10, Z+1	; 0x01
    1ed2:	4c e7       	ldi	r20, 0x7C	; 124
    1ed4:	55 e0       	ldi	r21, 0x05	; 5
    1ed6:	6a e9       	ldi	r22, 0x9A	; 154
    1ed8:	75 e0       	ldi	r23, 0x05	; 5
    1eda:	85 e4       	ldi	r24, 0x45	; 69
    1edc:	95 e0       	ldi	r25, 0x05	; 5
    1ede:	0e 94 63 14 	call	0x28c6	; 0x28c6 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    1ee2:	0f 90       	pop	r0
    1ee4:	0f 90       	pop	r0
    1ee6:	0f 90       	pop	r0
    1ee8:	5a c0       	rjmp	.+180    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1eea:	ee e2       	ldi	r30, 0x2E	; 46
    1eec:	f5 e0       	ldi	r31, 0x05	; 5
    1eee:	c6 84       	ldd	r12, Z+14	; 0x0e
    1ef0:	d7 84       	ldd	r13, Z+15	; 0x0f
    1ef2:	e0 88       	ldd	r14, Z+16	; 0x10
    1ef4:	f1 88       	ldd	r15, Z+17	; 0x11
    1ef6:	00 91 91 05 	lds	r16, 0x0591	; 0x800591 <gc_block+0x24>
    1efa:	10 91 92 05 	lds	r17, 0x0592	; 0x800592 <gc_block+0x25>
    1efe:	20 91 93 05 	lds	r18, 0x0593	; 0x800593 <gc_block+0x26>
    1f02:	30 91 94 05 	lds	r19, 0x0594	; 0x800594 <gc_block+0x27>
    1f06:	1f 92       	push	r1
    1f08:	ae a1       	ldd	r26, Y+38	; 0x26
    1f0a:	af 93       	push	r26
    1f0c:	bd a1       	ldd	r27, Y+37	; 0x25
    1f0e:	bf 93       	push	r27
    1f10:	8c a0       	ldd	r8, Y+36	; 0x24
    1f12:	a1 80       	ldd	r10, Z+1	; 0x01
    1f14:	4c e7       	ldi	r20, 0x7C	; 124
    1f16:	55 e0       	ldi	r21, 0x05	; 5
    1f18:	6a e9       	ldi	r22, 0x9A	; 154
    1f1a:	75 e0       	ldi	r23, 0x05	; 5
    1f1c:	85 e4       	ldi	r24, 0x45	; 69
    1f1e:	95 e0       	ldi	r25, 0x05	; 5
    1f20:	0e 94 63 14 	call	0x28c6	; 0x28c6 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	39 c0       	rjmp	.+114    	; 0x1f9e <gc_execute_line+0x1372>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    1f2c:	ee e2       	ldi	r30, 0x2E	; 46
    1f2e:	f5 e0       	ldi	r31, 0x05	; 5
    1f30:	46 85       	ldd	r20, Z+14	; 0x0e
    1f32:	57 85       	ldd	r21, Z+15	; 0x0f
    1f34:	60 89       	ldd	r22, Z+16	; 0x10
    1f36:	71 89       	ldd	r23, Z+17	; 0x11
    1f38:	e1 2c       	mov	r14, r1
    1f3a:	00 e0       	ldi	r16, 0x00	; 0
    1f3c:	21 81       	ldd	r18, Z+1	; 0x01
    1f3e:	8a e9       	ldi	r24, 0x9A	; 154
    1f40:	95 e0       	ldi	r25, 0x05	; 5
    1f42:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <mc_probe_cycle>
          #endif
          break;
    1f46:	2b c0       	rjmp	.+86     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    1f48:	ee e2       	ldi	r30, 0x2E	; 46
    1f4a:	f5 e0       	ldi	r31, 0x05	; 5
    1f4c:	46 85       	ldd	r20, Z+14	; 0x0e
    1f4e:	57 85       	ldd	r21, Z+15	; 0x0f
    1f50:	60 89       	ldd	r22, Z+16	; 0x10
    1f52:	71 89       	ldd	r23, Z+17	; 0x11
    1f54:	ee 24       	eor	r14, r14
    1f56:	e3 94       	inc	r14
    1f58:	00 e0       	ldi	r16, 0x00	; 0
    1f5a:	21 81       	ldd	r18, Z+1	; 0x01
    1f5c:	8a e9       	ldi	r24, 0x9A	; 154
    1f5e:	95 e0       	ldi	r25, 0x05	; 5
    1f60:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <mc_probe_cycle>
          #endif
          break;
    1f64:	1c c0       	rjmp	.+56     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    1f66:	ee e2       	ldi	r30, 0x2E	; 46
    1f68:	f5 e0       	ldi	r31, 0x05	; 5
    1f6a:	46 85       	ldd	r20, Z+14	; 0x0e
    1f6c:	57 85       	ldd	r21, Z+15	; 0x0f
    1f6e:	60 89       	ldd	r22, Z+16	; 0x10
    1f70:	71 89       	ldd	r23, Z+17	; 0x11
    1f72:	e1 2c       	mov	r14, r1
    1f74:	01 e0       	ldi	r16, 0x01	; 1
    1f76:	21 81       	ldd	r18, Z+1	; 0x01
    1f78:	8a e9       	ldi	r24, 0x9A	; 154
    1f7a:	95 e0       	ldi	r25, 0x05	; 5
    1f7c:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <mc_probe_cycle>
          #endif
          break;
    1f80:	0e c0       	rjmp	.+28     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    1f82:	ee e2       	ldi	r30, 0x2E	; 46
    1f84:	f5 e0       	ldi	r31, 0x05	; 5
    1f86:	46 85       	ldd	r20, Z+14	; 0x0e
    1f88:	57 85       	ldd	r21, Z+15	; 0x0f
    1f8a:	60 89       	ldd	r22, Z+16	; 0x10
    1f8c:	71 89       	ldd	r23, Z+17	; 0x11
    1f8e:	ee 24       	eor	r14, r14
    1f90:	e3 94       	inc	r14
    1f92:	01 e0       	ldi	r16, 0x01	; 1
    1f94:	21 81       	ldd	r18, Z+1	; 0x01
    1f96:	8a e9       	ldi	r24, 0x9A	; 154
    1f98:	95 e0       	ldi	r25, 0x05	; 5
    1f9a:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    1f9e:	8c e0       	ldi	r24, 0x0C	; 12
    1fa0:	ea e9       	ldi	r30, 0x9A	; 154
    1fa2:	f5 e0       	ldi	r31, 0x05	; 5
    1fa4:	a5 e4       	ldi	r26, 0x45	; 69
    1fa6:	b5 e0       	ldi	r27, 0x05	; 5
    1fa8:	01 90       	ld	r0, Z+
    1faa:	0d 92       	st	X+, r0
    1fac:	8a 95       	dec	r24
    1fae:	e1 f7       	brne	.-8      	; 0x1fa8 <gc_execute_line+0x137c>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    1fb0:	80 91 75 05 	lds	r24, 0x0575	; 0x800575 <gc_block+0x8>
    1fb4:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <gc_state+0x7>
  if (gc_state.modal.program_flow) { 
    1fb8:	88 23       	and	r24, r24
    1fba:	09 f4       	brne	.+2      	; 0x1fbe <gc_execute_line+0x1392>
    1fbc:	0e c1       	rjmp	.+540    	; 0x21da <gc_execute_line+0x15ae>
	protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    1fbe:	0e 94 31 22 	call	0x4462	; 0x4462 <protocol_buffer_synchronize>
	if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    1fc2:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <gc_state+0x7>
    1fc6:	81 30       	cpi	r24, 0x01	; 1
    1fc8:	79 f4       	brne	.+30     	; 0x1fe8 <gc_execute_line+0x13bc>
	  if (sys.state != STATE_CHECK_MODE) {
    1fca:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    1fce:	82 30       	cpi	r24, 0x02	; 2
    1fd0:	91 f1       	breq	.+100    	; 0x2036 <gc_execute_line+0x140a>
		bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); // Use feed hold for program pause.
    1fd2:	9f b7       	in	r25, 0x3f	; 63
    1fd4:	f8 94       	cli
    1fd6:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    1fda:	88 60       	ori	r24, 0x08	; 8
    1fdc:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    1fe0:	9f bf       	out	0x3f, r25	; 63
		protocol_execute_realtime(); // Execute suspend.
    1fe2:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    1fe6:	27 c0       	rjmp	.+78     	; 0x2036 <gc_execute_line+0x140a>
	} else { // == PROGRAM_FLOW_COMPLETED
	  // Upon program complete, only a subset of g-codes reset to certain defaults, according to 
	  // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
	  // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
	  // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
	  gc_state.modal.motion = MOTION_MODE_LINEAR;
    1fe8:	ee e2       	ldi	r30, 0x2E	; 46
    1fea:	f5 e0       	ldi	r31, 0x05	; 5
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	80 83       	st	Z, r24
	  gc_state.modal.plane_select = PLANE_SELECT_XY;
    1ff0:	14 82       	std	Z+4, r1	; 0x04
	  gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    1ff2:	13 82       	std	Z+3, r1	; 0x03
	  gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    1ff4:	11 82       	std	Z+1, r1	; 0x01
	  // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
	  gc_state.modal.coord_select = 0; // G54
    1ff6:	16 82       	std	Z+6, r1	; 0x06
	  gc_state.modal.spindle = SPINDLE_DISABLE;
    1ff8:	11 86       	std	Z+9, r1	; 0x09
	  gc_state.modal.coolant = COOLANT_DISABLE;
    1ffa:	10 86       	std	Z+8, r1	; 0x08
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
    1ffc:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    2000:	82 30       	cpi	r24, 0x02	; 2
    2002:	b1 f0       	breq	.+44     	; 0x2030 <gc_execute_line+0x1404>
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2004:	be 01       	movw	r22, r28
    2006:	6f 5f       	subi	r22, 0xFF	; 255
    2008:	7f 4f       	sbci	r23, 0xFF	; 255
    200a:	80 e0       	ldi	r24, 0x00	; 0
    200c:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    2010:	88 23       	and	r24, r24
    2012:	09 f4       	brne	.+2      	; 0x2016 <gc_execute_line+0x13ea>
    2014:	78 c0       	rjmp	.+240    	; 0x2106 <gc_execute_line+0x14da>
		memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2016:	8c e0       	ldi	r24, 0x0C	; 12
    2018:	fe 01       	movw	r30, r28
    201a:	31 96       	adiw	r30, 0x01	; 1
    201c:	a1 e5       	ldi	r26, 0x51	; 81
    201e:	b5 e0       	ldi	r27, 0x05	; 5
    2020:	01 90       	ld	r0, Z+
    2022:	0d 92       	st	X+, r0
    2024:	8a 95       	dec	r24
    2026:	e1 f7       	brne	.-8      	; 0x2020 <gc_execute_line+0x13f4>
		spindle_stop();
    2028:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <spindle_stop>
		coolant_stop();		
    202c:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
	  }
	  
	  report_feedback_message(MESSAGE_PROGRAM_END);
    2030:	87 e0       	ldi	r24, 0x07	; 7
    2032:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
	}
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    2036:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <gc_state+0x7>
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
    203a:	80 e0       	ldi	r24, 0x00	; 0
    203c:	ce c0       	rjmp	.+412    	; 0x21da <gc_execute_line+0x15ae>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	cc c0       	rjmp	.+408    	; 0x21da <gc_execute_line+0x15ae>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2042:	82 e0       	ldi	r24, 0x02	; 2
    2044:	ca c0       	rjmp	.+404    	; 0x21da <gc_execute_line+0x15ae>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2046:	84 e1       	ldi	r24, 0x14	; 20
    2048:	c8 c0       	rjmp	.+400    	; 0x21da <gc_execute_line+0x15ae>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    204a:	88 e1       	ldi	r24, 0x18	; 24
    204c:	c6 c0       	rjmp	.+396    	; 0x21da <gc_execute_line+0x15ae>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    204e:	84 e1       	ldi	r24, 0x14	; 20
    2050:	c4 c0       	rjmp	.+392    	; 0x21da <gc_execute_line+0x15ae>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2052:	84 e1       	ldi	r24, 0x14	; 20
    2054:	c2 c0       	rjmp	.+388    	; 0x21da <gc_execute_line+0x15ae>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2056:	84 e1       	ldi	r24, 0x14	; 20
    2058:	c0 c0       	rjmp	.+384    	; 0x21da <gc_execute_line+0x15ae>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    205a:	88 e1       	ldi	r24, 0x18	; 24
    205c:	be c0       	rjmp	.+380    	; 0x21da <gc_execute_line+0x15ae>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    205e:	84 e1       	ldi	r24, 0x14	; 20
    2060:	bc c0       	rjmp	.+376    	; 0x21da <gc_execute_line+0x15ae>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    2062:	84 e1       	ldi	r24, 0x14	; 20
    2064:	ba c0       	rjmp	.+372    	; 0x21da <gc_execute_line+0x15ae>
    2066:	84 e1       	ldi	r24, 0x14	; 20
    2068:	b8 c0       	rjmp	.+368    	; 0x21da <gc_execute_line+0x15ae>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    206a:	88 e1       	ldi	r24, 0x18	; 24
    206c:	b6 c0       	rjmp	.+364    	; 0x21da <gc_execute_line+0x15ae>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    206e:	84 e1       	ldi	r24, 0x14	; 20
    2070:	b4 c0       	rjmp	.+360    	; 0x21da <gc_execute_line+0x15ae>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    2072:	84 e1       	ldi	r24, 0x14	; 20
    2074:	b2 c0       	rjmp	.+356    	; 0x21da <gc_execute_line+0x15ae>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2076:	87 e1       	ldi	r24, 0x17	; 23
    2078:	b0 c0       	rjmp	.+352    	; 0x21da <gc_execute_line+0x15ae>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    207a:	85 e1       	ldi	r24, 0x15	; 21
    207c:	ae c0       	rjmp	.+348    	; 0x21da <gc_execute_line+0x15ae>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    207e:	87 e1       	ldi	r24, 0x17	; 23
    2080:	ac c0       	rjmp	.+344    	; 0x21da <gc_execute_line+0x15ae>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2082:	84 e1       	ldi	r24, 0x14	; 20
    2084:	aa c0       	rjmp	.+340    	; 0x21da <gc_execute_line+0x15ae>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2086:	85 e1       	ldi	r24, 0x15	; 21
    2088:	a8 c0       	rjmp	.+336    	; 0x21da <gc_execute_line+0x15ae>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    208a:	84 e1       	ldi	r24, 0x14	; 20
    208c:	a6 c0       	rjmp	.+332    	; 0x21da <gc_execute_line+0x15ae>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    208e:	89 e1       	ldi	r24, 0x19	; 25
    2090:	a4 c0       	rjmp	.+328    	; 0x21da <gc_execute_line+0x15ae>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2092:	84 e0       	ldi	r24, 0x04	; 4
    2094:	a2 c0       	rjmp	.+324    	; 0x21da <gc_execute_line+0x15ae>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2096:	8b e1       	ldi	r24, 0x1B	; 27
    2098:	a0 c0       	rjmp	.+320    	; 0x21da <gc_execute_line+0x15ae>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    209a:	86 e1       	ldi	r24, 0x16	; 22
    209c:	9e c0       	rjmp	.+316    	; 0x21da <gc_execute_line+0x15ae>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    209e:	8c e1       	ldi	r24, 0x1C	; 28
    20a0:	9c c0       	rjmp	.+312    	; 0x21da <gc_execute_line+0x15ae>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    20a2:	85 e2       	ldi	r24, 0x25	; 37
    20a4:	9a c0       	rjmp	.+308    	; 0x21da <gc_execute_line+0x15ae>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    20a6:	8d e1       	ldi	r24, 0x1D	; 29
    20a8:	98 c0       	rjmp	.+304    	; 0x21da <gc_execute_line+0x15ae>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    20aa:	87 e0       	ldi	r24, 0x07	; 7
    20ac:	96 c0       	rjmp	.+300    	; 0x21da <gc_execute_line+0x15ae>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    20ae:	8a e1       	ldi	r24, 0x1A	; 26
    20b0:	94 c0       	rjmp	.+296    	; 0x21da <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    20b2:	8c e1       	ldi	r24, 0x1C	; 28
    20b4:	92 c0       	rjmp	.+292    	; 0x21da <gc_execute_line+0x15ae>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    20b6:	8d e1       	ldi	r24, 0x1D	; 29
    20b8:	90 c0       	rjmp	.+288    	; 0x21da <gc_execute_line+0x15ae>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    20ba:	84 e1       	ldi	r24, 0x14	; 20
    20bc:	8e c0       	rjmp	.+284    	; 0x21da <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    20be:	84 e1       	ldi	r24, 0x14	; 20
    20c0:	8c c0       	rjmp	.+280    	; 0x21da <gc_execute_line+0x15ae>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    20c2:	87 e0       	ldi	r24, 0x07	; 7
    20c4:	8a c0       	rjmp	.+276    	; 0x21da <gc_execute_line+0x15ae>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20c6:	8a e1       	ldi	r24, 0x1A	; 26
    20c8:	88 c0       	rjmp	.+272    	; 0x21da <gc_execute_line+0x15ae>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20ca:	87 e0       	ldi	r24, 0x07	; 7
    20cc:	86 c0       	rjmp	.+268    	; 0x21da <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20ce:	87 e0       	ldi	r24, 0x07	; 7
    20d0:	84 c0       	rjmp	.+264    	; 0x21da <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    20d2:	8e e1       	ldi	r24, 0x1E	; 30
    20d4:	82 c0       	rjmp	.+260    	; 0x21da <gc_execute_line+0x15ae>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    20d6:	8f e1       	ldi	r24, 0x1F	; 31
    20d8:	80 c0       	rjmp	.+256    	; 0x21da <gc_execute_line+0x15ae>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    20da:	86 e1       	ldi	r24, 0x16	; 22
    20dc:	7e c0       	rjmp	.+252    	; 0x21da <gc_execute_line+0x15ae>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20de:	8a e1       	ldi	r24, 0x1A	; 26
    20e0:	7c c0       	rjmp	.+248    	; 0x21da <gc_execute_line+0x15ae>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    20e2:	80 e2       	ldi	r24, 0x20	; 32
    20e4:	7a c0       	rjmp	.+244    	; 0x21da <gc_execute_line+0x15ae>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20e6:	81 e2       	ldi	r24, 0x21	; 33
    20e8:	78 c0       	rjmp	.+240    	; 0x21da <gc_execute_line+0x15ae>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    20ea:	82 e2       	ldi	r24, 0x22	; 34
    20ec:	76 c0       	rjmp	.+236    	; 0x21da <gc_execute_line+0x15ae>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    20ee:	83 e2       	ldi	r24, 0x23	; 35
    20f0:	74 c0       	rjmp	.+232    	; 0x21da <gc_execute_line+0x15ae>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    20f2:	81 e2       	ldi	r24, 0x21	; 33
    20f4:	72 c0       	rjmp	.+228    	; 0x21da <gc_execute_line+0x15ae>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    20f6:	81 e2       	ldi	r24, 0x21	; 33
    20f8:	70 c0       	rjmp	.+224    	; 0x21da <gc_execute_line+0x15ae>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20fa:	8a e1       	ldi	r24, 0x1A	; 26
    20fc:	6e c0       	rjmp	.+220    	; 0x21da <gc_execute_line+0x15ae>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20fe:	81 e2       	ldi	r24, 0x21	; 33
    2100:	6c c0       	rjmp	.+216    	; 0x21da <gc_execute_line+0x15ae>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2102:	84 e2       	ldi	r24, 0x24	; 36
    2104:	6a c0       	rjmp	.+212    	; 0x21da <gc_execute_line+0x15ae>
	  gc_state.modal.coolant = COOLANT_DISABLE;
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2106:	87 e0       	ldi	r24, 0x07	; 7
    2108:	68 c0       	rjmp	.+208    	; 0x21da <gc_execute_line+0x15ae>
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    210a:	87 e1       	ldi	r24, 0x17	; 23
    210c:	66 c0       	rjmp	.+204    	; 0x21da <gc_execute_line+0x15ae>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    210e:	0c 31       	cpi	r16, 0x1C	; 28
    2110:	11 f4       	brne	.+4      	; 0x2116 <gc_execute_line+0x14ea>
    2112:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <gc_execute_line+0x162>
    2116:	50 f4       	brcc	.+20     	; 0x212c <gc_execute_line+0x1500>
    2118:	04 30       	cpi	r16, 0x04	; 4
    211a:	11 f4       	brne	.+4      	; 0x2120 <gc_execute_line+0x14f4>
    211c:	0c 94 b7 06 	jmp	0xd6e	; 0xd6e <gc_execute_line+0x142>
    2120:	0a 30       	cpi	r16, 0x0A	; 10
    2122:	11 f0       	breq	.+4      	; 0x2128 <gc_execute_line+0x14fc>
    2124:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <gc_execute_line+0x37e>
    2128:	0c 94 bf 06 	jmp	0xd7e	; 0xd7e <gc_execute_line+0x152>
    212c:	05 33       	cpi	r16, 0x35	; 53
    212e:	11 f4       	brne	.+4      	; 0x2134 <gc_execute_line+0x1508>
    2130:	0c 94 f3 06 	jmp	0xde6	; 0xde6 <gc_execute_line+0x1ba>
    2134:	0c 35       	cpi	r16, 0x5C	; 92
    2136:	11 f4       	brne	.+4      	; 0x213c <gc_execute_line+0x1510>
    2138:	0c 94 fb 06 	jmp	0xdf6	; 0xdf6 <gc_execute_line+0x1ca>
    213c:	0e 31       	cpi	r16, 0x1E	; 30
    213e:	11 f0       	breq	.+4      	; 0x2144 <gc_execute_line+0x1518>
    2140:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <gc_execute_line+0x37e>
    2144:	0c 94 dd 06 	jmp	0xdba	; 0xdba <gc_execute_line+0x18e>
    2148:	0c 31       	cpi	r16, 0x1C	; 28
    214a:	11 f4       	brne	.+4      	; 0x2150 <gc_execute_line+0x1524>
    214c:	0c 94 c9 06 	jmp	0xd92	; 0xd92 <gc_execute_line+0x166>
    2150:	48 f4       	brcc	.+18     	; 0x2164 <gc_execute_line+0x1538>
    2152:	04 30       	cpi	r16, 0x04	; 4
    2154:	11 f4       	brne	.+4      	; 0x215a <gc_execute_line+0x152e>
    2156:	0c 94 b9 06 	jmp	0xd72	; 0xd72 <gc_execute_line+0x146>
    215a:	0a 30       	cpi	r16, 0x0A	; 10
    215c:	11 f4       	brne	.+4      	; 0x2162 <gc_execute_line+0x1536>
    215e:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <gc_execute_line+0x156>
    2162:	d3 cf       	rjmp	.-90     	; 0x210a <gc_execute_line+0x14de>
    2164:	05 33       	cpi	r16, 0x35	; 53
    2166:	11 f4       	brne	.+4      	; 0x216c <gc_execute_line+0x1540>
    2168:	0c 94 f5 06 	jmp	0xdea	; 0xdea <gc_execute_line+0x1be>
    216c:	0c 35       	cpi	r16, 0x5C	; 92
    216e:	11 f4       	brne	.+4      	; 0x2174 <gc_execute_line+0x1548>
    2170:	0c 94 fd 06 	jmp	0xdfa	; 0xdfa <gc_execute_line+0x1ce>
    2174:	0e 31       	cpi	r16, 0x1E	; 30
    2176:	49 f6       	brne	.-110    	; 0x210a <gc_execute_line+0x14de>
    2178:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <gc_execute_line+0x192>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    217c:	e1 e0       	ldi	r30, 0x01	; 1
    217e:	ee a3       	std	Y+38, r30	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    2180:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    2182:	f2 e0       	ldi	r31, 0x02	; 2
    2184:	fc a3       	std	Y+36, r31	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2186:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x3>
    218a:	81 30       	cpi	r24, 0x01	; 1
    218c:	09 f0       	breq	.+2      	; 0x2190 <gc_execute_line+0x1564>
    218e:	eb c8       	rjmp	.-3626   	; 0x1366 <gc_execute_line+0x73a>
    2190:	b6 c8       	rjmp	.-3732   	; 0x12fe <gc_execute_line+0x6d2>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    2192:	25 e0       	ldi	r18, 0x05	; 5
    2194:	52 16       	cp	r5, r18
    2196:	09 f4       	brne	.+2      	; 0x219a <gc_execute_line+0x156e>
    2198:	eb ca       	rjmp	.-2602   	; 0x1770 <gc_execute_line+0xb44>
    219a:	37 e0       	ldi	r19, 0x07	; 7
    219c:	53 16       	cp	r5, r19
    219e:	09 f4       	brne	.+2      	; 0x21a2 <gc_execute_line+0x1576>
    21a0:	f5 ca       	rjmp	.-2582   	; 0x178c <gc_execute_line+0xb60>
    21a2:	83 e0       	ldi	r24, 0x03	; 3
    21a4:	58 12       	cpse	r5, r24
    21a6:	f7 ca       	rjmp	.-2578   	; 0x1796 <gc_execute_line+0xb6a>
    21a8:	d9 ca       	rjmp	.-2638   	; 0x175c <gc_execute_line+0xb30>
    21aa:	95 e0       	ldi	r25, 0x05	; 5
    21ac:	59 16       	cp	r5, r25
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <gc_execute_line+0x1586>
    21b0:	df ca       	rjmp	.-2626   	; 0x1770 <gc_execute_line+0xb44>
    21b2:	a7 e0       	ldi	r26, 0x07	; 7
    21b4:	5a 16       	cp	r5, r26
    21b6:	09 f4       	brne	.+2      	; 0x21ba <gc_execute_line+0x158e>
    21b8:	e9 ca       	rjmp	.-2606   	; 0x178c <gc_execute_line+0xb60>
    21ba:	b3 e0       	ldi	r27, 0x03	; 3
    21bc:	5b 12       	cpse	r5, r27
    21be:	eb ca       	rjmp	.-2602   	; 0x1796 <gc_execute_line+0xb6a>
    21c0:	cc ca       	rjmp	.-2664   	; 0x175a <gc_execute_line+0xb2e>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    21c2:	10 91 6e 05 	lds	r17, 0x056E	; 0x80056e <gc_block+0x1>
    21c6:	18 30       	cpi	r17, 0x08	; 8
    21c8:	09 f0       	breq	.+2      	; 0x21cc <gc_execute_line+0x15a0>
    21ca:	f6 ca       	rjmp	.-2580   	; 0x17b8 <gc_execute_line+0xb8c>
    21cc:	ef ca       	rjmp	.-2594   	; 0x17ac <gc_execute_line+0xb80>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    21ce:	ee ed       	ldi	r30, 0xDE	; 222
    21d0:	6e 22       	and	r6, r30
    21d2:	ec ef       	ldi	r30, 0xFC	; 252
    21d4:	7e 22       	and	r7, r30
    21d6:	1a a2       	std	Y+34, r1	; 0x22
    21d8:	22 cd       	rjmp	.-1468   	; 0x1c1e <gc_execute_line+0xff2>
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
}
    21da:	ab 96       	adiw	r28, 0x2b	; 43
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	de bf       	out	0x3e, r29	; 62
    21e2:	0f be       	out	0x3f, r0	; 63
    21e4:	cd bf       	out	0x3d, r28	; 61
    21e6:	df 91       	pop	r29
    21e8:	cf 91       	pop	r28
    21ea:	1f 91       	pop	r17
    21ec:	0f 91       	pop	r16
    21ee:	ff 90       	pop	r15
    21f0:	ef 90       	pop	r14
    21f2:	df 90       	pop	r13
    21f4:	cf 90       	pop	r12
    21f6:	bf 90       	pop	r11
    21f8:	af 90       	pop	r10
    21fa:	9f 90       	pop	r9
    21fc:	8f 90       	pop	r8
    21fe:	7f 90       	pop	r7
    2200:	6f 90       	pop	r6
    2202:	5f 90       	pop	r5
    2204:	4f 90       	pop	r4
    2206:	3f 90       	pop	r3
    2208:	2f 90       	pop	r2
    220a:	08 95       	ret

0000220c <limits_disable>:


// Disables hard limits.
void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    220c:	eb e6       	ldi	r30, 0x6B	; 107
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	80 81       	ld	r24, Z
    2212:	8d 7f       	andi	r24, 0xFD	; 253
    2214:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    2216:	e8 e6       	ldi	r30, 0x68	; 104
    2218:	f0 e0       	ldi	r31, 0x00	; 0
    221a:	80 81       	ld	r24, Z
    221c:	8e 7f       	andi	r24, 0xFE	; 254
    221e:	80 83       	st	Z, r24
    2220:	08 95       	ret

00002222 <limits_init>:
  #define HOMING_AXIS_LOCATE_SCALAR  5.0 // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    2222:	21 98       	cbi	0x04, 1	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK	); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    2224:	29 9a       	sbi	0x05, 1	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    2226:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    222a:	83 ff       	sbrs	r24, 3
    222c:	0b c0       	rjmp	.+22     	; 0x2244 <limits_init+0x22>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    222e:	eb e6       	ldi	r30, 0x6B	; 107
    2230:	f0 e0       	ldi	r31, 0x00	; 0
    2232:	80 81       	ld	r24, Z
    2234:	82 60       	ori	r24, 0x02	; 2
    2236:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    2238:	e8 e6       	ldi	r30, 0x68	; 104
    223a:	f0 e0       	ldi	r31, 0x00	; 0
    223c:	80 81       	ld	r24, Z
    223e:	81 60       	ori	r24, 0x01	; 1
    2240:	80 83       	st	Z, r24
    2242:	08 95       	ret
  } else {
    limits_disable(); 
    2244:	0e 94 06 11 	call	0x220c	; 0x220c <limits_disable>
    2248:	08 95       	ret

0000224a <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    224a:	ef 92       	push	r14
    224c:	ff 92       	push	r15
    224e:	0f 93       	push	r16
    2250:	1f 93       	push	r17
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
  uint8_t limit_state = 0;
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    2256:	13 b1       	in	r17, 0x03	; 3
    2258:	12 70       	andi	r17, 0x02	; 2
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    225a:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    225e:	86 fd       	sbrc	r24, 6
    2260:	1b c0       	rjmp	.+54     	; 0x2298 <limits_get_state+0x4e>
    2262:	82 e0       	ldi	r24, 0x02	; 2
    2264:	18 27       	eor	r17, r24
    2266:	18 c0       	rjmp	.+48     	; 0x2298 <limits_get_state+0x4e>
  if (pin) {  
    2268:	c0 e0       	ldi	r28, 0x00	; 0
    226a:	d0 e0       	ldi	r29, 0x00	; 0
    226c:	00 e0       	ldi	r16, 0x00	; 0
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    226e:	ee 24       	eor	r14, r14
    2270:	e3 94       	inc	r14
    2272:	f1 2c       	mov	r15, r1
    2274:	8c 2f       	mov	r24, r28
    2276:	0e 94 c9 2b 	call	0x5792	; 0x5792 <get_limit_pin_mask>
    227a:	81 23       	and	r24, r17
    227c:	41 f0       	breq	.+16     	; 0x228e <limits_get_state+0x44>
    227e:	c7 01       	movw	r24, r14
    2280:	0c 2e       	mov	r0, r28
    2282:	02 c0       	rjmp	.+4      	; 0x2288 <limits_get_state+0x3e>
    2284:	88 0f       	add	r24, r24
    2286:	99 1f       	adc	r25, r25
    2288:	0a 94       	dec	r0
    228a:	e2 f7       	brpl	.-8      	; 0x2284 <limits_get_state+0x3a>
    228c:	08 2b       	or	r16, r24
    228e:	21 96       	adiw	r28, 0x01	; 1
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
    2290:	c3 30       	cpi	r28, 0x03	; 3
    2292:	d1 05       	cpc	r29, r1
    2294:	79 f7       	brne	.-34     	; 0x2274 <limits_get_state+0x2a>
    2296:	03 c0       	rjmp	.+6      	; 0x229e <limits_get_state+0x54>
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    2298:	11 11       	cpse	r17, r1
    229a:	e6 cf       	rjmp	.-52     	; 0x2268 <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    229c:	00 e0       	ldi	r16, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    }
  }
  return(limit_state);
}
    229e:	80 2f       	mov	r24, r16
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	1f 91       	pop	r17
    22a6:	0f 91       	pop	r16
    22a8:	ff 90       	pop	r15
    22aa:	ef 90       	pop	r14
    22ac:	08 95       	ret

000022ae <__vector_3>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    22ae:	1f 92       	push	r1
    22b0:	0f 92       	push	r0
    22b2:	0f b6       	in	r0, 0x3f	; 63
    22b4:	0f 92       	push	r0
    22b6:	11 24       	eor	r1, r1
    22b8:	2f 93       	push	r18
    22ba:	3f 93       	push	r19
    22bc:	4f 93       	push	r20
    22be:	5f 93       	push	r21
    22c0:	6f 93       	push	r22
    22c2:	7f 93       	push	r23
    22c4:	8f 93       	push	r24
    22c6:	9f 93       	push	r25
    22c8:	af 93       	push	r26
    22ca:	bf 93       	push	r27
    22cc:	ef 93       	push	r30
    22ce:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    22d0:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    22d4:	81 30       	cpi	r24, 0x01	; 1
    22d6:	71 f0       	breq	.+28     	; 0x22f4 <__vector_3+0x46>
      if (!(sys_rt_exec_alarm)) {
    22d8:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    22dc:	81 11       	cpse	r24, r1
    22de:	0a c0       	rjmp	.+20     	; 0x22f4 <__vector_3+0x46>
          if (limits_get_state()) {
            mc_reset(); // Initiate system kill.
            bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
          }
        #else
          mc_reset(); // Initiate system kill.
    22e0:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
          bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    22e4:	9f b7       	in	r25, 0x3f	; 63
    22e6:	f8 94       	cli
    22e8:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    22ec:	83 60       	ori	r24, 0x03	; 3
    22ee:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    22f2:	9f bf       	out	0x3f, r25	; 63
        #endif
      }
    }
  }  
    22f4:	ff 91       	pop	r31
    22f6:	ef 91       	pop	r30
    22f8:	bf 91       	pop	r27
    22fa:	af 91       	pop	r26
    22fc:	9f 91       	pop	r25
    22fe:	8f 91       	pop	r24
    2300:	7f 91       	pop	r23
    2302:	6f 91       	pop	r22
    2304:	5f 91       	pop	r21
    2306:	4f 91       	pop	r20
    2308:	3f 91       	pop	r19
    230a:	2f 91       	pop	r18
    230c:	0f 90       	pop	r0
    230e:	0f be       	out	0x3f, r0	; 63
    2310:	0f 90       	pop	r0
    2312:	1f 90       	pop	r1
    2314:	18 95       	reti

00002316 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    2316:	2f 92       	push	r2
    2318:	3f 92       	push	r3
    231a:	4f 92       	push	r4
    231c:	5f 92       	push	r5
    231e:	6f 92       	push	r6
    2320:	7f 92       	push	r7
    2322:	8f 92       	push	r8
    2324:	9f 92       	push	r9
    2326:	af 92       	push	r10
    2328:	bf 92       	push	r11
    232a:	cf 92       	push	r12
    232c:	df 92       	push	r13
    232e:	ef 92       	push	r14
    2330:	ff 92       	push	r15
    2332:	0f 93       	push	r16
    2334:	1f 93       	push	r17
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	cd b7       	in	r28, 0x3d	; 61
    233c:	de b7       	in	r29, 0x3e	; 62
    233e:	6a 97       	sbiw	r28, 0x1a	; 26
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	de bf       	out	0x3e, r29	; 62
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    234a:	90 91 a6 05 	lds	r25, 0x05A6	; 0x8005a6 <sys>
    234e:	91 11       	cpse	r25, r1
    2350:	c9 c1       	rjmp	.+914    	; 0x26e4 <limits_go_home+0x3ce>
    2352:	88 8f       	std	Y+24, r24	; 0x18
    2354:	25 e8       	ldi	r18, 0x85	; 133
    2356:	36 e0       	ldi	r19, 0x06	; 6
    2358:	3f 8b       	std	Y+23, r19	; 0x17
    235a:	2e 8b       	std	Y+22, r18	; 0x16
    235c:	79 01       	movw	r14, r18
    235e:	ce 01       	movw	r24, r28
    2360:	01 96       	adiw	r24, 0x01	; 1
    2362:	5c 01       	movw	r10, r24
    2364:	00 e0       	ldi	r16, 0x00	; 0
    2366:	10 e0       	ldi	r17, 0x00	; 0
    2368:	41 2c       	mov	r4, r1
    236a:	51 2c       	mov	r5, r1
    236c:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    236e:	98 8d       	ldd	r25, Y+24	; 0x18
    2370:	c9 2e       	mov	r12, r25
    2372:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    2374:	80 2f       	mov	r24, r16
    2376:	0e 94 b5 2b 	call	0x576a	; 0x576a <get_step_pin_mask>
    237a:	d5 01       	movw	r26, r10
    237c:	8d 93       	st	X+, r24
    237e:	5d 01       	movw	r10, r26
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    2380:	d9 8a       	std	Y+17, r13	; 0x11
    2382:	c8 8a       	std	Y+16, r12	; 0x10
    2384:	c6 01       	movw	r24, r12
    2386:	00 2e       	mov	r0, r16
    2388:	02 c0       	rjmp	.+4      	; 0x238e <limits_go_home+0x78>
    238a:	95 95       	asr	r25
    238c:	87 95       	ror	r24
    238e:	0a 94       	dec	r0
    2390:	e2 f7       	brpl	.-8      	; 0x238a <limits_go_home+0x74>
    2392:	80 ff       	sbrs	r24, 0
    2394:	19 c0       	rjmp	.+50     	; 0x23c8 <limits_go_home+0xb2>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    2396:	20 e0       	ldi	r18, 0x00	; 0
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	40 ec       	ldi	r20, 0xC0	; 192
    239c:	5f eb       	ldi	r21, 0xBF	; 191
    239e:	f7 01       	movw	r30, r14
    23a0:	64 a1       	ldd	r22, Z+36	; 0x24
    23a2:	75 a1       	ldd	r23, Z+37	; 0x25
    23a4:	86 a1       	ldd	r24, Z+38	; 0x26
    23a6:	97 a1       	ldd	r25, Z+39	; 0x27
    23a8:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    23ac:	86 2e       	mov	r8, r22
    23ae:	97 2e       	mov	r9, r23
    23b0:	28 2e       	mov	r2, r24
    23b2:	39 2e       	mov	r3, r25
    23b4:	a3 01       	movw	r20, r6
    23b6:	92 01       	movw	r18, r4
    23b8:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    23bc:	88 23       	and	r24, r24
    23be:	24 f0       	brlt	.+8      	; 0x23c8 <limits_go_home+0xb2>
    23c0:	48 2c       	mov	r4, r8
    23c2:	59 2c       	mov	r5, r9
    23c4:	62 2c       	mov	r6, r2
    23c6:	73 2c       	mov	r7, r3
    23c8:	0f 5f       	subi	r16, 0xFF	; 255
    23ca:	1f 4f       	sbci	r17, 0xFF	; 255
    23cc:	f4 e0       	ldi	r31, 0x04	; 4
    23ce:	ef 0e       	add	r14, r31
    23d0:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    23d2:	03 30       	cpi	r16, 0x03	; 3
    23d4:	11 05       	cpc	r17, r1
    23d6:	71 f6       	brne	.-100    	; 0x2374 <limits_go_home+0x5e>
    23d8:	28 88       	ldd	r2, Y+16	; 0x10
    23da:	39 88       	ldd	r3, Y+17	; 0x11
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    23dc:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <settings+0x43>
    23e0:	90 91 c9 06 	lds	r25, 0x06C9	; 0x8006c9 <settings+0x44>
    23e4:	a0 91 ca 06 	lds	r26, 0x06CA	; 0x8006ca <settings+0x45>
    23e8:	b0 91 cb 06 	lds	r27, 0x06CB	; 0x8006cb <settings+0x46>
    23ec:	8a 8b       	std	Y+18, r24	; 0x12
    23ee:	9b 8b       	std	Y+19, r25	; 0x13
    23f0:	ac 8b       	std	Y+20, r26	; 0x14
    23f2:	bd 8b       	std	Y+21, r27	; 0x15
    23f4:	94 e0       	ldi	r25, 0x04	; 4
    23f6:	98 8b       	std	Y+16, r25	; 0x10
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    23f8:	01 e0       	ldi	r16, 0x01	; 1
  float homing_rate = settings.homing_seek_rate;

  uint8_t limit_state, axislock, n_active_axis;
  do {

    system_convert_array_steps_to_mpos(target,sys.position);
    23fa:	6a ea       	ldi	r22, 0xAA	; 170
    23fc:	75 e0       	ldi	r23, 0x05	; 5
    23fe:	ce 01       	movw	r24, r28
    2400:	04 96       	adiw	r24, 0x04	; 4
    2402:	0e 94 b1 38 	call	0x7162	; 0x7162 <system_convert_array_steps_to_mpos>
        #else
          sys.position[idx] = 0;
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    2406:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <settings+0x3e>
    240a:	e8 2e       	mov	r14, r24
    240c:	f1 2c       	mov	r15, r1
    240e:	ae 01       	movw	r20, r28
    2410:	4c 5f       	subi	r20, 0xFC	; 252
    2412:	5f 4f       	sbci	r21, 0xFF	; 255
    2414:	0f 2e       	mov	r0, r31
    2416:	f6 ea       	ldi	r31, 0xA6	; 166
    2418:	cf 2e       	mov	r12, r31
    241a:	f5 e0       	ldi	r31, 0x05	; 5
    241c:	df 2e       	mov	r13, r31
    241e:	f0 2d       	mov	r31, r0
    2420:	f6 01       	movw	r30, r12
    2422:	de 01       	movw	r26, r28
    2424:	11 96       	adiw	r26, 0x01	; 1
    2426:	80 e0       	ldi	r24, 0x00	; 0
    2428:	90 e0       	ldi	r25, 0x00	; 0

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    242a:	60 e0       	ldi	r22, 0x00	; 0
  do {

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    242c:	10 e0       	ldi	r17, 0x00	; 0
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
          if (approach) { target[idx] = -max_travel; }
          else { target[idx] = max_travel; }
        } else { 
          if (approach) { target[idx] = max_travel; }
          else { target[idx] = -max_travel; }
    242e:	53 01       	movw	r10, r6
    2430:	42 01       	movw	r8, r4
    2432:	b7 fa       	bst	r11, 7
    2434:	b0 94       	com	r11
    2436:	b7 f8       	bld	r11, 7
    2438:	b0 94       	com	r11
    243a:	ba 8f       	std	Y+26, r27	; 0x1a
    243c:	a9 8f       	std	Y+25, r26	; 0x19
    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
    243e:	91 01       	movw	r18, r2
    2440:	08 2e       	mov	r0, r24
    2442:	02 c0       	rjmp	.+4      	; 0x2448 <limits_go_home+0x132>
    2444:	35 95       	asr	r19
    2446:	27 95       	ror	r18
    2448:	0a 94       	dec	r0
    244a:	e2 f7       	brpl	.-8      	; 0x2444 <limits_go_home+0x12e>
    244c:	20 ff       	sbrs	r18, 0
    244e:	31 c0       	rjmp	.+98     	; 0x24b2 <limits_go_home+0x19c>
        n_active_axis++;
    2450:	6f 5f       	subi	r22, 0xFF	; 255
            sys.position[A_MOTOR] = sys.position[B_MOTOR] = axis_position;
          } else { 
            sys.position[Z_AXIS] = 0; 
          }
        #else
          sys.position[idx] = 0;
    2452:	14 82       	std	Z+4, r1	; 0x04
    2454:	15 82       	std	Z+5, r1	; 0x05
    2456:	16 82       	std	Z+6, r1	; 0x06
    2458:	17 82       	std	Z+7, r1	; 0x07
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    245a:	97 01       	movw	r18, r14
    245c:	08 2e       	mov	r0, r24
    245e:	02 c0       	rjmp	.+4      	; 0x2464 <limits_go_home+0x14e>
    2460:	35 95       	asr	r19
    2462:	27 95       	ror	r18
    2464:	0a 94       	dec	r0
    2466:	e2 f7       	brpl	.-8      	; 0x2460 <limits_go_home+0x14a>
    2468:	20 ff       	sbrs	r18, 0
    246a:	10 c0       	rjmp	.+32     	; 0x248c <limits_go_home+0x176>
          if (approach) { target[idx] = -max_travel; }
    246c:	00 23       	and	r16, r16
    246e:	39 f0       	breq	.+14     	; 0x247e <limits_go_home+0x168>
    2470:	da 01       	movw	r26, r20
    2472:	8d 92       	st	X+, r8
    2474:	9d 92       	st	X+, r9
    2476:	ad 92       	st	X+, r10
    2478:	bc 92       	st	X, r11
    247a:	13 97       	sbiw	r26, 0x03	; 3
    247c:	16 c0       	rjmp	.+44     	; 0x24aa <limits_go_home+0x194>
          else { target[idx] = max_travel; }
    247e:	da 01       	movw	r26, r20
    2480:	4d 92       	st	X+, r4
    2482:	5d 92       	st	X+, r5
    2484:	6d 92       	st	X+, r6
    2486:	7c 92       	st	X, r7
    2488:	13 97       	sbiw	r26, 0x03	; 3
    248a:	0f c0       	rjmp	.+30     	; 0x24aa <limits_go_home+0x194>
        } else { 
          if (approach) { target[idx] = max_travel; }
    248c:	00 23       	and	r16, r16
    248e:	39 f0       	breq	.+14     	; 0x249e <limits_go_home+0x188>
    2490:	da 01       	movw	r26, r20
    2492:	4d 92       	st	X+, r4
    2494:	5d 92       	st	X+, r5
    2496:	6d 92       	st	X+, r6
    2498:	7c 92       	st	X, r7
    249a:	13 97       	sbiw	r26, 0x03	; 3
    249c:	06 c0       	rjmp	.+12     	; 0x24aa <limits_go_home+0x194>
          else { target[idx] = -max_travel; }
    249e:	da 01       	movw	r26, r20
    24a0:	8d 92       	st	X+, r8
    24a2:	9d 92       	st	X+, r9
    24a4:	ad 92       	st	X+, r10
    24a6:	bc 92       	st	X, r11
    24a8:	13 97       	sbiw	r26, 0x03	; 3
        }        
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
    24aa:	a9 8d       	ldd	r26, Y+25	; 0x19
    24ac:	ba 8d       	ldd	r27, Y+26	; 0x1a
    24ae:	2c 91       	ld	r18, X
    24b0:	12 2b       	or	r17, r18
    24b2:	01 96       	adiw	r24, 0x01	; 1
    24b4:	29 8d       	ldd	r18, Y+25	; 0x19
    24b6:	3a 8d       	ldd	r19, Y+26	; 0x1a
    24b8:	2f 5f       	subi	r18, 0xFF	; 255
    24ba:	3f 4f       	sbci	r19, 0xFF	; 255
    24bc:	3a 8f       	std	Y+26, r19	; 0x1a
    24be:	29 8f       	std	Y+25, r18	; 0x19
    24c0:	4c 5f       	subi	r20, 0xFC	; 252
    24c2:	5f 4f       	sbci	r21, 0xFF	; 255
    24c4:	34 96       	adiw	r30, 0x04	; 4
    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    24c6:	83 30       	cpi	r24, 0x03	; 3
    24c8:	91 05       	cpc	r25, r1
    24ca:	09 f0       	breq	.+2      	; 0x24ce <limits_go_home+0x1b8>
    24cc:	b8 cf       	rjmp	.-144    	; 0x243e <limits_go_home+0x128>
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    24ce:	46 2e       	mov	r4, r22
    24d0:	51 2c       	mov	r5, r1
    24d2:	61 2c       	mov	r6, r1
    24d4:	71 2c       	mov	r7, r1
    24d6:	c3 01       	movw	r24, r6
    24d8:	b2 01       	movw	r22, r4
    24da:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    24de:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    24e2:	9b 01       	movw	r18, r22
    24e4:	ac 01       	movw	r20, r24
    24e6:	6a 89       	ldd	r22, Y+18	; 0x12
    24e8:	7b 89       	ldd	r23, Y+19	; 0x13
    24ea:	8c 89       	ldd	r24, Y+20	; 0x14
    24ec:	9d 89       	ldd	r25, Y+21	; 0x15
    24ee:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    24f2:	4b 01       	movw	r8, r22
    24f4:	5c 01       	movw	r10, r24
    sys.homing_axis_lock = axislock;
    24f6:	10 93 c3 05 	sts	0x05C3, r17	; 0x8005c3 <sys+0x1d>

    plan_sync_position(); // Sync planner position to current machine position.
    24fa:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <plan_sync_position>
    
    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    24fe:	20 e0       	ldi	r18, 0x00	; 0
    2500:	b5 01       	movw	r22, r10
    2502:	a4 01       	movw	r20, r8
    2504:	ce 01       	movw	r24, r28
    2506:	04 96       	adiw	r24, 0x04	; 4
    2508:	0e 94 2e 1b 	call	0x365c	; 0x365c <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    250c:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <st_prep_buffer>
    st_wake_up(); // Initiate motion
    2510:	0e 94 4f 2c 	call	0x589e	; 0x589e <st_wake_up>
    do {
      if (approach) {
    2514:	00 23       	and	r16, r16
    2516:	f1 f0       	breq	.+60     	; 0x2554 <limits_go_home+0x23e>
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
    2518:	0e 94 25 11 	call	0x224a	; 0x224a <limits_get_state>
    251c:	fe 01       	movw	r30, r28
    251e:	31 96       	adiw	r30, 0x01	; 1
    2520:	20 e0       	ldi	r18, 0x00	; 0
    2522:	30 e0       	ldi	r19, 0x00	; 0
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
            if (limit_state & (1 << idx)) { 
    2524:	68 2f       	mov	r22, r24
    2526:	70 e0       	ldi	r23, 0x00	; 0
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
    2528:	81 91       	ld	r24, Z+
    252a:	98 2f       	mov	r25, r24
    252c:	91 23       	and	r25, r17
    252e:	59 f0       	breq	.+22     	; 0x2546 <limits_go_home+0x230>
            if (limit_state & (1 << idx)) { 
    2530:	ab 01       	movw	r20, r22
    2532:	02 2e       	mov	r0, r18
    2534:	02 c0       	rjmp	.+4      	; 0x253a <limits_go_home+0x224>
    2536:	55 95       	asr	r21
    2538:	47 95       	ror	r20
    253a:	0a 94       	dec	r0
    253c:	e2 f7       	brpl	.-8      	; 0x2536 <limits_go_home+0x220>
    253e:	40 ff       	sbrs	r20, 0
    2540:	02 c0       	rjmp	.+4      	; 0x2546 <limits_go_home+0x230>
              #ifdef COREXY
                if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
              #else
                axislock &= ~(step_pin[idx]); 
    2542:	80 95       	com	r24
    2544:	18 23       	and	r17, r24
    2546:	2f 5f       	subi	r18, 0xFF	; 255
    2548:	3f 4f       	sbci	r19, 0xFF	; 255
    st_wake_up(); // Initiate motion
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
    254a:	23 30       	cpi	r18, 0x03	; 3
    254c:	31 05       	cpc	r19, r1
    254e:	61 f7       	brne	.-40     	; 0x2528 <limits_go_home+0x212>
                axislock &= ~(step_pin[idx]); 
              #endif
            }
          }
        }
        sys.homing_axis_lock = axislock;
    2550:	10 93 c3 05 	sts	0x05C3, r17	; 0x8005c3 <sys+0x1d>
      }

      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    2554:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <st_prep_buffer>

      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    2558:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    255c:	84 73       	andi	r24, 0x34	; 52
    255e:	c9 f0       	breq	.+50     	; 0x2592 <limits_go_home+0x27c>
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
    2560:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    2564:	80 73       	andi	r24, 0x30	; 48
    2566:	39 f4       	brne	.+14     	; 0x2576 <limits_go_home+0x260>
    2568:	01 11       	cpse	r16, r1
    256a:	b7 c0       	rjmp	.+366    	; 0x26da <limits_go_home+0x3c4>
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
    256c:	0e 94 25 11 	call	0x224a	; 0x224a <limits_get_state>
    2570:	38 8d       	ldd	r19, Y+24	; 0x18
    2572:	83 23       	and	r24, r19
    2574:	29 f0       	breq	.+10     	; 0x2580 <limits_go_home+0x26a>
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
          mc_reset(); // Stop motors, if they are running.
    2576:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
          protocol_execute_realtime();
    257a:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
          return;
    257e:	b2 c0       	rjmp	.+356    	; 0x26e4 <limits_go_home+0x3ce>
        } else {
          // Pull-off motion complete. Disable CYCLE_STOP from executing.
          bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    2580:	9f b7       	in	r25, 0x3f	; 63
    2582:	f8 94       	cli
    2584:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    2588:	8b 7f       	andi	r24, 0xFB	; 251
    258a:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    258e:	9f bf       	out	0x3f, r25	; 63
          break;
    2590:	04 c0       	rjmp	.+8      	; 0x259a <limits_go_home+0x284>
        } 
      }

    } while (STEP_MASK & axislock);
    2592:	81 2f       	mov	r24, r17
    2594:	8c 71       	andi	r24, 0x1C	; 28
    2596:	09 f0       	breq	.+2      	; 0x259a <limits_go_home+0x284>
    2598:	bd cf       	rjmp	.-134    	; 0x2514 <limits_go_home+0x1fe>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    259a:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <st_reset>
    plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    259e:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <plan_reset>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    25a2:	ac ec       	ldi	r26, 0xCC	; 204
    25a4:	b6 e0       	ldi	r27, 0x06	; 6
    25a6:	8d 91       	ld	r24, X+
    25a8:	9c 91       	ld	r25, X
    25aa:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;
    25ae:	b1 e0       	ldi	r27, 0x01	; 1
    25b0:	0b 27       	eor	r16, r27

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) { 
    25b2:	d1 f0       	breq	.+52     	; 0x25e8 <limits_go_home+0x2d2>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR; 
    25b4:	20 e0       	ldi	r18, 0x00	; 0
    25b6:	30 e0       	ldi	r19, 0x00	; 0
    25b8:	40 ea       	ldi	r20, 0xA0	; 160
    25ba:	50 e4       	ldi	r21, 0x40	; 64
    25bc:	ee ec       	ldi	r30, 0xCE	; 206
    25be:	f6 e0       	ldi	r31, 0x06	; 6
    25c0:	60 81       	ld	r22, Z
    25c2:	71 81       	ldd	r23, Z+1	; 0x01
    25c4:	82 81       	ldd	r24, Z+2	; 0x02
    25c6:	93 81       	ldd	r25, Z+3	; 0x03
    25c8:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    25cc:	2b 01       	movw	r4, r22
    25ce:	3c 01       	movw	r6, r24
      homing_rate = settings.homing_feed_rate;
    25d0:	a4 ec       	ldi	r26, 0xC4	; 196
    25d2:	b6 e0       	ldi	r27, 0x06	; 6
    25d4:	8d 91       	ld	r24, X+
    25d6:	9d 91       	ld	r25, X+
    25d8:	0d 90       	ld	r0, X+
    25da:	bc 91       	ld	r27, X
    25dc:	a0 2d       	mov	r26, r0
    25de:	8a 8b       	std	Y+18, r24	; 0x12
    25e0:	9b 8b       	std	Y+19, r25	; 0x13
    25e2:	ac 8b       	std	Y+20, r26	; 0x14
    25e4:	bd 8b       	std	Y+21, r27	; 0x15
    25e6:	11 c0       	rjmp	.+34     	; 0x260a <limits_go_home+0x2f4>
    } else {
      max_travel = settings.homing_pulloff;    
    25e8:	ee ec       	ldi	r30, 0xCE	; 206
    25ea:	f6 e0       	ldi	r31, 0x06	; 6
    25ec:	40 80       	ld	r4, Z
    25ee:	51 80       	ldd	r5, Z+1	; 0x01
    25f0:	62 80       	ldd	r6, Z+2	; 0x02
    25f2:	73 80       	ldd	r7, Z+3	; 0x03
      homing_rate = settings.homing_seek_rate;
    25f4:	a8 ec       	ldi	r26, 0xC8	; 200
    25f6:	b6 e0       	ldi	r27, 0x06	; 6
    25f8:	8d 91       	ld	r24, X+
    25fa:	9d 91       	ld	r25, X+
    25fc:	0d 90       	ld	r0, X+
    25fe:	bc 91       	ld	r27, X
    2600:	a0 2d       	mov	r26, r0
    2602:	8a 8b       	std	Y+18, r24	; 0x12
    2604:	9b 8b       	std	Y+19, r25	; 0x13
    2606:	ac 8b       	std	Y+20, r26	; 0x14
    2608:	bd 8b       	std	Y+21, r27	; 0x15
    260a:	b8 89       	ldd	r27, Y+16	; 0x10
    260c:	b1 50       	subi	r27, 0x01	; 1
    260e:	b8 8b       	std	Y+16, r27	; 0x10
    }
    
  } while (n_cycle-- > 0);
    2610:	b1 11       	cpse	r27, r1
    2612:	f3 ce       	rjmp	.-538    	; 0x23fa <limits_go_home+0xe4>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    2614:	e0 90 c3 06 	lds	r14, 0x06C3	; 0x8006c3 <settings+0x3e>
    2618:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    261a:	80 90 ce 06 	lds	r8, 0x06CE	; 0x8006ce <settings+0x49>
    261e:	90 90 cf 06 	lds	r9, 0x06CF	; 0x8006cf <settings+0x4a>
    2622:	a0 90 d0 06 	lds	r10, 0x06D0	; 0x8006d0 <settings+0x4b>
    2626:	b0 90 d1 06 	lds	r11, 0x06D1	; 0x8006d1 <settings+0x4c>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    262a:	24 01       	movw	r4, r8
    262c:	35 01       	movw	r6, r10
    262e:	77 fa       	bst	r7, 7
    2630:	70 94       	com	r7
    2632:	77 f8       	bld	r7, 7
    2634:	70 94       	com	r7
    2636:	00 e0       	ldi	r16, 0x00	; 0
    2638:	10 e0       	ldi	r17, 0x00	; 0
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    263a:	c1 01       	movw	r24, r2
    263c:	00 2e       	mov	r0, r16
    263e:	02 c0       	rjmp	.+4      	; 0x2644 <limits_go_home+0x32e>
    2640:	95 95       	asr	r25
    2642:	87 95       	ror	r24
    2644:	0a 94       	dec	r0
    2646:	e2 f7       	brpl	.-8      	; 0x2640 <limits_go_home+0x32a>
    2648:	80 ff       	sbrs	r24, 0
    264a:	36 c0       	rjmp	.+108    	; 0x26b8 <limits_go_home+0x3a2>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    264c:	c7 01       	movw	r24, r14
    264e:	00 2e       	mov	r0, r16
    2650:	02 c0       	rjmp	.+4      	; 0x2656 <limits_go_home+0x340>
    2652:	95 95       	asr	r25
    2654:	87 95       	ror	r24
    2656:	0a 94       	dec	r0
    2658:	e2 f7       	brpl	.-8      	; 0x2652 <limits_go_home+0x33c>
    265a:	80 ff       	sbrs	r24, 0
    265c:	15 c0       	rjmp	.+42     	; 0x2688 <limits_go_home+0x372>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    265e:	ee 89       	ldd	r30, Y+22	; 0x16
    2660:	ff 89       	ldd	r31, Y+23	; 0x17
    2662:	24 a1       	ldd	r18, Z+36	; 0x24
    2664:	35 a1       	ldd	r19, Z+37	; 0x25
    2666:	46 a1       	ldd	r20, Z+38	; 0x26
    2668:	57 a1       	ldd	r21, Z+39	; 0x27
    266a:	c5 01       	movw	r24, r10
    266c:	b4 01       	movw	r22, r8
    266e:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2672:	ae 89       	ldd	r26, Y+22	; 0x16
    2674:	bf 89       	ldd	r27, Y+23	; 0x17
    2676:	2d 91       	ld	r18, X+
    2678:	3d 91       	ld	r19, X+
    267a:	4d 91       	ld	r20, X+
    267c:	5c 91       	ld	r21, X
    267e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2682:	0e 94 f1 3b 	call	0x77e2	; 0x77e2 <lround>
    2686:	0c c0       	rjmp	.+24     	; 0x26a0 <limits_go_home+0x38a>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    2688:	ee 89       	ldd	r30, Y+22	; 0x16
    268a:	ff 89       	ldd	r31, Y+23	; 0x17
    268c:	20 81       	ld	r18, Z
    268e:	31 81       	ldd	r19, Z+1	; 0x01
    2690:	42 81       	ldd	r20, Z+2	; 0x02
    2692:	53 81       	ldd	r21, Z+3	; 0x03
    2694:	c3 01       	movw	r24, r6
    2696:	b2 01       	movw	r22, r4
    2698:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    269c:	0e 94 f1 3b 	call	0x77e2	; 0x77e2 <lround>
          sys.position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    26a0:	d6 01       	movw	r26, r12
    26a2:	14 96       	adiw	r26, 0x04	; 4
    26a4:	6c 93       	st	X, r22
    26a6:	14 97       	sbiw	r26, 0x04	; 4
    26a8:	15 96       	adiw	r26, 0x05	; 5
    26aa:	7c 93       	st	X, r23
    26ac:	15 97       	sbiw	r26, 0x05	; 5
    26ae:	16 96       	adiw	r26, 0x06	; 6
    26b0:	8c 93       	st	X, r24
    26b2:	16 97       	sbiw	r26, 0x06	; 6
    26b4:	17 96       	adiw	r26, 0x07	; 7
    26b6:	9c 93       	st	X, r25
    26b8:	0f 5f       	subi	r16, 0xFF	; 255
    26ba:	1f 4f       	sbci	r17, 0xFF	; 255
    26bc:	b4 e0       	ldi	r27, 0x04	; 4
    26be:	cb 0e       	add	r12, r27
    26c0:	d1 1c       	adc	r13, r1
    26c2:	ee 89       	ldd	r30, Y+22	; 0x16
    26c4:	ff 89       	ldd	r31, Y+23	; 0x17
    26c6:	34 96       	adiw	r30, 0x04	; 4
    26c8:	ff 8b       	std	Y+23, r31	; 0x17
    26ca:	ee 8b       	std	Y+22, r30	; 0x16
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    26cc:	03 30       	cpi	r16, 0x03	; 3
    26ce:	11 05       	cpc	r17, r1
    26d0:	09 f0       	breq	.+2      	; 0x26d4 <limits_go_home+0x3be>
    26d2:	b3 cf       	rjmp	.-154    	; 0x263a <limits_go_home+0x324>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    26d4:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <plan_sync_position>
    26d8:	05 c0       	rjmp	.+10     	; 0x26e4 <limits_go_home+0x3ce>
      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
    26da:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    26de:	82 ff       	sbrs	r24, 2
    26e0:	4f cf       	rjmp	.-354    	; 0x2580 <limits_go_home+0x26a>
    26e2:	49 cf       	rjmp	.-366    	; 0x2576 <limits_go_home+0x260>
    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    
  // sys.state = STATE_HOMING; // Ensure system state set as homing before returning. 
}
    26e4:	6a 96       	adiw	r28, 0x1a	; 26
    26e6:	0f b6       	in	r0, 0x3f	; 63
    26e8:	f8 94       	cli
    26ea:	de bf       	out	0x3e, r29	; 62
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	cd bf       	out	0x3d, r28	; 61
    26f0:	df 91       	pop	r29
    26f2:	cf 91       	pop	r28
    26f4:	1f 91       	pop	r17
    26f6:	0f 91       	pop	r16
    26f8:	ff 90       	pop	r15
    26fa:	ef 90       	pop	r14
    26fc:	df 90       	pop	r13
    26fe:	cf 90       	pop	r12
    2700:	bf 90       	pop	r11
    2702:	af 90       	pop	r10
    2704:	9f 90       	pop	r9
    2706:	8f 90       	pop	r8
    2708:	7f 90       	pop	r7
    270a:	6f 90       	pop	r6
    270c:	5f 90       	pop	r5
    270e:	4f 90       	pop	r4
    2710:	3f 90       	pop	r3
    2712:	2f 90       	pop	r2
    2714:	08 95       	ret

00002716 <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    2716:	9f 92       	push	r9
    2718:	af 92       	push	r10
    271a:	bf 92       	push	r11
    271c:	cf 92       	push	r12
    271e:	df 92       	push	r13
    2720:	ef 92       	push	r14
    2722:	ff 92       	push	r15
    2724:	0f 93       	push	r16
    2726:	1f 93       	push	r17
    2728:	cf 93       	push	r28
    272a:	df 93       	push	r29
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    #endif
    
    if (sys.soft_limit) {
    272c:	90 90 a9 05 	lds	r9, 0x05A9	; 0x8005a9 <sys+0x3>
    2730:	ec 01       	movw	r28, r24
    2732:	0f 2e       	mov	r0, r31
    2734:	f9 ea       	ldi	r31, 0xA9	; 169
    2736:	af 2e       	mov	r10, r31
    2738:	f6 e0       	ldi	r31, 0x06	; 6
    273a:	bf 2e       	mov	r11, r31
    273c:	f0 2d       	mov	r31, r0
    273e:	8c 01       	movw	r16, r24
    2740:	04 5f       	subi	r16, 0xF4	; 244
    2742:	1f 4f       	sbci	r17, 0xFF	; 255
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    2744:	c9 90       	ld	r12, Y+
    2746:	d9 90       	ld	r13, Y+
    2748:	e9 90       	ld	r14, Y+
    274a:	f9 90       	ld	r15, Y+
    274c:	20 e0       	ldi	r18, 0x00	; 0
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	a9 01       	movw	r20, r18
    2752:	c7 01       	movw	r24, r14
    2754:	b6 01       	movw	r22, r12
    2756:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    275a:	18 16       	cp	r1, r24
    275c:	64 f0       	brlt	.+24     	; 0x2776 <limits_soft_check+0x60>
    275e:	f5 01       	movw	r30, r10
    2760:	21 91       	ld	r18, Z+
    2762:	31 91       	ld	r19, Z+
    2764:	41 91       	ld	r20, Z+
    2766:	51 91       	ld	r21, Z+
    2768:	5f 01       	movw	r10, r30
    276a:	c7 01       	movw	r24, r14
    276c:	b6 01       	movw	r22, r12
    276e:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    2772:	88 23       	and	r24, r24
    2774:	24 f4       	brge	.+8      	; 0x277e <limits_soft_check+0x68>
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <sys+0x3>
    277c:	02 c0       	rjmp	.+4      	; 0x2782 <limits_soft_check+0x6c>
    #endif
    
    if (sys.soft_limit) {
    277e:	99 20       	and	r9, r9
    2780:	19 f1       	breq	.+70     	; 0x27c8 <limits_soft_check+0xb2>
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    2782:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    2786:	88 30       	cpi	r24, 0x08	; 8
    2788:	91 f4       	brne	.+36     	; 0x27ae <limits_soft_check+0x98>
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
    278a:	9f b7       	in	r25, 0x3f	; 63
    278c:	f8 94       	cli
    278e:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    2792:	88 60       	ori	r24, 0x08	; 8
    2794:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    2798:	9f bf       	out	0x3f, r25	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    279a:	c6 ea       	ldi	r28, 0xA6	; 166
    279c:	d5 e0       	ldi	r29, 0x05	; 5
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    279e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
          if (sys.abort) { return; }
    27a2:	88 81       	ld	r24, Y
    27a4:	81 11       	cpse	r24, r1
    27a6:	14 c0       	rjmp	.+40     	; 0x27d0 <limits_soft_check+0xba>
        } while ( sys.state != STATE_IDLE );
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	81 11       	cpse	r24, r1
    27ac:	f8 cf       	rjmp	.-16     	; 0x279e <limits_soft_check+0x88>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    27ae:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    27b2:	9f b7       	in	r25, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    27ba:	85 60       	ori	r24, 0x05	; 5
    27bc:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    27c0:	9f bf       	out	0x3f, r25	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    27c2:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
      return;
    27c6:	04 c0       	rjmp	.+8      	; 0x27d0 <limits_soft_check+0xba>
// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    27c8:	c0 17       	cp	r28, r16
    27ca:	d1 07       	cpc	r29, r17
    27cc:	09 f0       	breq	.+2      	; 0x27d0 <limits_soft_check+0xba>
    27ce:	ba cf       	rjmp	.-140    	; 0x2744 <limits_soft_check+0x2e>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    27d0:	df 91       	pop	r29
    27d2:	cf 91       	pop	r28
    27d4:	1f 91       	pop	r17
    27d6:	0f 91       	pop	r16
    27d8:	ff 90       	pop	r15
    27da:	ef 90       	pop	r14
    27dc:	df 90       	pop	r13
    27de:	cf 90       	pop	r12
    27e0:	bf 90       	pop	r11
    27e2:	af 90       	pop	r10
    27e4:	9f 90       	pop	r9
    27e6:	08 95       	ret

000027e8 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
    27e8:	0e 94 13 28 	call	0x5026	; 0x5026 <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
    27ec:	0e 94 a8 2b 	call	0x5750	; 0x5750 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    27f0:	0e 94 fc 2e 	call	0x5df8	; 0x5df8 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    27f4:	0e 94 35 36 	call	0x6c6a	; 0x6c6a <system_init>
  
  memset(&sys, 0, sizeof(system_t));  // Clear all system variables
    27f8:	e6 ea       	ldi	r30, 0xA6	; 166
    27fa:	f5 e0       	ldi	r31, 0x05	; 5
    27fc:	8e e1       	ldi	r24, 0x1E	; 30
    27fe:	df 01       	movw	r26, r30
    2800:	1d 92       	st	X+, r1
    2802:	8a 95       	dec	r24
    2804:	e9 f7       	brne	.-6      	; 0x2800 <main+0x18>
  sys.abort = true;   // Set abort to complete initialization
    2806:	81 e0       	ldi	r24, 0x01	; 1
    2808:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    280a:	78 94       	sei
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
    280c:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    2810:	84 ff       	sbrs	r24, 4
    2812:	03 c0       	rjmp	.+6      	; 0x281a <main+0x32>
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <sys+0x1>
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    281a:	c6 ea       	ldi	r28, 0xA6	; 166
    281c:	d5 e0       	ldi	r29, 0x05	; 5

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    281e:	0e 94 ec 28 	call	0x51d8	; 0x51d8 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    2822:	0e 94 fd 05 	call	0xbfa	; 0xbfa <gc_init>
    //spindle_init();
	servo_init();
    2826:	0e 94 f1 28 	call	0x51e2	; 0x51e2 <servo_init>
    coolant_init();
    282a:	0e 94 06 05 	call	0xa0c	; 0xa0c <coolant_init>
    limits_init(); 
    282e:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
    probe_init();
    2832:	0e 94 19 20 	call	0x4032	; 0x4032 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    2836:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    283a:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    283e:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <plan_sync_position>
    gc_sync_position();
    2842:	0e 94 0f 06 	call	0xc1e	; 0xc1e <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    2846:	18 82       	st	Y, r1
    sys_rt_exec_state = 0;
    2848:	10 92 2b 05 	sts	0x052B, r1	; 0x80052b <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
    284c:	10 92 2d 05 	sts	0x052D, r1	; 0x80052d <sys_rt_exec_alarm>
    sys.suspend = false;
    2850:	1a 82       	std	Y+2, r1	; 0x02
    sys.soft_limit = false;
    2852:	1b 82       	std	Y+3, r1	; 0x03
              
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    2854:	0e 94 84 21 	call	0x4308	; 0x4308 <protocol_main_loop>
    2858:	e2 cf       	rjmp	.-60     	; 0x281e <main+0x36>

0000285a <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    285a:	bf 92       	push	r11
    285c:	cf 92       	push	r12
    285e:	df 92       	push	r13
    2860:	ef 92       	push	r14
    2862:	ff 92       	push	r15
    2864:	0f 93       	push	r16
    2866:	1f 93       	push	r17
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
    286c:	8c 01       	movw	r16, r24
    286e:	6a 01       	movw	r12, r20
    2870:	7b 01       	movw	r14, r22
    2872:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    2874:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    2878:	85 ff       	sbrs	r24, 5
    287a:	03 c0       	rjmp	.+6      	; 0x2882 <mc_line+0x28>
    287c:	c8 01       	movw	r24, r16
    287e:	0e 94 8b 13 	call	0x2716	; 0x2716 <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2882:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    2886:	82 30       	cpi	r24, 0x02	; 2
    2888:	a1 f0       	breq	.+40     	; 0x28b2 <mc_line+0x58>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    288a:	c6 ea       	ldi	r28, 0xA6	; 166
    288c:	d5 e0       	ldi	r29, 0x05	; 5
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    288e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    2892:	88 81       	ld	r24, Y
    2894:	81 11       	cpse	r24, r1
    2896:	0d c0       	rjmp	.+26     	; 0x28b2 <mc_line+0x58>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    2898:	0e 94 26 1b 	call	0x364c	; 0x364c <plan_check_full_buffer>
    289c:	88 23       	and	r24, r24
    289e:	19 f0       	breq	.+6      	; 0x28a6 <mc_line+0x4c>
    28a0:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    28a4:	f4 cf       	rjmp	.-24     	; 0x288e <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    28a6:	2b 2d       	mov	r18, r11
    28a8:	b7 01       	movw	r22, r14
    28aa:	a6 01       	movw	r20, r12
    28ac:	c8 01       	movw	r24, r16
    28ae:	0e 94 2e 1b 	call	0x365c	; 0x365c <plan_buffer_line>
  #endif
}
    28b2:	df 91       	pop	r29
    28b4:	cf 91       	pop	r28
    28b6:	1f 91       	pop	r17
    28b8:	0f 91       	pop	r16
    28ba:	ff 90       	pop	r15
    28bc:	ef 90       	pop	r14
    28be:	df 90       	pop	r13
    28c0:	cf 90       	pop	r12
    28c2:	bf 90       	pop	r11
    28c4:	08 95       	ret

000028c6 <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    28c6:	2f 92       	push	r2
    28c8:	3f 92       	push	r3
    28ca:	4f 92       	push	r4
    28cc:	5f 92       	push	r5
    28ce:	6f 92       	push	r6
    28d0:	7f 92       	push	r7
    28d2:	8f 92       	push	r8
    28d4:	9f 92       	push	r9
    28d6:	af 92       	push	r10
    28d8:	bf 92       	push	r11
    28da:	cf 92       	push	r12
    28dc:	df 92       	push	r13
    28de:	ef 92       	push	r14
    28e0:	ff 92       	push	r15
    28e2:	0f 93       	push	r16
    28e4:	1f 93       	push	r17
    28e6:	cf 93       	push	r28
    28e8:	df 93       	push	r29
    28ea:	cd b7       	in	r28, 0x3d	; 61
    28ec:	de b7       	in	r29, 0x3e	; 62
    28ee:	e4 97       	sbiw	r28, 0x34	; 52
    28f0:	0f b6       	in	r0, 0x3f	; 63
    28f2:	f8 94       	cli
    28f4:	de bf       	out	0x3e, r29	; 62
    28f6:	0f be       	out	0x3f, r0	; 63
    28f8:	cd bf       	out	0x3d, r28	; 61
    28fa:	9e 87       	std	Y+14, r25	; 0x0e
    28fc:	8d 87       	std	Y+13, r24	; 0x0d
    28fe:	7c ab       	std	Y+52, r23	; 0x34
    2900:	6b ab       	std	Y+51, r22	; 0x33
    2902:	3a 01       	movw	r6, r20
    2904:	0d 83       	std	Y+5, r16	; 0x05
    2906:	1e 83       	std	Y+6, r17	; 0x06
    2908:	2f 83       	std	Y+7, r18	; 0x07
    290a:	38 87       	std	Y+8, r19	; 0x08
    290c:	cf 86       	std	Y+15, r12	; 0x0f
    290e:	d8 8a       	std	Y+16, r13	; 0x10
    2910:	e9 8a       	std	Y+17, r14	; 0x11
    2912:	fa 8a       	std	Y+18, r15	; 0x12
    2914:	0a 2d       	mov	r16, r10
  float center_axis0 = position[axis_0] + offset[axis_0];
    2916:	91 2c       	mov	r9, r1
    2918:	88 0c       	add	r8, r8
    291a:	99 1c       	adc	r9, r9
    291c:	88 0c       	add	r8, r8
    291e:	99 1c       	adc	r9, r9
    2920:	88 0d       	add	r24, r8
    2922:	99 1d       	adc	r25, r9
    2924:	9c 8b       	std	Y+20, r25	; 0x14
    2926:	8b 8b       	std	Y+19, r24	; 0x13
    2928:	ca 01       	movw	r24, r20
    292a:	88 0d       	add	r24, r8
    292c:	99 1d       	adc	r25, r9
    292e:	98 ab       	std	Y+48, r25	; 0x30
    2930:	8f a7       	std	Y+47, r24	; 0x2f
    2932:	dc 01       	movw	r26, r24
    2934:	2d 90       	ld	r2, X+
    2936:	3d 90       	ld	r3, X+
    2938:	4d 90       	ld	r4, X+
    293a:	5c 90       	ld	r5, X
    293c:	eb 89       	ldd	r30, Y+19	; 0x13
    293e:	fc 89       	ldd	r31, Y+20	; 0x14
    2940:	20 81       	ld	r18, Z
    2942:	31 81       	ldd	r19, Z+1	; 0x01
    2944:	42 81       	ldd	r20, Z+2	; 0x02
    2946:	53 81       	ldd	r21, Z+3	; 0x03
    2948:	c2 01       	movw	r24, r4
    294a:	b1 01       	movw	r22, r2
    294c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2950:	6d 8b       	std	Y+21, r22	; 0x15
    2952:	7e 8b       	std	Y+22, r23	; 0x16
    2954:	8f 8b       	std	Y+23, r24	; 0x17
    2956:	98 8f       	std	Y+24, r25	; 0x18
  float center_axis1 = position[axis_1] + offset[axis_1];
    2958:	2a 96       	adiw	r28, 0x0a	; 10
    295a:	af ac       	ldd	r10, Y+63	; 0x3f
    295c:	2a 97       	sbiw	r28, 0x0a	; 10
    295e:	b1 2c       	mov	r11, r1
    2960:	aa 0c       	add	r10, r10
    2962:	bb 1c       	adc	r11, r11
    2964:	aa 0c       	add	r10, r10
    2966:	bb 1c       	adc	r11, r11
    2968:	8d 85       	ldd	r24, Y+13	; 0x0d
    296a:	9e 85       	ldd	r25, Y+14	; 0x0e
    296c:	8a 0d       	add	r24, r10
    296e:	9b 1d       	adc	r25, r11
    2970:	9a 8f       	std	Y+26, r25	; 0x1a
    2972:	89 8f       	std	Y+25, r24	; 0x19
    2974:	d3 01       	movw	r26, r6
    2976:	aa 0d       	add	r26, r10
    2978:	bb 1d       	adc	r27, r11
    297a:	ba ab       	std	Y+50, r27	; 0x32
    297c:	a9 ab       	std	Y+49, r26	; 0x31
    297e:	cd 90       	ld	r12, X+
    2980:	dd 90       	ld	r13, X+
    2982:	ed 90       	ld	r14, X+
    2984:	fc 90       	ld	r15, X
    2986:	fc 01       	movw	r30, r24
    2988:	20 81       	ld	r18, Z
    298a:	31 81       	ldd	r19, Z+1	; 0x01
    298c:	42 81       	ldd	r20, Z+2	; 0x02
    298e:	53 81       	ldd	r21, Z+3	; 0x03
    2990:	c7 01       	movw	r24, r14
    2992:	b6 01       	movw	r22, r12
    2994:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2998:	6b 8f       	std	Y+27, r22	; 0x1b
    299a:	7c 8f       	std	Y+28, r23	; 0x1c
    299c:	8d 8f       	std	Y+29, r24	; 0x1d
    299e:	9e 8f       	std	Y+30, r25	; 0x1e
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    29a0:	d2 01       	movw	r26, r4
    29a2:	c1 01       	movw	r24, r2
    29a4:	b0 58       	subi	r27, 0x80	; 128
    29a6:	89 83       	std	Y+1, r24	; 0x01
    29a8:	9a 83       	std	Y+2, r25	; 0x02
    29aa:	ab 83       	std	Y+3, r26	; 0x03
    29ac:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
    29ae:	d7 01       	movw	r26, r14
    29b0:	c6 01       	movw	r24, r12
    29b2:	b0 58       	subi	r27, 0x80	; 128
    29b4:	89 87       	std	Y+9, r24	; 0x09
    29b6:	9a 87       	std	Y+10, r25	; 0x0a
    29b8:	ab 87       	std	Y+11, r26	; 0x0b
    29ba:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
    29bc:	eb a9       	ldd	r30, Y+51	; 0x33
    29be:	fc a9       	ldd	r31, Y+52	; 0x34
    29c0:	e8 0d       	add	r30, r8
    29c2:	f9 1d       	adc	r31, r9
    29c4:	2d 89       	ldd	r18, Y+21	; 0x15
    29c6:	3e 89       	ldd	r19, Y+22	; 0x16
    29c8:	4f 89       	ldd	r20, Y+23	; 0x17
    29ca:	58 8d       	ldd	r21, Y+24	; 0x18
    29cc:	60 81       	ld	r22, Z
    29ce:	71 81       	ldd	r23, Z+1	; 0x01
    29d0:	82 81       	ldd	r24, Z+2	; 0x02
    29d2:	93 81       	ldd	r25, Z+3	; 0x03
    29d4:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    29d8:	6b 01       	movw	r12, r22
    29da:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
    29dc:	eb a9       	ldd	r30, Y+51	; 0x33
    29de:	fc a9       	ldd	r31, Y+52	; 0x34
    29e0:	ea 0d       	add	r30, r10
    29e2:	fb 1d       	adc	r31, r11
    29e4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    29e6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    29e8:	4d 8d       	ldd	r20, Y+29	; 0x1d
    29ea:	5e 8d       	ldd	r21, Y+30	; 0x1e
    29ec:	60 81       	ld	r22, Z
    29ee:	71 81       	ldd	r23, Z+1	; 0x01
    29f0:	82 81       	ldd	r24, Z+2	; 0x02
    29f2:	93 81       	ldd	r25, Z+3	; 0x03
    29f4:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    29f8:	4b 01       	movw	r8, r22
    29fa:	5c 01       	movw	r10, r24
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    29fc:	a7 01       	movw	r20, r14
    29fe:	96 01       	movw	r18, r12
    2a00:	69 81       	ldd	r22, Y+1	; 0x01
    2a02:	7a 81       	ldd	r23, Y+2	; 0x02
    2a04:	8b 81       	ldd	r24, Y+3	; 0x03
    2a06:	9c 81       	ldd	r25, Y+4	; 0x04
    2a08:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2a0c:	2b 01       	movw	r4, r22
    2a0e:	3c 01       	movw	r6, r24
    2a10:	a5 01       	movw	r20, r10
    2a12:	94 01       	movw	r18, r8
    2a14:	69 85       	ldd	r22, Y+9	; 0x09
    2a16:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a18:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a1a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a1c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2a20:	9b 01       	movw	r18, r22
    2a22:	ac 01       	movw	r20, r24
    2a24:	c3 01       	movw	r24, r6
    2a26:	b2 01       	movw	r22, r4
    2a28:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2a2c:	2b 01       	movw	r4, r22
    2a2e:	3c 01       	movw	r6, r24
    2a30:	a5 01       	movw	r20, r10
    2a32:	94 01       	movw	r18, r8
    2a34:	69 81       	ldd	r22, Y+1	; 0x01
    2a36:	7a 81       	ldd	r23, Y+2	; 0x02
    2a38:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a3c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2a40:	4b 01       	movw	r8, r22
    2a42:	5c 01       	movw	r10, r24
    2a44:	a7 01       	movw	r20, r14
    2a46:	96 01       	movw	r18, r12
    2a48:	69 85       	ldd	r22, Y+9	; 0x09
    2a4a:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a4c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a4e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a50:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2a54:	9b 01       	movw	r18, r22
    2a56:	ac 01       	movw	r20, r24
    2a58:	c5 01       	movw	r24, r10
    2a5a:	b4 01       	movw	r22, r8
    2a5c:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2a60:	a3 01       	movw	r20, r6
    2a62:	92 01       	movw	r18, r4
    2a64:	0e 94 4c 39 	call	0x7298	; 0x7298 <atan2>
    2a68:	4b 01       	movw	r8, r22
    2a6a:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
    2a6c:	2c 96       	adiw	r28, 0x0c	; 12
    2a6e:	8f ad       	ldd	r24, Y+63	; 0x3f
    2a70:	2c 97       	sbiw	r28, 0x0c	; 12
    2a72:	88 23       	and	r24, r24
    2a74:	a9 f0       	breq	.+42     	; 0x2aa0 <mc_arc+0x1da>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
    2a76:	2d eb       	ldi	r18, 0xBD	; 189
    2a78:	37 e3       	ldi	r19, 0x37	; 55
    2a7a:	46 e0       	ldi	r20, 0x06	; 6
    2a7c:	55 eb       	ldi	r21, 0xB5	; 181
    2a7e:	c5 01       	movw	r24, r10
    2a80:	b4 01       	movw	r22, r8
    2a82:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    2a86:	88 23       	and	r24, r24
    2a88:	fc f0       	brlt	.+62     	; 0x2ac8 <mc_arc+0x202>
    2a8a:	2b ed       	ldi	r18, 0xDB	; 219
    2a8c:	3f e0       	ldi	r19, 0x0F	; 15
    2a8e:	49 ec       	ldi	r20, 0xC9	; 201
    2a90:	50 e4       	ldi	r21, 0x40	; 64
    2a92:	c5 01       	movw	r24, r10
    2a94:	b4 01       	movw	r22, r8
    2a96:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2a9a:	4b 01       	movw	r8, r22
    2a9c:	5c 01       	movw	r10, r24
    2a9e:	14 c0       	rjmp	.+40     	; 0x2ac8 <mc_arc+0x202>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
    2aa0:	2d eb       	ldi	r18, 0xBD	; 189
    2aa2:	37 e3       	ldi	r19, 0x37	; 55
    2aa4:	46 e0       	ldi	r20, 0x06	; 6
    2aa6:	55 e3       	ldi	r21, 0x35	; 53
    2aa8:	c5 01       	movw	r24, r10
    2aaa:	b4 01       	movw	r22, r8
    2aac:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    2ab0:	18 16       	cp	r1, r24
    2ab2:	54 f0       	brlt	.+20     	; 0x2ac8 <mc_arc+0x202>
    2ab4:	2b ed       	ldi	r18, 0xDB	; 219
    2ab6:	3f e0       	ldi	r19, 0x0F	; 15
    2ab8:	49 ec       	ldi	r20, 0xC9	; 201
    2aba:	50 e4       	ldi	r21, 0x40	; 64
    2abc:	c5 01       	movw	r24, r10
    2abe:	b4 01       	movw	r22, r8
    2ac0:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2ac4:	4b 01       	movw	r8, r22
    2ac6:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    2ac8:	c0 90 be 06 	lds	r12, 0x06BE	; 0x8006be <settings+0x39>
    2acc:	d0 90 bf 06 	lds	r13, 0x06BF	; 0x8006bf <settings+0x3a>
    2ad0:	e0 90 c0 06 	lds	r14, 0x06C0	; 0x8006c0 <settings+0x3b>
    2ad4:	f0 90 c1 06 	lds	r15, 0x06C1	; 0x8006c1 <settings+0x3c>
    2ad8:	2d 81       	ldd	r18, Y+5	; 0x05
    2ada:	3e 81       	ldd	r19, Y+6	; 0x06
    2adc:	4f 81       	ldd	r20, Y+7	; 0x07
    2ade:	58 85       	ldd	r21, Y+8	; 0x08
    2ae0:	ca 01       	movw	r24, r20
    2ae2:	b9 01       	movw	r22, r18
    2ae4:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2ae8:	2b 01       	movw	r4, r22
    2aea:	3c 01       	movw	r6, r24
    2aec:	a7 01       	movw	r20, r14
    2aee:	96 01       	movw	r18, r12
    2af0:	c3 01       	movw	r24, r6
    2af2:	b2 01       	movw	r22, r4
    2af4:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2af8:	a7 01       	movw	r20, r14
    2afa:	96 01       	movw	r18, r12
    2afc:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2b00:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    2b04:	6b 01       	movw	r12, r22
    2b06:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    2b08:	20 e0       	ldi	r18, 0x00	; 0
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	40 e0       	ldi	r20, 0x00	; 0
    2b0e:	5f e3       	ldi	r21, 0x3F	; 63
    2b10:	c5 01       	movw	r24, r10
    2b12:	b4 01       	movw	r22, r8
    2b14:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2b18:	2d 81       	ldd	r18, Y+5	; 0x05
    2b1a:	3e 81       	ldd	r19, Y+6	; 0x06
    2b1c:	4f 81       	ldd	r20, Y+7	; 0x07
    2b1e:	58 85       	ldd	r21, Y+8	; 0x08
    2b20:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2b24:	9f 77       	andi	r25, 0x7F	; 127
    2b26:	a7 01       	movw	r20, r14
    2b28:	96 01       	movw	r18, r12
    2b2a:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    2b2e:	0e 94 b1 3a 	call	0x7562	; 0x7562 <floor>
    2b32:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    2b36:	6b 01       	movw	r12, r22
    2b38:	7c 01       	movw	r14, r24
    2b3a:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    2b3c:	61 15       	cp	r22, r1
    2b3e:	71 05       	cpc	r23, r1
    2b40:	09 f4       	brne	.+2      	; 0x2b44 <mc_arc+0x27e>
    2b42:	81 c1       	rjmp	.+770    	; 0x2e46 <mc_arc+0x580>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    2b44:	00 23       	and	r16, r16
    2b46:	81 f0       	breq	.+32     	; 0x2b68 <mc_arc+0x2a2>
    2b48:	80 e0       	ldi	r24, 0x00	; 0
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    2b50:	9b 01       	movw	r18, r22
    2b52:	ac 01       	movw	r20, r24
    2b54:	6f 85       	ldd	r22, Y+15	; 0x0f
    2b56:	78 89       	ldd	r23, Y+16	; 0x10
    2b58:	89 89       	ldd	r24, Y+17	; 0x11
    2b5a:	9a 89       	ldd	r25, Y+18	; 0x12
    2b5c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2b60:	6f 87       	std	Y+15, r22	; 0x0f
    2b62:	78 8b       	std	Y+16, r23	; 0x10
    2b64:	89 8b       	std	Y+17, r24	; 0x11
    2b66:	9a 8b       	std	Y+18, r25	; 0x12
   
    float theta_per_segment = angular_travel/segments;
    2b68:	b6 01       	movw	r22, r12
    2b6a:	80 e0       	ldi	r24, 0x00	; 0
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    2b72:	6b 01       	movw	r12, r22
    2b74:	7c 01       	movw	r14, r24
    2b76:	9b 01       	movw	r18, r22
    2b78:	ac 01       	movw	r20, r24
    2b7a:	c5 01       	movw	r24, r10
    2b7c:	b4 01       	movw	r22, r8
    2b7e:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    2b82:	6b a7       	std	Y+43, r22	; 0x2b
    2b84:	7c a7       	std	Y+44, r23	; 0x2c
    2b86:	8d a7       	std	Y+45, r24	; 0x2d
    2b88:	9e a7       	std	Y+46, r25	; 0x2e
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    2b8a:	2b 96       	adiw	r28, 0x0b	; 11
    2b8c:	8f ad       	ldd	r24, Y+63	; 0x3f
    2b8e:	2b 97       	sbiw	r28, 0x0b	; 11
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	88 0f       	add	r24, r24
    2b94:	99 1f       	adc	r25, r25
    2b96:	88 0f       	add	r24, r24
    2b98:	99 1f       	adc	r25, r25
    2b9a:	4d 84       	ldd	r4, Y+13	; 0x0d
    2b9c:	5e 84       	ldd	r5, Y+14	; 0x0e
    2b9e:	48 0e       	add	r4, r24
    2ba0:	59 1e       	adc	r5, r25
    2ba2:	eb a9       	ldd	r30, Y+51	; 0x33
    2ba4:	fc a9       	ldd	r31, Y+52	; 0x34
    2ba6:	e8 0f       	add	r30, r24
    2ba8:	f9 1f       	adc	r31, r25
    2baa:	d2 01       	movw	r26, r4
    2bac:	2d 91       	ld	r18, X+
    2bae:	3d 91       	ld	r19, X+
    2bb0:	4d 91       	ld	r20, X+
    2bb2:	5c 91       	ld	r21, X
    2bb4:	60 81       	ld	r22, Z
    2bb6:	71 81       	ldd	r23, Z+1	; 0x01
    2bb8:	82 81       	ldd	r24, Z+2	; 0x02
    2bba:	93 81       	ldd	r25, Z+3	; 0x03
    2bbc:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2bc0:	a7 01       	movw	r20, r14
    2bc2:	96 01       	movw	r18, r12
    2bc4:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    2bc8:	6f 8f       	std	Y+31, r22	; 0x1f
    2bca:	78 a3       	std	Y+32, r23	; 0x20
    2bcc:	89 a3       	std	Y+33, r24	; 0x21
    2bce:	9a a3       	std	Y+34, r25	; 0x22
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    2bd0:	2b a5       	ldd	r18, Y+43	; 0x2b
    2bd2:	3c a5       	ldd	r19, Y+44	; 0x2c
    2bd4:	4d a5       	ldd	r20, Y+45	; 0x2d
    2bd6:	5e a5       	ldd	r21, Y+46	; 0x2e
    2bd8:	ca 01       	movw	r24, r20
    2bda:	b9 01       	movw	r22, r18
    2bdc:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2be0:	9b 01       	movw	r18, r22
    2be2:	ac 01       	movw	r20, r24
    2be4:	60 e0       	ldi	r22, 0x00	; 0
    2be6:	70 e0       	ldi	r23, 0x00	; 0
    2be8:	80 e0       	ldi	r24, 0x00	; 0
    2bea:	90 e4       	ldi	r25, 0x40	; 64
    2bec:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2bf0:	6b 01       	movw	r12, r22
    2bf2:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    2bf4:	2b ea       	ldi	r18, 0xAB	; 171
    2bf6:	3a ea       	ldi	r19, 0xAA	; 170
    2bf8:	4a e2       	ldi	r20, 0x2A	; 42
    2bfa:	5e e3       	ldi	r21, 0x3E	; 62
    2bfc:	6b a5       	ldd	r22, Y+43	; 0x2b
    2bfe:	7c a5       	ldd	r23, Y+44	; 0x2c
    2c00:	8d a5       	ldd	r24, Y+45	; 0x2d
    2c02:	9e a5       	ldd	r25, Y+46	; 0x2e
    2c04:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2c08:	4b 01       	movw	r8, r22
    2c0a:	5c 01       	movw	r10, r24
    2c0c:	20 e0       	ldi	r18, 0x00	; 0
    2c0e:	30 e0       	ldi	r19, 0x00	; 0
    2c10:	40 e8       	ldi	r20, 0x80	; 128
    2c12:	50 e4       	ldi	r21, 0x40	; 64
    2c14:	c7 01       	movw	r24, r14
    2c16:	b6 01       	movw	r22, r12
    2c18:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2c1c:	9b 01       	movw	r18, r22
    2c1e:	ac 01       	movw	r20, r24
    2c20:	c5 01       	movw	r24, r10
    2c22:	b4 01       	movw	r22, r8
    2c24:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2c28:	6b a3       	std	Y+35, r22	; 0x23
    2c2a:	7c a3       	std	Y+36, r23	; 0x24
    2c2c:	8d a3       	std	Y+37, r24	; 0x25
    2c2e:	9e a3       	std	Y+38, r25	; 0x26
    cos_T *= 0.5;
    2c30:	20 e0       	ldi	r18, 0x00	; 0
    2c32:	30 e0       	ldi	r19, 0x00	; 0
    2c34:	40 e0       	ldi	r20, 0x00	; 0
    2c36:	5f e3       	ldi	r21, 0x3F	; 63
    2c38:	c7 01       	movw	r24, r14
    2c3a:	b6 01       	movw	r22, r12
    2c3c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2c40:	6f a3       	std	Y+39, r22	; 0x27
    2c42:	78 a7       	std	Y+40, r23	; 0x28
    2c44:	89 a7       	std	Y+41, r24	; 0x29
    2c46:	9a a7       	std	Y+42, r25	; 0x2a
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2c48:	b2 e0       	ldi	r27, 0x02	; 2
    2c4a:	6b 16       	cp	r6, r27
    2c4c:	71 04       	cpc	r7, r1
    2c4e:	08 f4       	brcc	.+2      	; 0x2c52 <mc_arc+0x38c>
    2c50:	fa c0       	rjmp	.+500    	; 0x2e46 <mc_arc+0x580>
    2c52:	10 e0       	ldi	r17, 0x00	; 0
    2c54:	22 24       	eor	r2, r2
    2c56:	23 94       	inc	r2
    2c58:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2c5a:	c9 84       	ldd	r12, Y+9	; 0x09
    2c5c:	da 84       	ldd	r13, Y+10	; 0x0a
    2c5e:	eb 84       	ldd	r14, Y+11	; 0x0b
    2c60:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    2c62:	1c 30       	cpi	r17, 0x0C	; 12
    2c64:	08 f0       	brcs	.+2      	; 0x2c68 <mc_arc+0x3a2>
    2c66:	44 c0       	rjmp	.+136    	; 0x2cf0 <mc_arc+0x42a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    2c68:	a7 01       	movw	r20, r14
    2c6a:	96 01       	movw	r18, r12
    2c6c:	6f a1       	ldd	r22, Y+39	; 0x27
    2c6e:	78 a5       	ldd	r23, Y+40	; 0x28
    2c70:	89 a5       	ldd	r24, Y+41	; 0x29
    2c72:	9a a5       	ldd	r25, Y+42	; 0x2a
    2c74:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2c78:	4b 01       	movw	r8, r22
    2c7a:	5c 01       	movw	r10, r24
    2c7c:	29 81       	ldd	r18, Y+1	; 0x01
    2c7e:	3a 81       	ldd	r19, Y+2	; 0x02
    2c80:	4b 81       	ldd	r20, Y+3	; 0x03
    2c82:	5c 81       	ldd	r21, Y+4	; 0x04
    2c84:	6b a1       	ldd	r22, Y+35	; 0x23
    2c86:	7c a1       	ldd	r23, Y+36	; 0x24
    2c88:	8d a1       	ldd	r24, Y+37	; 0x25
    2c8a:	9e a1       	ldd	r25, Y+38	; 0x26
    2c8c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2c90:	a5 01       	movw	r20, r10
    2c92:	94 01       	movw	r18, r8
    2c94:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2c98:	86 2e       	mov	r8, r22
    2c9a:	97 2e       	mov	r9, r23
    2c9c:	a8 2e       	mov	r10, r24
    2c9e:	b9 2e       	mov	r11, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    2ca0:	29 81       	ldd	r18, Y+1	; 0x01
    2ca2:	3a 81       	ldd	r19, Y+2	; 0x02
    2ca4:	4b 81       	ldd	r20, Y+3	; 0x03
    2ca6:	5c 81       	ldd	r21, Y+4	; 0x04
    2ca8:	6f a1       	ldd	r22, Y+39	; 0x27
    2caa:	78 a5       	ldd	r23, Y+40	; 0x28
    2cac:	89 a5       	ldd	r24, Y+41	; 0x29
    2cae:	9a a5       	ldd	r25, Y+42	; 0x2a
    2cb0:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2cb4:	69 83       	std	Y+1, r22	; 0x01
    2cb6:	7a 83       	std	Y+2, r23	; 0x02
    2cb8:	8b 83       	std	Y+3, r24	; 0x03
    2cba:	9c 83       	std	Y+4, r25	; 0x04
    2cbc:	a7 01       	movw	r20, r14
    2cbe:	96 01       	movw	r18, r12
    2cc0:	6b a1       	ldd	r22, Y+35	; 0x23
    2cc2:	7c a1       	ldd	r23, Y+36	; 0x24
    2cc4:	8d a1       	ldd	r24, Y+37	; 0x25
    2cc6:	9e a1       	ldd	r25, Y+38	; 0x26
    2cc8:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2ccc:	9b 01       	movw	r18, r22
    2cce:	ac 01       	movw	r20, r24
    2cd0:	69 81       	ldd	r22, Y+1	; 0x01
    2cd2:	7a 81       	ldd	r23, Y+2	; 0x02
    2cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd8:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2cdc:	69 83       	std	Y+1, r22	; 0x01
    2cde:	7a 83       	std	Y+2, r23	; 0x02
    2ce0:	8b 83       	std	Y+3, r24	; 0x03
    2ce2:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
    2ce4:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    2ce6:	c8 2c       	mov	r12, r8
    2ce8:	d9 2c       	mov	r13, r9
    2cea:	ea 2c       	mov	r14, r10
    2cec:	fb 2c       	mov	r15, r11
    2cee:	66 c0       	rjmp	.+204    	; 0x2dbc <mc_arc+0x4f6>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    2cf0:	b1 01       	movw	r22, r2
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
    2cf4:	90 e0       	ldi	r25, 0x00	; 0
    2cf6:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    2cfa:	2b a5       	ldd	r18, Y+43	; 0x2b
    2cfc:	3c a5       	ldd	r19, Y+44	; 0x2c
    2cfe:	4d a5       	ldd	r20, Y+45	; 0x2d
    2d00:	5e a5       	ldd	r21, Y+46	; 0x2e
    2d02:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2d06:	6b 01       	movw	r12, r22
    2d08:	7c 01       	movw	r14, r24
    2d0a:	0e 94 c7 39 	call	0x738e	; 0x738e <cos>
    2d0e:	6d 83       	std	Y+5, r22	; 0x05
    2d10:	7e 83       	std	Y+6, r23	; 0x06
    2d12:	8f 83       	std	Y+7, r24	; 0x07
    2d14:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
    2d16:	c7 01       	movw	r24, r14
    2d18:	b6 01       	movw	r22, r12
    2d1a:	0e 94 b5 3c 	call	0x796a	; 0x796a <sin>
    2d1e:	69 87       	std	Y+9, r22	; 0x09
    2d20:	7a 87       	std	Y+10, r23	; 0x0a
    2d22:	8b 87       	std	Y+11, r24	; 0x0b
    2d24:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    2d26:	ef a5       	ldd	r30, Y+47	; 0x2f
    2d28:	f8 a9       	ldd	r31, Y+48	; 0x30
    2d2a:	c0 80       	ld	r12, Z
    2d2c:	d1 80       	ldd	r13, Z+1	; 0x01
    2d2e:	e2 80       	ldd	r14, Z+2	; 0x02
    2d30:	f3 80       	ldd	r15, Z+3	; 0x03
    2d32:	f7 fa       	bst	r15, 7
    2d34:	f0 94       	com	r15
    2d36:	f7 f8       	bld	r15, 7
    2d38:	f0 94       	com	r15
    2d3a:	a9 a9       	ldd	r26, Y+49	; 0x31
    2d3c:	ba a9       	ldd	r27, Y+50	; 0x32
    2d3e:	8d 90       	ld	r8, X+
    2d40:	9d 90       	ld	r9, X+
    2d42:	ad 90       	ld	r10, X+
    2d44:	bc 90       	ld	r11, X
    2d46:	a7 01       	movw	r20, r14
    2d48:	96 01       	movw	r18, r12
    2d4a:	6d 81       	ldd	r22, Y+5	; 0x05
    2d4c:	7e 81       	ldd	r23, Y+6	; 0x06
    2d4e:	8f 81       	ldd	r24, Y+7	; 0x07
    2d50:	98 85       	ldd	r25, Y+8	; 0x08
    2d52:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2d56:	69 83       	std	Y+1, r22	; 0x01
    2d58:	7a 83       	std	Y+2, r23	; 0x02
    2d5a:	8b 83       	std	Y+3, r24	; 0x03
    2d5c:	9c 83       	std	Y+4, r25	; 0x04
    2d5e:	a5 01       	movw	r20, r10
    2d60:	94 01       	movw	r18, r8
    2d62:	69 85       	ldd	r22, Y+9	; 0x09
    2d64:	7a 85       	ldd	r23, Y+10	; 0x0a
    2d66:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d68:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d6a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2d6e:	9b 01       	movw	r18, r22
    2d70:	ac 01       	movw	r20, r24
    2d72:	69 81       	ldd	r22, Y+1	; 0x01
    2d74:	7a 81       	ldd	r23, Y+2	; 0x02
    2d76:	8b 81       	ldd	r24, Y+3	; 0x03
    2d78:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7a:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2d7e:	69 83       	std	Y+1, r22	; 0x01
    2d80:	7a 83       	std	Y+2, r23	; 0x02
    2d82:	8b 83       	std	Y+3, r24	; 0x03
    2d84:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    2d86:	a7 01       	movw	r20, r14
    2d88:	96 01       	movw	r18, r12
    2d8a:	69 85       	ldd	r22, Y+9	; 0x09
    2d8c:	7a 85       	ldd	r23, Y+10	; 0x0a
    2d8e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d90:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d92:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2d96:	6b 01       	movw	r12, r22
    2d98:	7c 01       	movw	r14, r24
    2d9a:	a5 01       	movw	r20, r10
    2d9c:	94 01       	movw	r18, r8
    2d9e:	6d 81       	ldd	r22, Y+5	; 0x05
    2da0:	7e 81       	ldd	r23, Y+6	; 0x06
    2da2:	8f 81       	ldd	r24, Y+7	; 0x07
    2da4:	98 85       	ldd	r25, Y+8	; 0x08
    2da6:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2daa:	9b 01       	movw	r18, r22
    2dac:	ac 01       	movw	r20, r24
    2dae:	c7 01       	movw	r24, r14
    2db0:	b6 01       	movw	r22, r12
    2db2:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2db6:	6b 01       	movw	r12, r22
    2db8:	7c 01       	movw	r14, r24
        count = 0;
    2dba:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    2dbc:	2d 89       	ldd	r18, Y+21	; 0x15
    2dbe:	3e 89       	ldd	r19, Y+22	; 0x16
    2dc0:	4f 89       	ldd	r20, Y+23	; 0x17
    2dc2:	58 8d       	ldd	r21, Y+24	; 0x18
    2dc4:	69 81       	ldd	r22, Y+1	; 0x01
    2dc6:	7a 81       	ldd	r23, Y+2	; 0x02
    2dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dca:	9c 81       	ldd	r25, Y+4	; 0x04
    2dcc:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2dd0:	eb 89       	ldd	r30, Y+19	; 0x13
    2dd2:	fc 89       	ldd	r31, Y+20	; 0x14
    2dd4:	60 83       	st	Z, r22
    2dd6:	71 83       	std	Z+1, r23	; 0x01
    2dd8:	82 83       	std	Z+2, r24	; 0x02
    2dda:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    2ddc:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2dde:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2de0:	4d 8d       	ldd	r20, Y+29	; 0x1d
    2de2:	5e 8d       	ldd	r21, Y+30	; 0x1e
    2de4:	c7 01       	movw	r24, r14
    2de6:	b6 01       	movw	r22, r12
    2de8:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2dec:	a9 8d       	ldd	r26, Y+25	; 0x19
    2dee:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2df0:	6d 93       	st	X+, r22
    2df2:	7d 93       	st	X+, r23
    2df4:	8d 93       	st	X+, r24
    2df6:	9c 93       	st	X, r25
    2df8:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    2dfa:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2dfc:	38 a1       	ldd	r19, Y+32	; 0x20
    2dfe:	49 a1       	ldd	r20, Y+33	; 0x21
    2e00:	5a a1       	ldd	r21, Y+34	; 0x22
    2e02:	f2 01       	movw	r30, r4
    2e04:	60 81       	ld	r22, Z
    2e06:	71 81       	ldd	r23, Z+1	; 0x01
    2e08:	82 81       	ldd	r24, Z+2	; 0x02
    2e0a:	93 81       	ldd	r25, Z+3	; 0x03
    2e0c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    2e10:	d2 01       	movw	r26, r4
    2e12:	6d 93       	st	X+, r22
    2e14:	7d 93       	st	X+, r23
    2e16:	8d 93       	st	X+, r24
    2e18:	9c 93       	st	X, r25
    2e1a:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    2e1c:	20 2f       	mov	r18, r16
    2e1e:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e20:	58 89       	ldd	r21, Y+16	; 0x10
    2e22:	69 89       	ldd	r22, Y+17	; 0x11
    2e24:	7a 89       	ldd	r23, Y+18	; 0x12
    2e26:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e28:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e2a:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2e2e:	e6 ea       	ldi	r30, 0xA6	; 166
    2e30:	f5 e0       	ldi	r31, 0x05	; 5
    2e32:	80 81       	ld	r24, Z
    2e34:	81 11       	cpse	r24, r1
    2e36:	10 c0       	rjmp	.+32     	; 0x2e58 <mc_arc+0x592>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2e38:	ff ef       	ldi	r31, 0xFF	; 255
    2e3a:	2f 1a       	sub	r2, r31
    2e3c:	3f 0a       	sbc	r3, r31
    2e3e:	62 14       	cp	r6, r2
    2e40:	73 04       	cpc	r7, r3
    2e42:	09 f0       	breq	.+2      	; 0x2e46 <mc_arc+0x580>
    2e44:	0e cf       	rjmp	.-484    	; 0x2c62 <mc_arc+0x39c>
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2e46:	20 2f       	mov	r18, r16
    2e48:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e4a:	58 89       	ldd	r21, Y+16	; 0x10
    2e4c:	69 89       	ldd	r22, Y+17	; 0x11
    2e4e:	7a 89       	ldd	r23, Y+18	; 0x12
    2e50:	8b a9       	ldd	r24, Y+51	; 0x33
    2e52:	9c a9       	ldd	r25, Y+52	; 0x34
    2e54:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
  #endif
}
    2e58:	e4 96       	adiw	r28, 0x34	; 52
    2e5a:	0f b6       	in	r0, 0x3f	; 63
    2e5c:	f8 94       	cli
    2e5e:	de bf       	out	0x3e, r29	; 62
    2e60:	0f be       	out	0x3f, r0	; 63
    2e62:	cd bf       	out	0x3d, r28	; 61
    2e64:	df 91       	pop	r29
    2e66:	cf 91       	pop	r28
    2e68:	1f 91       	pop	r17
    2e6a:	0f 91       	pop	r16
    2e6c:	ff 90       	pop	r15
    2e6e:	ef 90       	pop	r14
    2e70:	df 90       	pop	r13
    2e72:	cf 90       	pop	r12
    2e74:	bf 90       	pop	r11
    2e76:	af 90       	pop	r10
    2e78:	9f 90       	pop	r9
    2e7a:	8f 90       	pop	r8
    2e7c:	7f 90       	pop	r7
    2e7e:	6f 90       	pop	r6
    2e80:	5f 90       	pop	r5
    2e82:	4f 90       	pop	r4
    2e84:	3f 90       	pop	r3
    2e86:	2f 90       	pop	r2
    2e88:	08 95       	ret

00002e8a <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    2e8a:	8f 92       	push	r8
    2e8c:	9f 92       	push	r9
    2e8e:	af 92       	push	r10
    2e90:	bf 92       	push	r11
    2e92:	cf 92       	push	r12
    2e94:	df 92       	push	r13
    2e96:	ef 92       	push	r14
    2e98:	ff 92       	push	r15
    2e9a:	cf 93       	push	r28
    2e9c:	df 93       	push	r29
   if (sys.state == STATE_CHECK_MODE) { return; }
    2e9e:	20 91 a7 05 	lds	r18, 0x05A7	; 0x8005a7 <sys+0x1>
    2ea2:	22 30       	cpi	r18, 0x02	; 2
    2ea4:	09 f4       	brne	.+2      	; 0x2ea8 <mc_dwell+0x1e>
    2ea6:	48 c0       	rjmp	.+144    	; 0x2f38 <mc_dwell+0xae>
    2ea8:	4b 01       	movw	r8, r22
    2eaa:	5c 01       	movw	r10, r24
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    2eac:	20 e0       	ldi	r18, 0x00	; 0
    2eae:	30 e0       	ldi	r19, 0x00	; 0
    2eb0:	40 ea       	ldi	r20, 0xA0	; 160
    2eb2:	51 e4       	ldi	r21, 0x41	; 65
    2eb4:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2eb8:	0e 94 b1 3a 	call	0x7562	; 0x7562 <floor>
    2ebc:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    2ec0:	6b 01       	movw	r12, r22
    2ec2:	7c 01       	movw	r14, r24
    2ec4:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    2ec6:	0e 94 31 22 	call	0x4462	; 0x4462 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    2eca:	20 e0       	ldi	r18, 0x00	; 0
    2ecc:	30 e0       	ldi	r19, 0x00	; 0
    2ece:	4a e7       	ldi	r20, 0x7A	; 122
    2ed0:	54 e4       	ldi	r21, 0x44	; 68
    2ed2:	c5 01       	movw	r24, r10
    2ed4:	b4 01       	movw	r22, r8
    2ed6:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    2eda:	4b 01       	movw	r8, r22
    2edc:	5c 01       	movw	r10, r24
    2ede:	82 e3       	ldi	r24, 0x32	; 50
    2ee0:	8c 9d       	mul	r24, r12
    2ee2:	b0 01       	movw	r22, r0
    2ee4:	8d 9d       	mul	r24, r13
    2ee6:	70 0d       	add	r23, r0
    2ee8:	11 24       	eor	r1, r1
    2eea:	80 e0       	ldi	r24, 0x00	; 0
    2eec:	90 e0       	ldi	r25, 0x00	; 0
    2eee:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    2ef2:	9b 01       	movw	r18, r22
    2ef4:	ac 01       	movw	r20, r24
    2ef6:	c5 01       	movw	r24, r10
    2ef8:	b4 01       	movw	r22, r8
    2efa:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    2efe:	0e 94 b1 3a 	call	0x7562	; 0x7562 <floor>
    2f02:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    2f06:	cb 01       	movw	r24, r22
    2f08:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>
   while (i-- > 0) {
    2f0c:	cd 2b       	or	r28, r29
    2f0e:	a1 f0       	breq	.+40     	; 0x2f38 <mc_dwell+0xae>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    2f10:	c6 ea       	ldi	r28, 0xA6	; 166
    2f12:	d5 e0       	ldi	r29, 0x05	; 5
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    2f14:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
     if (sys.abort) { return; }
    2f18:	88 81       	ld	r24, Y
    2f1a:	81 11       	cpse	r24, r1
    2f1c:	0d c0       	rjmp	.+26     	; 0x2f38 <mc_dwell+0xae>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2f1e:	2f ef       	ldi	r18, 0xFF	; 255
    2f20:	80 e7       	ldi	r24, 0x70	; 112
    2f22:	92 e0       	ldi	r25, 0x02	; 2
    2f24:	21 50       	subi	r18, 0x01	; 1
    2f26:	80 40       	sbci	r24, 0x00	; 0
    2f28:	90 40       	sbci	r25, 0x00	; 0
    2f2a:	e1 f7       	brne	.-8      	; 0x2f24 <mc_dwell+0x9a>
    2f2c:	00 c0       	rjmp	.+0      	; 0x2f2e <mc_dwell+0xa4>
    2f2e:	00 00       	nop
    2f30:	21 e0       	ldi	r18, 0x01	; 1
    2f32:	c2 1a       	sub	r12, r18
    2f34:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    2f36:	71 f7       	brne	.-36     	; 0x2f14 <mc_dwell+0x8a>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    2f38:	df 91       	pop	r29
    2f3a:	cf 91       	pop	r28
    2f3c:	ff 90       	pop	r15
    2f3e:	ef 90       	pop	r14
    2f40:	df 90       	pop	r13
    2f42:	cf 90       	pop	r12
    2f44:	bf 90       	pop	r11
    2f46:	af 90       	pop	r10
    2f48:	9f 90       	pop	r9
    2f4a:	8f 90       	pop	r8
    2f4c:	08 95       	ret

00002f4e <mc_homing_cycle>:
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    2f4e:	0e 94 06 11 	call	0x220c	; 0x220c <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    2f52:	84 e0       	ldi	r24, 0x04	; 4
    2f54:	0e 94 8b 11 	call	0x2316	; 0x2316 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    2f58:	83 e0       	ldi	r24, 0x03	; 3
    2f5a:	0e 94 8b 11 	call	0x2316	; 0x2316 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    2f5e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    2f62:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <sys>
    2f66:	81 11       	cpse	r24, r1
    2f68:	04 c0       	rjmp	.+8      	; 0x2f72 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    2f6a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <gc_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    2f6e:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
    2f72:	08 95       	ret

00002f74 <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    2f74:	8f 92       	push	r8
    2f76:	9f 92       	push	r9
    2f78:	af 92       	push	r10
    2f7a:	bf 92       	push	r11
    2f7c:	cf 92       	push	r12
    2f7e:	df 92       	push	r13
    2f80:	ef 92       	push	r14
    2f82:	0f 93       	push	r16
    2f84:	cf 93       	push	r28
    2f86:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f88:	30 91 a7 05 	lds	r19, 0x05A7	; 0x8005a7 <sys+0x1>
    2f8c:	32 30       	cpi	r19, 0x02	; 2
    2f8e:	09 f4       	brne	.+2      	; 0x2f92 <mc_probe_cycle+0x1e>
    2f90:	69 c0       	rjmp	.+210    	; 0x3064 <mc_probe_cycle+0xf0>
    2f92:	c2 2f       	mov	r28, r18
    2f94:	4a 01       	movw	r8, r20
    2f96:	5b 01       	movw	r10, r22
    2f98:	6c 01       	movw	r12, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    2f9a:	0e 94 31 22 	call	0x4462	; 0x4462 <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    2f9e:	10 92 c2 05 	sts	0x05C2, r1	; 0x8005c2 <sys+0x1c>
  probe_configure_invert_mask(is_probe_away);
    2fa2:	80 2f       	mov	r24, r16
    2fa4:	0e 94 1c 20 	call	0x4038	; 0x4038 <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    2fa8:	0e 94 2e 20 	call	0x405c	; 0x405c <probe_get_state>
    2fac:	88 23       	and	r24, r24
    2fae:	51 f0       	breq	.+20     	; 0x2fc4 <mc_probe_cycle+0x50>
    bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    2fb0:	9f b7       	in	r25, 0x3f	; 63
    2fb2:	f8 94       	cli
    2fb4:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    2fb8:	80 61       	ori	r24, 0x10	; 16
    2fba:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    2fbe:	9f bf       	out	0x3f, r25	; 63
    protocol_execute_realtime();
    2fc0:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    2fc4:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <sys>
    2fc8:	81 11       	cpse	r24, r1
    2fca:	4c c0       	rjmp	.+152    	; 0x3064 <mc_probe_cycle+0xf0>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2fcc:	2c 2f       	mov	r18, r28
    2fce:	b5 01       	movw	r22, r10
    2fd0:	a4 01       	movw	r20, r8
    2fd2:	c6 01       	movw	r24, r12
    2fd4:	0e 94 2d 14 	call	0x285a	; 0x285a <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
    2fde:	9f b7       	in	r25, 0x3f	; 63
    2fe0:	f8 94       	cli
    2fe2:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    2fe6:	82 60       	ori	r24, 0x02	; 2
    2fe8:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    2fec:	9f bf       	out	0x3f, r25	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    2fee:	c6 ea       	ldi	r28, 0xA6	; 166
    2ff0:	d5 e0       	ldi	r29, 0x05	; 5
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    2ff2:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    2ff6:	98 81       	ld	r25, Y
    2ff8:	91 11       	cpse	r25, r1
    2ffa:	34 c0       	rjmp	.+104    	; 0x3064 <mc_probe_cycle+0xf0>
  } while (sys.state != STATE_IDLE);
    2ffc:	99 81       	ldd	r25, Y+1	; 0x01
    2ffe:	91 11       	cpse	r25, r1
    3000:	f8 cf       	rjmp	.-16     	; 0x2ff2 <mc_probe_cycle+0x7e>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
    3002:	80 91 2c 05 	lds	r24, 0x052C	; 0x80052c <sys_probe_state>
    3006:	81 30       	cpi	r24, 0x01	; 1
    3008:	a9 f4       	brne	.+42     	; 0x3034 <mc_probe_cycle+0xc0>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    300a:	ee 20       	and	r14, r14
    300c:	51 f0       	breq	.+20     	; 0x3022 <mc_probe_cycle+0xae>
    300e:	8c e0       	ldi	r24, 0x0C	; 12
    3010:	ea ea       	ldi	r30, 0xAA	; 170
    3012:	f5 e0       	ldi	r31, 0x05	; 5
    3014:	a6 eb       	ldi	r26, 0xB6	; 182
    3016:	b5 e0       	ldi	r27, 0x05	; 5
    3018:	01 90       	ld	r0, Z+
    301a:	0d 92       	st	X+, r0
    301c:	8a 95       	dec	r24
    301e:	e1 f7       	brne	.-8      	; 0x3018 <mc_probe_cycle+0xa4>
    3020:	0c c0       	rjmp	.+24     	; 0x303a <mc_probe_cycle+0xc6>
    else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    3022:	9f b7       	in	r25, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    302a:	80 61       	ori	r24, 0x10	; 16
    302c:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    3030:	9f bf       	out	0x3f, r25	; 63
    3032:	03 c0       	rjmp	.+6      	; 0x303a <mc_probe_cycle+0xc6>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    3034:	81 e0       	ldi	r24, 0x01	; 1
    3036:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <sys+0x1c>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    303a:	10 92 2c 05 	sts	0x052C, r1	; 0x80052c <sys_probe_state>
  protocol_execute_realtime();   // Check and execute run-time commands
    303e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    3042:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <sys>
    3046:	81 11       	cpse	r24, r1
    3048:	0d c0       	rjmp	.+26     	; 0x3064 <mc_probe_cycle+0xf0>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    304a:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    304e:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    3052:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    3056:	6a ea       	ldi	r22, 0xAA	; 170
    3058:	75 e0       	ldi	r23, 0x05	; 5
    305a:	c6 01       	movw	r24, r12
    305c:	0e 94 b1 38 	call	0x7162	; 0x7162 <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    3060:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <report_probe_parameters>
  #endif
}
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	0f 91       	pop	r16
    306a:	ef 90       	pop	r14
    306c:	df 90       	pop	r13
    306e:	cf 90       	pop	r12
    3070:	bf 90       	pop	r11
    3072:	af 90       	pop	r10
    3074:	9f 90       	pop	r9
    3076:	8f 90       	pop	r8
    3078:	08 95       	ret

0000307a <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
    307a:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    307e:	84 fd       	sbrc	r24, 4
    3080:	2a c0       	rjmp	.+84     	; 0x30d6 <mc_reset+0x5c>
    bit_true_atomic(sys_rt_exec_state, EXEC_RESET);
    3082:	9f b7       	in	r25, 0x3f	; 63
    3084:	f8 94       	cli
    3086:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    308a:	80 61       	ori	r24, 0x10	; 16
    308c:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    3090:	9f bf       	out	0x3f, r25	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    3092:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <spindle_stop>
    coolant_stop();
    3096:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    309a:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    309e:	98 2f       	mov	r25, r24
    30a0:	9c 70       	andi	r25, 0x0C	; 12
    30a2:	21 f4       	brne	.+8      	; 0x30ac <mc_reset+0x32>
    30a4:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <sys+0x2>
    30a8:	91 30       	cpi	r25, 0x01	; 1
    30aa:	a9 f4       	brne	.+42     	; 0x30d6 <mc_reset+0x5c>
      if (sys.state == STATE_HOMING) { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_HOMING_FAIL); }
    30ac:	84 30       	cpi	r24, 0x04	; 4
    30ae:	49 f4       	brne	.+18     	; 0x30c2 <mc_reset+0x48>
    30b0:	9f b7       	in	r25, 0x3f	; 63
    30b2:	f8 94       	cli
    30b4:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    30b8:	80 62       	ori	r24, 0x20	; 32
    30ba:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    30be:	9f bf       	out	0x3f, r25	; 63
    30c0:	08 c0       	rjmp	.+16     	; 0x30d2 <mc_reset+0x58>
      else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE); }
    30c2:	9f b7       	in	r25, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    30ca:	88 60       	ori	r24, 0x08	; 8
    30cc:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <sys_rt_exec_alarm>
    30d0:	9f bf       	out	0x3f, r25	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    30d2:	0e 94 6e 2c 	call	0x58dc	; 0x58dc <st_go_idle>
    30d6:	08 95       	ret

000030d8 <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    30d8:	4f 92       	push	r4
    30da:	5f 92       	push	r5
    30dc:	6f 92       	push	r6
    30de:	7f 92       	push	r7
    30e0:	8f 92       	push	r8
    30e2:	9f 92       	push	r9
    30e4:	af 92       	push	r10
    30e6:	bf 92       	push	r11
    30e8:	cf 92       	push	r12
    30ea:	df 92       	push	r13
    30ec:	ef 92       	push	r14
    30ee:	ff 92       	push	r15
    30f0:	0f 93       	push	r16
    30f2:	1f 93       	push	r17
    30f4:	cf 93       	push	r28
    30f6:	df 93       	push	r29
    30f8:	dc 01       	movw	r26, r24
    30fa:	fb 01       	movw	r30, r22
    30fc:	c0 81       	ld	r28, Z
    30fe:	d0 e0       	ldi	r29, 0x00	; 0
    3100:	fc 01       	movw	r30, r24
    3102:	ec 0f       	add	r30, r28
    3104:	fd 1f       	adc	r31, r29
    3106:	90 81       	ld	r25, Z
    3108:	9d 32       	cpi	r25, 0x2D	; 45
    310a:	29 f4       	brne	.+10     	; 0x3116 <read_float+0x3e>
    310c:	ef 01       	movw	r28, r30
    310e:	22 96       	adiw	r28, 0x02	; 2
    3110:	91 81       	ldd	r25, Z+1	; 0x01
    3112:	01 e0       	ldi	r16, 0x01	; 1
    3114:	0b c0       	rjmp	.+22     	; 0x312c <read_float+0x54>
    3116:	9b 32       	cpi	r25, 0x2B	; 43
    3118:	29 f0       	breq	.+10     	; 0x3124 <read_float+0x4c>
    311a:	21 96       	adiw	r28, 0x01	; 1
    311c:	ca 0f       	add	r28, r26
    311e:	db 1f       	adc	r29, r27
    3120:	00 e0       	ldi	r16, 0x00	; 0
    3122:	04 c0       	rjmp	.+8      	; 0x312c <read_float+0x54>
    3124:	ef 01       	movw	r28, r30
    3126:	22 96       	adiw	r28, 0x02	; 2
    3128:	91 81       	ldd	r25, Z+1	; 0x01
    312a:	00 e0       	ldi	r16, 0x00	; 0
    312c:	80 e0       	ldi	r24, 0x00	; 0
    312e:	20 e0       	ldi	r18, 0x00	; 0
    3130:	10 e0       	ldi	r17, 0x00	; 0
    3132:	41 2c       	mov	r4, r1
    3134:	51 2c       	mov	r5, r1
    3136:	32 01       	movw	r6, r4
    3138:	31 e0       	ldi	r19, 0x01	; 1
    313a:	fe 01       	movw	r30, r28
    313c:	90 53       	subi	r25, 0x30	; 48
    313e:	9a 30       	cpi	r25, 0x0A	; 10
    3140:	10 f5       	brcc	.+68     	; 0x3186 <read_float+0xae>
    3142:	2f 5f       	subi	r18, 0xFF	; 255
    3144:	29 30       	cpi	r18, 0x09	; 9
    3146:	d8 f4       	brcc	.+54     	; 0x317e <read_float+0xa6>
    3148:	81 11       	cpse	r24, r1
    314a:	11 50       	subi	r17, 0x01	; 1
    314c:	53 01       	movw	r10, r6
    314e:	42 01       	movw	r8, r4
    3150:	88 0c       	add	r8, r8
    3152:	99 1c       	adc	r9, r9
    3154:	aa 1c       	adc	r10, r10
    3156:	bb 1c       	adc	r11, r11
    3158:	88 0c       	add	r8, r8
    315a:	99 1c       	adc	r9, r9
    315c:	aa 1c       	adc	r10, r10
    315e:	bb 1c       	adc	r11, r11
    3160:	84 0c       	add	r8, r4
    3162:	95 1c       	adc	r9, r5
    3164:	a6 1c       	adc	r10, r6
    3166:	b7 1c       	adc	r11, r7
    3168:	88 0c       	add	r8, r8
    316a:	99 1c       	adc	r9, r9
    316c:	aa 1c       	adc	r10, r10
    316e:	bb 1c       	adc	r11, r11
    3170:	24 01       	movw	r4, r8
    3172:	35 01       	movw	r6, r10
    3174:	49 0e       	add	r4, r25
    3176:	51 1c       	adc	r5, r1
    3178:	61 1c       	adc	r6, r1
    317a:	71 1c       	adc	r7, r1
    317c:	09 c0       	rjmp	.+18     	; 0x3190 <read_float+0xb8>
    317e:	81 11       	cpse	r24, r1
    3180:	07 c0       	rjmp	.+14     	; 0x3190 <read_float+0xb8>
    3182:	1f 5f       	subi	r17, 0xFF	; 255
    3184:	05 c0       	rjmp	.+10     	; 0x3190 <read_float+0xb8>
    3186:	9e 3f       	cpi	r25, 0xFE	; 254
    3188:	31 f4       	brne	.+12     	; 0x3196 <read_float+0xbe>
    318a:	81 11       	cpse	r24, r1
    318c:	04 c0       	rjmp	.+8      	; 0x3196 <read_float+0xbe>
    318e:	83 2f       	mov	r24, r19
    3190:	90 81       	ld	r25, Z
    3192:	21 96       	adiw	r28, 0x01	; 1
    3194:	d2 cf       	rjmp	.-92     	; 0x313a <read_float+0x62>
    3196:	22 23       	and	r18, r18
    3198:	09 f4       	brne	.+2      	; 0x319c <read_float+0xc4>
    319a:	52 c0       	rjmp	.+164    	; 0x3240 <read_float+0x168>
    319c:	6a 01       	movw	r12, r20
    319e:	7b 01       	movw	r14, r22
    31a0:	5d 01       	movw	r10, r26
    31a2:	c3 01       	movw	r24, r6
    31a4:	b2 01       	movw	r22, r4
    31a6:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    31aa:	2b 01       	movw	r4, r22
    31ac:	3c 01       	movw	r6, r24
    31ae:	20 e0       	ldi	r18, 0x00	; 0
    31b0:	30 e0       	ldi	r19, 0x00	; 0
    31b2:	a9 01       	movw	r20, r18
    31b4:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    31b8:	88 23       	and	r24, r24
    31ba:	51 f1       	breq	.+84     	; 0x3210 <read_float+0x138>
    31bc:	1f 3f       	cpi	r17, 0xFF	; 255
    31be:	6c f4       	brge	.+26     	; 0x31da <read_float+0x102>
    31c0:	2a e0       	ldi	r18, 0x0A	; 10
    31c2:	37 ed       	ldi	r19, 0xD7	; 215
    31c4:	43 e2       	ldi	r20, 0x23	; 35
    31c6:	5c e3       	ldi	r21, 0x3C	; 60
    31c8:	c3 01       	movw	r24, r6
    31ca:	b2 01       	movw	r22, r4
    31cc:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    31d0:	2b 01       	movw	r4, r22
    31d2:	3c 01       	movw	r6, r24
    31d4:	1e 5f       	subi	r17, 0xFE	; 254
    31d6:	1f 3f       	cpi	r17, 0xFF	; 255
    31d8:	9c f3       	brlt	.-26     	; 0x31c0 <read_float+0xe8>
    31da:	11 23       	and	r17, r17
    31dc:	5c f4       	brge	.+22     	; 0x31f4 <read_float+0x11c>
    31de:	2d ec       	ldi	r18, 0xCD	; 205
    31e0:	3c ec       	ldi	r19, 0xCC	; 204
    31e2:	4c ec       	ldi	r20, 0xCC	; 204
    31e4:	5d e3       	ldi	r21, 0x3D	; 61
    31e6:	c3 01       	movw	r24, r6
    31e8:	b2 01       	movw	r22, r4
    31ea:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    31ee:	2b 01       	movw	r4, r22
    31f0:	3c 01       	movw	r6, r24
    31f2:	0e c0       	rjmp	.+28     	; 0x3210 <read_float+0x138>
    31f4:	11 16       	cp	r1, r17
    31f6:	64 f4       	brge	.+24     	; 0x3210 <read_float+0x138>
    31f8:	20 e0       	ldi	r18, 0x00	; 0
    31fa:	30 e0       	ldi	r19, 0x00	; 0
    31fc:	40 e2       	ldi	r20, 0x20	; 32
    31fe:	51 e4       	ldi	r21, 0x41	; 65
    3200:	c3 01       	movw	r24, r6
    3202:	b2 01       	movw	r22, r4
    3204:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3208:	2b 01       	movw	r4, r22
    320a:	3c 01       	movw	r6, r24
    320c:	11 50       	subi	r17, 0x01	; 1
    320e:	a1 f7       	brne	.-24     	; 0x31f8 <read_float+0x120>
    3210:	00 23       	and	r16, r16
    3212:	51 f0       	breq	.+20     	; 0x3228 <read_float+0x150>
    3214:	77 fa       	bst	r7, 7
    3216:	70 94       	com	r7
    3218:	77 f8       	bld	r7, 7
    321a:	70 94       	com	r7
    321c:	f6 01       	movw	r30, r12
    321e:	40 82       	st	Z, r4
    3220:	51 82       	std	Z+1, r5	; 0x01
    3222:	62 82       	std	Z+2, r6	; 0x02
    3224:	73 82       	std	Z+3, r7	; 0x03
    3226:	05 c0       	rjmp	.+10     	; 0x3232 <read_float+0x15a>
    3228:	f6 01       	movw	r30, r12
    322a:	40 82       	st	Z, r4
    322c:	51 82       	std	Z+1, r5	; 0x01
    322e:	62 82       	std	Z+2, r6	; 0x02
    3230:	73 82       	std	Z+3, r7	; 0x03
    3232:	ca 19       	sub	r28, r10
    3234:	db 09       	sbc	r29, r11
    3236:	c1 50       	subi	r28, 0x01	; 1
    3238:	f7 01       	movw	r30, r14
    323a:	c0 83       	st	Z, r28
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	01 c0       	rjmp	.+2      	; 0x3242 <read_float+0x16a>
    3240:	80 e0       	ldi	r24, 0x00	; 0
    3242:	df 91       	pop	r29
    3244:	cf 91       	pop	r28
    3246:	1f 91       	pop	r17
    3248:	0f 91       	pop	r16
    324a:	ff 90       	pop	r15
    324c:	ef 90       	pop	r14
    324e:	df 90       	pop	r13
    3250:	cf 90       	pop	r12
    3252:	bf 90       	pop	r11
    3254:	af 90       	pop	r10
    3256:	9f 90       	pop	r9
    3258:	8f 90       	pop	r8
    325a:	7f 90       	pop	r7
    325c:	6f 90       	pop	r6
    325e:	5f 90       	pop	r5
    3260:	4f 90       	pop	r4
    3262:	08 95       	ret

00003264 <delay_ms>:
    3264:	00 97       	sbiw	r24, 0x00	; 0
    3266:	41 f0       	breq	.+16     	; 0x3278 <delay_ms+0x14>
    3268:	ef e9       	ldi	r30, 0x9F	; 159
    326a:	ff e0       	ldi	r31, 0x0F	; 15
    326c:	31 97       	sbiw	r30, 0x01	; 1
    326e:	f1 f7       	brne	.-4      	; 0x326c <delay_ms+0x8>
    3270:	00 c0       	rjmp	.+0      	; 0x3272 <delay_ms+0xe>
    3272:	00 00       	nop
    3274:	01 97       	sbiw	r24, 0x01	; 1
    3276:	c1 f7       	brne	.-16     	; 0x3268 <delay_ms+0x4>
    3278:	08 95       	ret

0000327a <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    327a:	4f 92       	push	r4
    327c:	5f 92       	push	r5
    327e:	6f 92       	push	r6
    3280:	7f 92       	push	r7
    3282:	8f 92       	push	r8
    3284:	9f 92       	push	r9
    3286:	af 92       	push	r10
    3288:	bf 92       	push	r11
    328a:	cf 92       	push	r12
    328c:	df 92       	push	r13
    328e:	ef 92       	push	r14
    3290:	ff 92       	push	r15
    3292:	4b 01       	movw	r8, r22
    3294:	5c 01       	movw	r10, r24
    3296:	69 01       	movw	r12, r18
    3298:	7a 01       	movw	r14, r20
    329a:	a5 01       	movw	r20, r10
    329c:	94 01       	movw	r18, r8
    329e:	c5 01       	movw	r24, r10
    32a0:	b4 01       	movw	r22, r8
    32a2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    32a6:	4b 01       	movw	r8, r22
    32a8:	5c 01       	movw	r10, r24
    32aa:	a7 01       	movw	r20, r14
    32ac:	96 01       	movw	r18, r12
    32ae:	c7 01       	movw	r24, r14
    32b0:	b6 01       	movw	r22, r12
    32b2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    32b6:	9b 01       	movw	r18, r22
    32b8:	ac 01       	movw	r20, r24
    32ba:	c5 01       	movw	r24, r10
    32bc:	b4 01       	movw	r22, r8
    32be:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    32c2:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    32c6:	ff 90       	pop	r15
    32c8:	ef 90       	pop	r14
    32ca:	df 90       	pop	r13
    32cc:	cf 90       	pop	r12
    32ce:	bf 90       	pop	r11
    32d0:	af 90       	pop	r10
    32d2:	9f 90       	pop	r9
    32d4:	8f 90       	pop	r8
    32d6:	7f 90       	pop	r7
    32d8:	6f 90       	pop	r6
    32da:	5f 90       	pop	r5
    32dc:	4f 90       	pop	r4
    32de:	08 95       	ret

000032e0 <planner_recalculate>:
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
  return(block_index);
}
    32e0:	2f 92       	push	r2
    32e2:	3f 92       	push	r3
    32e4:	4f 92       	push	r4
    32e6:	5f 92       	push	r5
    32e8:	6f 92       	push	r6
    32ea:	7f 92       	push	r7
    32ec:	8f 92       	push	r8
    32ee:	9f 92       	push	r9
    32f0:	af 92       	push	r10
    32f2:	bf 92       	push	r11
    32f4:	cf 92       	push	r12
    32f6:	df 92       	push	r13
    32f8:	ef 92       	push	r14
    32fa:	ff 92       	push	r15
    32fc:	0f 93       	push	r16
    32fe:	1f 93       	push	r17
    3300:	cf 93       	push	r28
    3302:	df 93       	push	r29
    3304:	c0 91 24 01 	lds	r28, 0x0124	; 0x800124 <block_buffer_head>
    3308:	c1 11       	cpse	r28, r1
    330a:	01 c0       	rjmp	.+2      	; 0x330e <planner_recalculate+0x2e>
    330c:	c2 e1       	ldi	r28, 0x12	; 18
    330e:	c1 50       	subi	r28, 0x01	; 1
    3310:	d0 91 22 01 	lds	r29, 0x0122	; 0x800122 <block_buffer_planned>
    3314:	dc 17       	cp	r29, r28
    3316:	09 f4       	brne	.+2      	; 0x331a <planner_recalculate+0x3a>
    3318:	36 c1       	rjmp	.+620    	; 0x3586 <planner_recalculate+0x2a6>
    331a:	0c 2f       	mov	r16, r28
    331c:	10 e0       	ldi	r17, 0x00	; 0
    331e:	29 e2       	ldi	r18, 0x29	; 41
    3320:	c2 9f       	mul	r28, r18
    3322:	c0 01       	movw	r24, r0
    3324:	11 24       	eor	r1, r1
    3326:	fc 01       	movw	r30, r24
    3328:	ea 5d       	subi	r30, 0xDA	; 218
    332a:	fe 4f       	sbci	r31, 0xFE	; 254
    332c:	6f 01       	movw	r12, r30
    332e:	e5 88       	ldd	r14, Z+21	; 0x15
    3330:	f6 88       	ldd	r15, Z+22	; 0x16
    3332:	97 88       	ldd	r9, Z+23	; 0x17
    3334:	80 8c       	ldd	r8, Z+24	; 0x18
    3336:	61 a1       	ldd	r22, Z+33	; 0x21
    3338:	72 a1       	ldd	r23, Z+34	; 0x22
    333a:	83 a1       	ldd	r24, Z+35	; 0x23
    333c:	94 a1       	ldd	r25, Z+36	; 0x24
    333e:	9b 01       	movw	r18, r22
    3340:	ac 01       	movw	r20, r24
    3342:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    3346:	f6 01       	movw	r30, r12
    3348:	25 a1       	ldd	r18, Z+37	; 0x25
    334a:	36 a1       	ldd	r19, Z+38	; 0x26
    334c:	47 a1       	ldd	r20, Z+39	; 0x27
    334e:	50 a5       	ldd	r21, Z+40	; 0x28
    3350:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3354:	a6 2e       	mov	r10, r22
    3356:	b7 2e       	mov	r11, r23
    3358:	c8 2e       	mov	r12, r24
    335a:	d9 2e       	mov	r13, r25
    335c:	26 2f       	mov	r18, r22
    335e:	37 2f       	mov	r19, r23
    3360:	48 2f       	mov	r20, r24
    3362:	59 2f       	mov	r21, r25
    3364:	6e 2d       	mov	r22, r14
    3366:	7f 2d       	mov	r23, r15
    3368:	89 2d       	mov	r24, r9
    336a:	98 2d       	mov	r25, r8
    336c:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3370:	88 23       	and	r24, r24
    3372:	24 f0       	brlt	.+8      	; 0x337c <planner_recalculate+0x9c>
    3374:	ea 2c       	mov	r14, r10
    3376:	fb 2c       	mov	r15, r11
    3378:	9c 2c       	mov	r9, r12
    337a:	8d 2c       	mov	r8, r13
    337c:	89 e2       	ldi	r24, 0x29	; 41
    337e:	80 9f       	mul	r24, r16
    3380:	f0 01       	movw	r30, r0
    3382:	81 9f       	mul	r24, r17
    3384:	f0 0d       	add	r31, r0
    3386:	11 24       	eor	r1, r1
    3388:	ea 5d       	subi	r30, 0xDA	; 218
    338a:	fe 4f       	sbci	r31, 0xFE	; 254
    338c:	8e 2d       	mov	r24, r14
    338e:	9f 2d       	mov	r25, r15
    3390:	a9 2d       	mov	r26, r9
    3392:	b8 2d       	mov	r27, r8
    3394:	81 8b       	std	Z+17, r24	; 0x11
    3396:	92 8b       	std	Z+18, r25	; 0x12
    3398:	a3 8b       	std	Z+19, r26	; 0x13
    339a:	b4 8b       	std	Z+20, r27	; 0x14
    339c:	c1 11       	cpse	r28, r1
    339e:	01 c0       	rjmp	.+2      	; 0x33a2 <planner_recalculate+0xc2>
    33a0:	c2 e1       	ldi	r28, 0x12	; 18
    33a2:	c1 50       	subi	r28, 0x01	; 1
    33a4:	dc 13       	cpse	r29, r28
    33a6:	07 c0       	rjmp	.+14     	; 0x33b6 <planner_recalculate+0xd6>
    33a8:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    33ac:	d8 13       	cpse	r29, r24
    33ae:	7c c0       	rjmp	.+248    	; 0x34a8 <planner_recalculate+0x1c8>
    33b0:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <st_update_plan_block_parameters>
    33b4:	79 c0       	rjmp	.+242    	; 0x34a8 <planner_recalculate+0x1c8>
    33b6:	29 e2       	ldi	r18, 0x29	; 41
    33b8:	20 9f       	mul	r18, r16
    33ba:	c0 01       	movw	r24, r0
    33bc:	21 9f       	mul	r18, r17
    33be:	90 0d       	add	r25, r0
    33c0:	11 24       	eor	r1, r1
    33c2:	9c 01       	movw	r18, r24
    33c4:	2a 5d       	subi	r18, 0xDA	; 218
    33c6:	3e 4f       	sbci	r19, 0xFE	; 254
    33c8:	69 01       	movw	r12, r18
    33ca:	d9 e2       	ldi	r29, 0x29	; 41
    33cc:	ec 2e       	mov	r14, r28
    33ce:	f1 2c       	mov	r15, r1
    33d0:	de 9d       	mul	r29, r14
    33d2:	80 01       	movw	r16, r0
    33d4:	df 9d       	mul	r29, r15
    33d6:	10 0d       	add	r17, r0
    33d8:	11 24       	eor	r1, r1
    33da:	0a 5d       	subi	r16, 0xDA	; 218
    33dc:	1e 4f       	sbci	r17, 0xFE	; 254
    33de:	c1 11       	cpse	r28, r1
    33e0:	01 c0       	rjmp	.+2      	; 0x33e4 <planner_recalculate+0x104>
    33e2:	c2 e1       	ldi	r28, 0x12	; 18
    33e4:	c1 50       	subi	r28, 0x01	; 1
    33e6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    33ea:	8c 13       	cpse	r24, r28
    33ec:	02 c0       	rjmp	.+4      	; 0x33f2 <planner_recalculate+0x112>
    33ee:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <st_update_plan_block_parameters>
    33f2:	de 9d       	mul	r29, r14
    33f4:	f0 01       	movw	r30, r0
    33f6:	df 9d       	mul	r29, r15
    33f8:	f0 0d       	add	r31, r0
    33fa:	11 24       	eor	r1, r1
    33fc:	ea 5d       	subi	r30, 0xDA	; 218
    33fe:	fe 4f       	sbci	r31, 0xFE	; 254
    3400:	45 88       	ldd	r4, Z+21	; 0x15
    3402:	56 88       	ldd	r5, Z+22	; 0x16
    3404:	67 88       	ldd	r6, Z+23	; 0x17
    3406:	70 8c       	ldd	r7, Z+24	; 0x18
    3408:	a3 01       	movw	r20, r6
    340a:	92 01       	movw	r18, r4
    340c:	61 89       	ldd	r22, Z+17	; 0x11
    340e:	72 89       	ldd	r23, Z+18	; 0x12
    3410:	83 89       	ldd	r24, Z+19	; 0x13
    3412:	94 89       	ldd	r25, Z+20	; 0x14
    3414:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3418:	88 23       	and	r24, r24
    341a:	09 f4       	brne	.+2      	; 0x341e <planner_recalculate+0x13e>
    341c:	40 c0       	rjmp	.+128    	; 0x349e <planner_recalculate+0x1be>
    341e:	de 9d       	mul	r29, r14
    3420:	c0 01       	movw	r24, r0
    3422:	df 9d       	mul	r29, r15
    3424:	90 0d       	add	r25, r0
    3426:	11 24       	eor	r1, r1
    3428:	fc 01       	movw	r30, r24
    342a:	ea 5d       	subi	r30, 0xDA	; 218
    342c:	fe 4f       	sbci	r31, 0xFE	; 254
    342e:	5f 01       	movw	r10, r30
    3430:	61 a1       	ldd	r22, Z+33	; 0x21
    3432:	72 a1       	ldd	r23, Z+34	; 0x22
    3434:	83 a1       	ldd	r24, Z+35	; 0x23
    3436:	94 a1       	ldd	r25, Z+36	; 0x24
    3438:	9b 01       	movw	r18, r22
    343a:	ac 01       	movw	r20, r24
    343c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    3440:	f5 01       	movw	r30, r10
    3442:	25 a1       	ldd	r18, Z+37	; 0x25
    3444:	36 a1       	ldd	r19, Z+38	; 0x26
    3446:	47 a1       	ldd	r20, Z+39	; 0x27
    3448:	50 a5       	ldd	r21, Z+40	; 0x28
    344a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    344e:	f6 01       	movw	r30, r12
    3450:	21 89       	ldd	r18, Z+17	; 0x11
    3452:	32 89       	ldd	r19, Z+18	; 0x12
    3454:	43 89       	ldd	r20, Z+19	; 0x13
    3456:	54 89       	ldd	r21, Z+20	; 0x14
    3458:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    345c:	4b 01       	movw	r8, r22
    345e:	5c 01       	movw	r10, r24
    3460:	9b 01       	movw	r18, r22
    3462:	ac 01       	movw	r20, r24
    3464:	c3 01       	movw	r24, r6
    3466:	b2 01       	movw	r22, r4
    3468:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    346c:	18 16       	cp	r1, r24
    346e:	64 f4       	brge	.+24     	; 0x3488 <planner_recalculate+0x1a8>
    3470:	de 9d       	mul	r29, r14
    3472:	f0 01       	movw	r30, r0
    3474:	df 9d       	mul	r29, r15
    3476:	f0 0d       	add	r31, r0
    3478:	11 24       	eor	r1, r1
    347a:	ea 5d       	subi	r30, 0xDA	; 218
    347c:	fe 4f       	sbci	r31, 0xFE	; 254
    347e:	81 8a       	std	Z+17, r8	; 0x11
    3480:	92 8a       	std	Z+18, r9	; 0x12
    3482:	a3 8a       	std	Z+19, r10	; 0x13
    3484:	b4 8a       	std	Z+20, r11	; 0x14
    3486:	0b c0       	rjmp	.+22     	; 0x349e <planner_recalculate+0x1be>
    3488:	de 9d       	mul	r29, r14
    348a:	f0 01       	movw	r30, r0
    348c:	df 9d       	mul	r29, r15
    348e:	f0 0d       	add	r31, r0
    3490:	11 24       	eor	r1, r1
    3492:	ea 5d       	subi	r30, 0xDA	; 218
    3494:	fe 4f       	sbci	r31, 0xFE	; 254
    3496:	41 8a       	std	Z+17, r4	; 0x11
    3498:	52 8a       	std	Z+18, r5	; 0x12
    349a:	63 8a       	std	Z+19, r6	; 0x13
    349c:	74 8a       	std	Z+20, r7	; 0x14
    349e:	68 01       	movw	r12, r16
    34a0:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <block_buffer_planned>
    34a4:	8c 13       	cpse	r24, r28
    34a6:	92 cf       	rjmp	.-220    	; 0x33cc <planner_recalculate+0xec>
    34a8:	20 90 22 01 	lds	r2, 0x0122	; 0x800122 <block_buffer_planned>
    34ac:	f9 e2       	ldi	r31, 0x29	; 41
    34ae:	2f 9e       	mul	r2, r31
    34b0:	c0 01       	movw	r24, r0
    34b2:	11 24       	eor	r1, r1
    34b4:	9c 01       	movw	r18, r24
    34b6:	2a 5d       	subi	r18, 0xDA	; 218
    34b8:	3e 4f       	sbci	r19, 0xFE	; 254
    34ba:	79 01       	movw	r14, r18
    34bc:	c1 e0       	ldi	r28, 0x01	; 1
    34be:	c2 0d       	add	r28, r2
    34c0:	c2 31       	cpi	r28, 0x12	; 18
    34c2:	09 f4       	brne	.+2      	; 0x34c6 <planner_recalculate+0x1e6>
    34c4:	c0 e0       	ldi	r28, 0x00	; 0
    34c6:	30 90 24 01 	lds	r3, 0x0124	; 0x800124 <block_buffer_head>
    34ca:	d9 e2       	ldi	r29, 0x29	; 41
    34cc:	58 c0       	rjmp	.+176    	; 0x357e <planner_recalculate+0x29e>
    34ce:	cc 2e       	mov	r12, r28
    34d0:	d1 2c       	mov	r13, r1
    34d2:	dc 9d       	mul	r29, r12
    34d4:	80 01       	movw	r16, r0
    34d6:	dd 9d       	mul	r29, r13
    34d8:	10 0d       	add	r17, r0
    34da:	11 24       	eor	r1, r1
    34dc:	0a 5d       	subi	r16, 0xDA	; 218
    34de:	1e 4f       	sbci	r17, 0xFE	; 254
    34e0:	f7 01       	movw	r30, r14
    34e2:	41 88       	ldd	r4, Z+17	; 0x11
    34e4:	52 88       	ldd	r5, Z+18	; 0x12
    34e6:	63 88       	ldd	r6, Z+19	; 0x13
    34e8:	74 88       	ldd	r7, Z+20	; 0x14
    34ea:	f8 01       	movw	r30, r16
    34ec:	81 88       	ldd	r8, Z+17	; 0x11
    34ee:	92 88       	ldd	r9, Z+18	; 0x12
    34f0:	a3 88       	ldd	r10, Z+19	; 0x13
    34f2:	b4 88       	ldd	r11, Z+20	; 0x14
    34f4:	a5 01       	movw	r20, r10
    34f6:	94 01       	movw	r18, r8
    34f8:	c3 01       	movw	r24, r6
    34fa:	b2 01       	movw	r22, r4
    34fc:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3500:	88 23       	and	r24, r24
    3502:	24 f5       	brge	.+72     	; 0x354c <planner_recalculate+0x26c>
    3504:	f7 01       	movw	r30, r14
    3506:	61 a1       	ldd	r22, Z+33	; 0x21
    3508:	72 a1       	ldd	r23, Z+34	; 0x22
    350a:	83 a1       	ldd	r24, Z+35	; 0x23
    350c:	94 a1       	ldd	r25, Z+36	; 0x24
    350e:	9b 01       	movw	r18, r22
    3510:	ac 01       	movw	r20, r24
    3512:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    3516:	f7 01       	movw	r30, r14
    3518:	25 a1       	ldd	r18, Z+37	; 0x25
    351a:	36 a1       	ldd	r19, Z+38	; 0x26
    351c:	47 a1       	ldd	r20, Z+39	; 0x27
    351e:	50 a5       	ldd	r21, Z+40	; 0x28
    3520:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3524:	a3 01       	movw	r20, r6
    3526:	92 01       	movw	r18, r4
    3528:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    352c:	2b 01       	movw	r4, r22
    352e:	3c 01       	movw	r6, r24
    3530:	9b 01       	movw	r18, r22
    3532:	ac 01       	movw	r20, r24
    3534:	c5 01       	movw	r24, r10
    3536:	b4 01       	movw	r22, r8
    3538:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    353c:	18 16       	cp	r1, r24
    353e:	34 f4       	brge	.+12     	; 0x354c <planner_recalculate+0x26c>
    3540:	f8 01       	movw	r30, r16
    3542:	41 8a       	std	Z+17, r4	; 0x11
    3544:	52 8a       	std	Z+18, r5	; 0x12
    3546:	63 8a       	std	Z+19, r6	; 0x13
    3548:	74 8a       	std	Z+20, r7	; 0x14
    354a:	2c 2e       	mov	r2, r28
    354c:	dc 9d       	mul	r29, r12
    354e:	f0 01       	movw	r30, r0
    3550:	dd 9d       	mul	r29, r13
    3552:	f0 0d       	add	r31, r0
    3554:	11 24       	eor	r1, r1
    3556:	ea 5d       	subi	r30, 0xDA	; 218
    3558:	fe 4f       	sbci	r31, 0xFE	; 254
    355a:	25 89       	ldd	r18, Z+21	; 0x15
    355c:	36 89       	ldd	r19, Z+22	; 0x16
    355e:	47 89       	ldd	r20, Z+23	; 0x17
    3560:	50 8d       	ldd	r21, Z+24	; 0x18
    3562:	61 89       	ldd	r22, Z+17	; 0x11
    3564:	72 89       	ldd	r23, Z+18	; 0x12
    3566:	83 89       	ldd	r24, Z+19	; 0x13
    3568:	94 89       	ldd	r25, Z+20	; 0x14
    356a:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    356e:	81 11       	cpse	r24, r1
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <planner_recalculate+0x294>
    3572:	2c 2e       	mov	r2, r28
    3574:	cf 5f       	subi	r28, 0xFF	; 255
    3576:	c2 31       	cpi	r28, 0x12	; 18
    3578:	09 f4       	brne	.+2      	; 0x357c <planner_recalculate+0x29c>
    357a:	c0 e0       	ldi	r28, 0x00	; 0
    357c:	78 01       	movw	r14, r16
    357e:	c3 11       	cpse	r28, r3
    3580:	a6 cf       	rjmp	.-180    	; 0x34ce <planner_recalculate+0x1ee>
    3582:	20 92 22 01 	sts	0x0122, r2	; 0x800122 <block_buffer_planned>
    3586:	df 91       	pop	r29
    3588:	cf 91       	pop	r28
    358a:	1f 91       	pop	r17
    358c:	0f 91       	pop	r16
    358e:	ff 90       	pop	r15
    3590:	ef 90       	pop	r14
    3592:	df 90       	pop	r13
    3594:	cf 90       	pop	r12
    3596:	bf 90       	pop	r11
    3598:	af 90       	pop	r10
    359a:	9f 90       	pop	r9
    359c:	8f 90       	pop	r8
    359e:	7f 90       	pop	r7
    35a0:	6f 90       	pop	r6
    35a2:	5f 90       	pop	r5
    35a4:	4f 90       	pop	r4
    35a6:	3f 90       	pop	r3
    35a8:	2f 90       	pop	r2
    35aa:	08 95       	ret

000035ac <plan_reset>:
}


void plan_reset() 
{
  memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
    35ac:	8c e1       	ldi	r24, 0x1C	; 28
    35ae:	e6 e0       	ldi	r30, 0x06	; 6
    35b0:	f1 e0       	ldi	r31, 0x01	; 1
    35b2:	df 01       	movw	r26, r30
    35b4:	1d 92       	st	X+, r1
    35b6:	8a 95       	dec	r24
    35b8:	e9 f7       	brne	.-6      	; 0x35b4 <plan_reset+0x8>
  block_buffer_tail = 0;
    35ba:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <block_buffer_tail>
  block_buffer_head = 0; // Empty = tail
    35be:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <block_buffer_head>
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <next_buffer_head>
  block_buffer_planned = 0; // = block_buffer_tail;
    35c8:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <block_buffer_planned>
    35cc:	08 95       	ret

000035ce <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    35ce:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    35d2:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <block_buffer_head>
    35d6:	98 17       	cp	r25, r24
    35d8:	69 f0       	breq	.+26     	; 0x35f4 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    35da:	91 e0       	ldi	r25, 0x01	; 1
    35dc:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    35de:	92 31       	cpi	r25, 0x12	; 18
    35e0:	09 f4       	brne	.+2      	; 0x35e4 <plan_discard_current_block+0x16>
    35e2:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    35e4:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <block_buffer_planned>
    35e8:	82 13       	cpse	r24, r18
    35ea:	02 c0       	rjmp	.+4      	; 0x35f0 <plan_discard_current_block+0x22>
    35ec:	90 93 22 01 	sts	0x0122, r25	; 0x800122 <block_buffer_planned>
    block_buffer_tail = block_index;
    35f0:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <block_buffer_tail>
    35f4:	08 95       	ret

000035f6 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    35f6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    35fa:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <block_buffer_head>
    35fe:	98 17       	cp	r25, r24
    3600:	39 f0       	breq	.+14     	; 0x3610 <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    3602:	29 e2       	ldi	r18, 0x29	; 41
    3604:	82 9f       	mul	r24, r18
    3606:	c0 01       	movw	r24, r0
    3608:	11 24       	eor	r1, r1
    360a:	8a 5d       	subi	r24, 0xDA	; 218
    360c:	9e 4f       	sbci	r25, 0xFE	; 254
    360e:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    3610:	80 e0       	ldi	r24, 0x00	; 0
    3612:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    3614:	08 95       	ret

00003616 <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    3616:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <block_buffer_tail>
    361a:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    361c:	e2 31       	cpi	r30, 0x12	; 18
    361e:	09 f4       	brne	.+2      	; 0x3622 <plan_get_exec_block_exit_speed+0xc>
    3620:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3622:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <block_buffer_head>
    3626:	8e 17       	cp	r24, r30
    3628:	69 f0       	breq	.+26     	; 0x3644 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    362a:	89 e2       	ldi	r24, 0x29	; 41
    362c:	e8 9f       	mul	r30, r24
    362e:	f0 01       	movw	r30, r0
    3630:	11 24       	eor	r1, r1
    3632:	ea 5d       	subi	r30, 0xDA	; 218
    3634:	fe 4f       	sbci	r31, 0xFE	; 254
    3636:	61 89       	ldd	r22, Z+17	; 0x11
    3638:	72 89       	ldd	r23, Z+18	; 0x12
    363a:	83 89       	ldd	r24, Z+19	; 0x13
    363c:	94 89       	ldd	r25, Z+20	; 0x14
    363e:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    3642:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3644:	60 e0       	ldi	r22, 0x00	; 0
    3646:	70 e0       	ldi	r23, 0x00	; 0
    3648:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    364a:	08 95       	ret

0000364c <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
    364c:	81 e0       	ldi	r24, 0x01	; 1
    364e:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <block_buffer_tail>
    3652:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <next_buffer_head>
    3656:	29 13       	cpse	r18, r25
    3658:	80 e0       	ldi	r24, 0x00	; 0
  if (block_buffer_tail == next_buffer_head) { return(true); }
  return(false);
}
    365a:	08 95       	ret

0000365c <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    365c:	2f 92       	push	r2
    365e:	3f 92       	push	r3
    3660:	4f 92       	push	r4
    3662:	5f 92       	push	r5
    3664:	6f 92       	push	r6
    3666:	7f 92       	push	r7
    3668:	8f 92       	push	r8
    366a:	9f 92       	push	r9
    366c:	af 92       	push	r10
    366e:	bf 92       	push	r11
    3670:	cf 92       	push	r12
    3672:	df 92       	push	r13
    3674:	ef 92       	push	r14
    3676:	ff 92       	push	r15
    3678:	0f 93       	push	r16
    367a:	1f 93       	push	r17
    367c:	cf 93       	push	r28
    367e:	df 93       	push	r29
    3680:	cd b7       	in	r28, 0x3d	; 61
    3682:	de b7       	in	r29, 0x3e	; 62
    3684:	e8 97       	sbiw	r28, 0x38	; 56
    3686:	0f b6       	in	r0, 0x3f	; 63
    3688:	f8 94       	cli
    368a:	de bf       	out	0x3e, r29	; 62
    368c:	0f be       	out	0x3f, r0	; 63
    368e:	cd bf       	out	0x3d, r28	; 61
    3690:	4b a7       	std	Y+43, r20	; 0x2b
    3692:	5c a7       	std	Y+44, r21	; 0x2c
    3694:	6d a7       	std	Y+45, r22	; 0x2d
    3696:	7e a7       	std	Y+46, r23	; 0x2e
    3698:	02 2f       	mov	r16, r18
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    369a:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <block_buffer_head>
  block->step_event_count = 0;
    369e:	39 e2       	ldi	r19, 0x29	; 41
    36a0:	23 9f       	mul	r18, r19
    36a2:	a0 01       	movw	r20, r0
    36a4:	11 24       	eor	r1, r1
    36a6:	fa 01       	movw	r30, r20
    36a8:	ea 5d       	subi	r30, 0xDA	; 218
    36aa:	fe 4f       	sbci	r31, 0xFE	; 254
    36ac:	15 86       	std	Z+13, r1	; 0x0d
    36ae:	16 86       	std	Z+14, r1	; 0x0e
    36b0:	17 86       	std	Z+15, r1	; 0x0f
    36b2:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    36b4:	15 a2       	std	Z+37, r1	; 0x25
    36b6:	16 a2       	std	Z+38, r1	; 0x26
    36b8:	17 a2       	std	Z+39, r1	; 0x27
    36ba:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    36bc:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    36be:	0f 2e       	mov	r0, r31
    36c0:	f9 e9       	ldi	r31, 0x99	; 153
    36c2:	cf 2e       	mov	r12, r31
    36c4:	f6 e7       	ldi	r31, 0x76	; 118
    36c6:	df 2e       	mov	r13, r31
    36c8:	f6 e9       	ldi	r31, 0x96	; 150
    36ca:	ef 2e       	mov	r14, r31
    36cc:	fe e7       	ldi	r31, 0x7E	; 126
    36ce:	ff 2e       	mov	r15, r31
    36d0:	f0 2d       	mov	r31, r0
    36d2:	c1 a2       	std	Z+33, r12	; 0x21
    36d4:	d2 a2       	std	Z+34, r13	; 0x22
    36d6:	e3 a2       	std	Z+35, r14	; 0x23
    36d8:	f4 a2       	std	Z+36, r15	; 0x24
    36da:	9a 8f       	std	Y+26, r25	; 0x1a
    36dc:	89 8f       	std	Y+25, r24	; 0x19
    36de:	85 e8       	ldi	r24, 0x85	; 133
    36e0:	96 e0       	ldi	r25, 0x06	; 6
    36e2:	9a ab       	std	Y+50, r25	; 0x32
    36e4:	89 ab       	std	Y+49, r24	; 0x31
    36e6:	de 01       	movw	r26, r28
    36e8:	11 96       	adiw	r26, 0x01	; 1
    36ea:	bc 8f       	std	Y+28, r27	; 0x1c
    36ec:	ab 8f       	std	Y+27, r26	; 0x1b
    36ee:	e6 e0       	ldi	r30, 0x06	; 6
    36f0:	f1 e0       	ldi	r31, 0x01	; 1
    36f2:	fc ab       	std	Y+52, r31	; 0x34
    36f4:	eb ab       	std	Y+51, r30	; 0x33
    36f6:	ca 01       	movw	r24, r20
    36f8:	89 5d       	subi	r24, 0xD9	; 217
    36fa:	9e 4f       	sbci	r25, 0xFE	; 254
    36fc:	9e 8f       	std	Y+30, r25	; 0x1e
    36fe:	8d 8f       	std	Y+29, r24	; 0x1d
    3700:	4e 01       	movw	r8, r28
    3702:	9d e0       	ldi	r25, 0x0D	; 13
    3704:	89 0e       	add	r8, r25
    3706:	91 1c       	adc	r9, r1
    3708:	9a a2       	std	Y+34, r9	; 0x22
    370a:	89 a2       	std	Y+33, r8	; 0x21
    370c:	5f 01       	movw	r10, r30
    370e:	a5 e8       	ldi	r26, 0x85	; 133
    3710:	b6 e0       	ldi	r27, 0x06	; 6
    3712:	bc a3       	std	Y+36, r27	; 0x24
    3714:	ab a3       	std	Y+35, r26	; 0x23
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    3716:	10 e0       	ldi	r17, 0x00	; 0
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    3718:	e2 2f       	mov	r30, r18
    371a:	f0 e0       	ldi	r31, 0x00	; 0
    371c:	f8 ab       	std	Y+48, r31	; 0x30
    371e:	ef a7       	std	Y+47, r30	; 0x2f
    3720:	9a 01       	movw	r18, r20
    3722:	2a 5d       	subi	r18, 0xDA	; 218
    3724:	3e 4f       	sbci	r19, 0xFE	; 254
    3726:	3a a7       	std	Y+42, r19	; 0x2a
    3728:	29 a7       	std	Y+41, r18	; 0x29
    372a:	23 5f       	subi	r18, 0xF3	; 243
    372c:	3f 4f       	sbci	r19, 0xFF	; 255
    372e:	38 a7       	std	Y+40, r19	; 0x28
    3730:	2f a3       	std	Y+39, r18	; 0x27
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    3732:	29 a4       	ldd	r2, Y+41	; 0x29
    3734:	3a a4       	ldd	r3, Y+42	; 0x2a
    3736:	35 e2       	ldi	r19, 0x25	; 37
    3738:	23 0e       	add	r2, r19
    373a:	31 1c       	adc	r3, r1
        delta_mm = (target_steps[X_AXIS]-pl.position[X_AXIS] - target_steps[Y_AXIS]+pl.position[Y_AXIS])/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    373c:	a9 8d       	ldd	r26, Y+25	; 0x19
    373e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3740:	6d 91       	ld	r22, X+
    3742:	7d 91       	ld	r23, X+
    3744:	8d 91       	ld	r24, X+
    3746:	9d 91       	ld	r25, X+
    3748:	ba 8f       	std	Y+26, r27	; 0x1a
    374a:	a9 8f       	std	Y+25, r26	; 0x19
    374c:	eb a1       	ldd	r30, Y+35	; 0x23
    374e:	fc a1       	ldd	r31, Y+36	; 0x24
    3750:	41 90       	ld	r4, Z+
    3752:	51 90       	ld	r5, Z+
    3754:	61 90       	ld	r6, Z+
    3756:	71 90       	ld	r7, Z+
    3758:	fc a3       	std	Y+36, r31	; 0x24
    375a:	eb a3       	std	Y+35, r30	; 0x23
    375c:	a3 01       	movw	r20, r6
    375e:	92 01       	movw	r18, r4
    3760:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3764:	0e 94 f1 3b 	call	0x77e2	; 0x77e2 <lround>
    3768:	ab 8d       	ldd	r26, Y+27	; 0x1b
    376a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    376c:	6d 93       	st	X+, r22
    376e:	7d 93       	st	X+, r23
    3770:	8d 93       	st	X+, r24
    3772:	9d 93       	st	X+, r25
    3774:	bc 8f       	std	Y+28, r27	; 0x1c
    3776:	ab 8f       	std	Y+27, r26	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    3778:	f5 01       	movw	r30, r10
    377a:	c1 90       	ld	r12, Z+
    377c:	d1 90       	ld	r13, Z+
    377e:	e1 90       	ld	r14, Z+
    3780:	f1 90       	ld	r15, Z+
    3782:	5f 01       	movw	r10, r30
    3784:	6c 19       	sub	r22, r12
    3786:	7d 09       	sbc	r23, r13
    3788:	8e 09       	sbc	r24, r14
    378a:	9f 09       	sbc	r25, r15
    378c:	9b 01       	movw	r18, r22
    378e:	ac 01       	movw	r20, r24
    3790:	3a f4       	brpl	.+14     	; 0x37a0 <plan_buffer_line+0x144>
    3792:	22 27       	eor	r18, r18
    3794:	33 27       	eor	r19, r19
    3796:	a9 01       	movw	r20, r18
    3798:	26 1b       	sub	r18, r22
    379a:	37 0b       	sbc	r19, r23
    379c:	48 0b       	sbc	r20, r24
    379e:	59 0b       	sbc	r21, r25
    37a0:	ad 8d       	ldd	r26, Y+29	; 0x1d
    37a2:	be 8d       	ldd	r27, Y+30	; 0x1e
    37a4:	2d 93       	st	X+, r18
    37a6:	3d 93       	st	X+, r19
    37a8:	4d 93       	st	X+, r20
    37aa:	5d 93       	st	X+, r21
    37ac:	be 8f       	std	Y+30, r27	; 0x1e
    37ae:	ad 8f       	std	Y+29, r26	; 0x1d
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    37b0:	ef a1       	ldd	r30, Y+39	; 0x27
    37b2:	f8 a5       	ldd	r31, Y+40	; 0x28
    37b4:	c0 80       	ld	r12, Z
    37b6:	d1 80       	ldd	r13, Z+1	; 0x01
    37b8:	e2 80       	ldd	r14, Z+2	; 0x02
    37ba:	f3 80       	ldd	r15, Z+3	; 0x03
    37bc:	c2 16       	cp	r12, r18
    37be:	d3 06       	cpc	r13, r19
    37c0:	e4 06       	cpc	r14, r20
    37c2:	f5 06       	cpc	r15, r21
    37c4:	10 f4       	brcc	.+4      	; 0x37ca <plan_buffer_line+0x16e>
    37c6:	69 01       	movw	r12, r18
    37c8:	7a 01       	movw	r14, r20
    37ca:	af a1       	ldd	r26, Y+39	; 0x27
    37cc:	b8 a5       	ldd	r27, Y+40	; 0x28
    37ce:	cd 92       	st	X+, r12
    37d0:	dd 92       	st	X+, r13
    37d2:	ed 92       	st	X+, r14
    37d4:	fc 92       	st	X, r15
    37d6:	13 97       	sbiw	r26, 0x03	; 3
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    37d8:	0e 94 76 3a 	call	0x74ec	; 0x74ec <__floatsisf>
    37dc:	a3 01       	movw	r20, r6
    37de:	92 01       	movw	r18, r4
    37e0:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    37e4:	2b 01       	movw	r4, r22
    37e6:	3c 01       	movw	r6, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    37e8:	e9 a1       	ldd	r30, Y+33	; 0x21
    37ea:	fa a1       	ldd	r31, Y+34	; 0x22
    37ec:	61 93       	st	Z+, r22
    37ee:	71 93       	st	Z+, r23
    37f0:	81 93       	st	Z+, r24
    37f2:	91 93       	st	Z+, r25
    37f4:	fa a3       	std	Y+34, r31	; 0x22
    37f6:	e9 a3       	std	Y+33, r30	; 0x21
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    37f8:	20 e0       	ldi	r18, 0x00	; 0
    37fa:	30 e0       	ldi	r19, 0x00	; 0
    37fc:	a9 01       	movw	r20, r18
    37fe:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3802:	88 23       	and	r24, r24
    3804:	44 f4       	brge	.+16     	; 0x3816 <plan_buffer_line+0x1ba>
    3806:	81 2f       	mov	r24, r17
    3808:	0e 94 bf 2b 	call	0x577e	; 0x577e <get_direction_pin_mask>
    380c:	a9 a5       	ldd	r26, Y+41	; 0x29
    380e:	ba a5       	ldd	r27, Y+42	; 0x2a
    3810:	9c 91       	ld	r25, X
    3812:	89 2b       	or	r24, r25
    3814:	8c 93       	st	X, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    3816:	a3 01       	movw	r20, r6
    3818:	92 01       	movw	r18, r4
    381a:	c3 01       	movw	r24, r6
    381c:	b2 01       	movw	r22, r4
    381e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3822:	f1 01       	movw	r30, r2
    3824:	20 81       	ld	r18, Z
    3826:	31 81       	ldd	r19, Z+1	; 0x01
    3828:	42 81       	ldd	r20, Z+2	; 0x02
    382a:	53 81       	ldd	r21, Z+3	; 0x03
    382c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    3830:	d1 01       	movw	r26, r2
    3832:	6d 93       	st	X+, r22
    3834:	7d 93       	st	X+, r23
    3836:	8d 93       	st	X+, r24
    3838:	9c 93       	st	X, r25
    383a:	13 97       	sbiw	r26, 0x03	; 3
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    383c:	1f 5f       	subi	r17, 0xFF	; 255
    383e:	13 30       	cpi	r17, 0x03	; 3
    3840:	09 f0       	breq	.+2      	; 0x3844 <plan_buffer_line+0x1e8>
    3842:	7c cf       	rjmp	.-264    	; 0x373c <plan_buffer_line+0xe0>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    3844:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    3848:	6b 01       	movw	r12, r22
    384a:	7c 01       	movw	r14, r24
    384c:	89 e2       	ldi	r24, 0x29	; 41
    384e:	2f a5       	ldd	r18, Y+47	; 0x2f
    3850:	38 a9       	ldd	r19, Y+48	; 0x30
    3852:	82 9f       	mul	r24, r18
    3854:	f0 01       	movw	r30, r0
    3856:	83 9f       	mul	r24, r19
    3858:	f0 0d       	add	r31, r0
    385a:	11 24       	eor	r1, r1
    385c:	ea 5d       	subi	r30, 0xDA	; 218
    385e:	fe 4f       	sbci	r31, 0xFE	; 254
    3860:	c5 a2       	std	Z+37, r12	; 0x25
    3862:	d6 a2       	std	Z+38, r13	; 0x26
    3864:	e7 a2       	std	Z+39, r14	; 0x27
    3866:	f0 a6       	std	Z+40, r15	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    3868:	85 85       	ldd	r24, Z+13	; 0x0d
    386a:	96 85       	ldd	r25, Z+14	; 0x0e
    386c:	a7 85       	ldd	r26, Z+15	; 0x0f
    386e:	b0 89       	ldd	r27, Z+16	; 0x10
    3870:	89 2b       	or	r24, r25
    3872:	8a 2b       	or	r24, r26
    3874:	8b 2b       	or	r24, r27
    3876:	09 f4       	brne	.+2      	; 0x387a <plan_buffer_line+0x21e>
    3878:	47 c2       	rjmp	.+1166   	; 0x3d08 <plan_buffer_line+0x6ac>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    387a:	20 e0       	ldi	r18, 0x00	; 0
    387c:	30 e0       	ldi	r19, 0x00	; 0
    387e:	a9 01       	movw	r20, r18
    3880:	6b a5       	ldd	r22, Y+43	; 0x2b
    3882:	7c a5       	ldd	r23, Y+44	; 0x2c
    3884:	8d a5       	ldd	r24, Y+45	; 0x2d
    3886:	9e a5       	ldd	r25, Y+46	; 0x2e
    3888:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    388c:	88 23       	and	r24, r24
    388e:	0c f1       	brlt	.+66     	; 0x38d2 <plan_buffer_line+0x276>
  else if (invert_feed_rate) { feed_rate *= block->millimeters; }
    3890:	00 23       	and	r16, r16
    3892:	61 f0       	breq	.+24     	; 0x38ac <plan_buffer_line+0x250>
    3894:	a7 01       	movw	r20, r14
    3896:	96 01       	movw	r18, r12
    3898:	6b a5       	ldd	r22, Y+43	; 0x2b
    389a:	7c a5       	ldd	r23, Y+44	; 0x2c
    389c:	8d a5       	ldd	r24, Y+45	; 0x2d
    389e:	9e a5       	ldd	r25, Y+46	; 0x2e
    38a0:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    38a4:	6b a7       	std	Y+43, r22	; 0x2b
    38a6:	7c a7       	std	Y+44, r23	; 0x2c
    38a8:	8d a7       	std	Y+45, r24	; 0x2d
    38aa:	9e a7       	std	Y+46, r25	; 0x2e
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    38ac:	20 e0       	ldi	r18, 0x00	; 0
    38ae:	30 e0       	ldi	r19, 0x00	; 0
    38b0:	40 e8       	ldi	r20, 0x80	; 128
    38b2:	5f e3       	ldi	r21, 0x3F	; 63
    38b4:	6b a5       	ldd	r22, Y+43	; 0x2b
    38b6:	7c a5       	ldd	r23, Y+44	; 0x2c
    38b8:	8d a5       	ldd	r24, Y+45	; 0x2d
    38ba:	9e a5       	ldd	r25, Y+46	; 0x2e
    38bc:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    38c0:	88 23       	and	r24, r24
    38c2:	7c f4       	brge	.+30     	; 0x38e2 <plan_buffer_line+0x286>
    38c4:	1b a6       	std	Y+43, r1	; 0x2b
    38c6:	1c a6       	std	Y+44, r1	; 0x2c
    38c8:	30 e8       	ldi	r19, 0x80	; 128
    38ca:	3d a7       	std	Y+45, r19	; 0x2d
    38cc:	4f e3       	ldi	r20, 0x3F	; 63
    38ce:	4e a7       	std	Y+46, r20	; 0x2e
    38d0:	08 c0       	rjmp	.+16     	; 0x38e2 <plan_buffer_line+0x286>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    38d2:	59 e9       	ldi	r21, 0x99	; 153
    38d4:	5b a7       	std	Y+43, r21	; 0x2b
    38d6:	86 e7       	ldi	r24, 0x76	; 118
    38d8:	8c a7       	std	Y+44, r24	; 0x2c
    38da:	96 e9       	ldi	r25, 0x96	; 150
    38dc:	9d a7       	std	Y+45, r25	; 0x2d
    38de:	ae e7       	ldi	r26, 0x7E	; 126
    38e0:	ae a7       	std	Y+46, r26	; 0x2e
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    38e2:	a7 01       	movw	r20, r14
    38e4:	96 01       	movw	r18, r12
    38e6:	60 e0       	ldi	r22, 0x00	; 0
    38e8:	70 e0       	ldi	r23, 0x00	; 0
    38ea:	80 e8       	ldi	r24, 0x80	; 128
    38ec:	9f e3       	ldi	r25, 0x3F	; 63
    38ee:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    38f2:	6d ab       	std	Y+53, r22	; 0x35
    38f4:	7e ab       	std	Y+54, r23	; 0x36
    38f6:	8f ab       	std	Y+55, r24	; 0x37
    38f8:	98 af       	std	Y+56, r25	; 0x38
    38fa:	2e 01       	movw	r4, r28
    38fc:	b9 e1       	ldi	r27, 0x19	; 25
    38fe:	4b 0e       	add	r4, r27
    3900:	51 1c       	adc	r5, r1
  float junction_cos_theta = 0;
    3902:	1b a2       	std	Y+35, r1	; 0x23
    3904:	1c a2       	std	Y+36, r1	; 0x24
    3906:	1d a2       	std	Y+37, r1	; 0x25
    3908:	1e a2       	std	Y+38, r1	; 0x26
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    390a:	29 e2       	ldi	r18, 0x29	; 41
    390c:	ef a5       	ldd	r30, Y+47	; 0x2f
    390e:	f8 a9       	ldd	r31, Y+48	; 0x30
    3910:	2e 9f       	mul	r18, r30
    3912:	c0 01       	movw	r24, r0
    3914:	2f 9f       	mul	r18, r31
    3916:	90 0d       	add	r25, r0
    3918:	11 24       	eor	r1, r1
    391a:	9c 01       	movw	r18, r24
    391c:	29 5b       	subi	r18, 0xB9	; 185
    391e:	3e 4f       	sbci	r19, 0xFE	; 254
    3920:	19 01       	movw	r2, r18
    3922:	69 a8       	ldd	r6, Y+49	; 0x31
    3924:	7a a8       	ldd	r7, Y+50	; 0x32
    3926:	0b a9       	ldd	r16, Y+51	; 0x33
    3928:	1c a9       	ldd	r17, Y+52	; 0x34
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    392a:	d4 01       	movw	r26, r8
    392c:	cd 90       	ld	r12, X+
    392e:	dd 90       	ld	r13, X+
    3930:	ed 90       	ld	r14, X+
    3932:	fc 90       	ld	r15, X
    3934:	20 e0       	ldi	r18, 0x00	; 0
    3936:	30 e0       	ldi	r19, 0x00	; 0
    3938:	a9 01       	movw	r20, r18
    393a:	c7 01       	movw	r24, r14
    393c:	b6 01       	movw	r22, r12
    393e:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3942:	88 23       	and	r24, r24
    3944:	09 f4       	brne	.+2      	; 0x3948 <plan_buffer_line+0x2ec>
    3946:	8d c0       	rjmp	.+282    	; 0x3a62 <plan_buffer_line+0x406>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    3948:	a7 01       	movw	r20, r14
    394a:	96 01       	movw	r18, r12
    394c:	6d a9       	ldd	r22, Y+53	; 0x35
    394e:	7e a9       	ldd	r23, Y+54	; 0x36
    3950:	8f a9       	ldd	r24, Y+55	; 0x37
    3952:	98 ad       	ldd	r25, Y+56	; 0x38
    3954:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3958:	6b 01       	movw	r12, r22
    395a:	7c 01       	movw	r14, r24
    395c:	f4 01       	movw	r30, r8
    395e:	60 83       	st	Z, r22
    3960:	71 83       	std	Z+1, r23	; 0x01
    3962:	82 83       	std	Z+2, r24	; 0x02
    3964:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    3966:	9b 01       	movw	r18, r22
    3968:	ac 01       	movw	r20, r24
    396a:	60 e0       	ldi	r22, 0x00	; 0
    396c:	70 e0       	ldi	r23, 0x00	; 0
    396e:	80 e8       	ldi	r24, 0x80	; 128
    3970:	9f e3       	ldi	r25, 0x3F	; 63
    3972:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    3976:	9b 01       	movw	r18, r22
    3978:	ac 01       	movw	r20, r24
    397a:	5f 77       	andi	r21, 0x7F	; 127
    397c:	2d 8f       	std	Y+29, r18	; 0x1d
    397e:	3e 8f       	std	Y+30, r19	; 0x1e
    3980:	4f 8f       	std	Y+31, r20	; 0x1f
    3982:	58 a3       	std	Y+32, r21	; 0x20
    3984:	7a a2       	std	Y+34, r7	; 0x22
    3986:	69 a2       	std	Y+33, r6	; 0x21

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    3988:	d3 01       	movw	r26, r6
    398a:	1c 96       	adiw	r26, 0x0c	; 12
    398c:	2d 91       	ld	r18, X+
    398e:	3d 91       	ld	r19, X+
    3990:	4d 91       	ld	r20, X+
    3992:	5c 91       	ld	r21, X
    3994:	1f 97       	sbiw	r26, 0x0f	; 15
    3996:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3998:	7e 8d       	ldd	r23, Y+30	; 0x1e
    399a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    399c:	98 a1       	ldd	r25, Y+32	; 0x20
    399e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    39a2:	69 8f       	std	Y+25, r22	; 0x19
    39a4:	7b 8f       	std	Y+27, r23	; 0x1b
    39a6:	b8 2e       	mov	r11, r24
    39a8:	a9 2e       	mov	r10, r25
    39aa:	2b a5       	ldd	r18, Y+43	; 0x2b
    39ac:	3c a5       	ldd	r19, Y+44	; 0x2c
    39ae:	4d a5       	ldd	r20, Y+45	; 0x2d
    39b0:	5e a5       	ldd	r21, Y+46	; 0x2e
    39b2:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    39b6:	18 16       	cp	r1, r24
    39b8:	34 f0       	brlt	.+12     	; 0x39c6 <plan_buffer_line+0x36a>
    39ba:	b9 8d       	ldd	r27, Y+25	; 0x19
    39bc:	bb a7       	std	Y+43, r27	; 0x2b
    39be:	eb 8d       	ldd	r30, Y+27	; 0x1b
    39c0:	ec a7       	std	Y+44, r30	; 0x2c
    39c2:	bd a6       	std	Y+45, r11	; 0x2d
    39c4:	ae a6       	std	Y+46, r10	; 0x2e
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    39c6:	d1 01       	movw	r26, r2
    39c8:	bc 91       	ld	r27, X
    39ca:	b9 8f       	std	Y+25, r27	; 0x19
    39cc:	f1 01       	movw	r30, r2
    39ce:	f1 81       	ldd	r31, Z+1	; 0x01
    39d0:	fb 8f       	std	Y+27, r31	; 0x1b
    39d2:	d1 01       	movw	r26, r2
    39d4:	12 96       	adiw	r26, 0x02	; 2
    39d6:	ac 90       	ld	r10, X
    39d8:	12 97       	sbiw	r26, 0x02	; 2
    39da:	13 96       	adiw	r26, 0x03	; 3
    39dc:	bc 90       	ld	r11, X
    39de:	e9 a1       	ldd	r30, Y+33	; 0x21
    39e0:	fa a1       	ldd	r31, Y+34	; 0x22
    39e2:	20 8d       	ldd	r18, Z+24	; 0x18
    39e4:	31 8d       	ldd	r19, Z+25	; 0x19
    39e6:	42 8d       	ldd	r20, Z+26	; 0x1a
    39e8:	53 8d       	ldd	r21, Z+27	; 0x1b
    39ea:	6d 8d       	ldd	r22, Y+29	; 0x1d
    39ec:	7e 8d       	ldd	r23, Y+30	; 0x1e
    39ee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    39f0:	98 a1       	ldd	r25, Y+32	; 0x20
    39f2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    39f6:	6d 8f       	std	Y+29, r22	; 0x1d
    39f8:	79 a3       	std	Y+33, r23	; 0x21
    39fa:	8f a3       	std	Y+39, r24	; 0x27
    39fc:	99 a7       	std	Y+41, r25	; 0x29
    39fe:	26 2f       	mov	r18, r22
    3a00:	37 2f       	mov	r19, r23
    3a02:	48 2f       	mov	r20, r24
    3a04:	59 2f       	mov	r21, r25
    3a06:	69 8d       	ldd	r22, Y+25	; 0x19
    3a08:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3a0a:	8a 2d       	mov	r24, r10
    3a0c:	9b 2d       	mov	r25, r11
    3a0e:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3a12:	88 23       	and	r24, r24
    3a14:	34 f0       	brlt	.+12     	; 0x3a22 <plan_buffer_line+0x3c6>
    3a16:	fd 8d       	ldd	r31, Y+29	; 0x1d
    3a18:	f9 8f       	std	Y+25, r31	; 0x19
    3a1a:	29 a1       	ldd	r18, Y+33	; 0x21
    3a1c:	2b 8f       	std	Y+27, r18	; 0x1b
    3a1e:	af a0       	ldd	r10, Y+39	; 0x27
    3a20:	b9 a4       	ldd	r11, Y+41	; 0x29
    3a22:	89 8d       	ldd	r24, Y+25	; 0x19
    3a24:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a26:	aa 2d       	mov	r26, r10
    3a28:	bb 2d       	mov	r27, r11
    3a2a:	f1 01       	movw	r30, r2
    3a2c:	80 83       	st	Z, r24
    3a2e:	91 83       	std	Z+1, r25	; 0x01
    3a30:	a2 83       	std	Z+2, r26	; 0x02
    3a32:	b3 83       	std	Z+3, r27	; 0x03

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    3a34:	d8 01       	movw	r26, r16
    3a36:	1c 96       	adiw	r26, 0x0c	; 12
    3a38:	2d 91       	ld	r18, X+
    3a3a:	3d 91       	ld	r19, X+
    3a3c:	4d 91       	ld	r20, X+
    3a3e:	5c 91       	ld	r21, X
    3a40:	1f 97       	sbiw	r26, 0x0f	; 15
    3a42:	c7 01       	movw	r24, r14
    3a44:	b6 01       	movw	r22, r12
    3a46:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3a4a:	9b 01       	movw	r18, r22
    3a4c:	ac 01       	movw	r20, r24
    3a4e:	6b a1       	ldd	r22, Y+35	; 0x23
    3a50:	7c a1       	ldd	r23, Y+36	; 0x24
    3a52:	8d a1       	ldd	r24, Y+37	; 0x25
    3a54:	9e a1       	ldd	r25, Y+38	; 0x26
    3a56:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    3a5a:	6b a3       	std	Y+35, r22	; 0x23
    3a5c:	7c a3       	std	Y+36, r23	; 0x24
    3a5e:	8d a3       	std	Y+37, r24	; 0x25
    3a60:	9e a3       	std	Y+38, r25	; 0x26
    3a62:	b4 e0       	ldi	r27, 0x04	; 4
    3a64:	8b 0e       	add	r8, r27
    3a66:	91 1c       	adc	r9, r1
    3a68:	0c 5f       	subi	r16, 0xFC	; 252
    3a6a:	1f 4f       	sbci	r17, 0xFF	; 255
    3a6c:	e4 e0       	ldi	r30, 0x04	; 4
    3a6e:	6e 0e       	add	r6, r30
    3a70:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3a72:	84 14       	cp	r8, r4
    3a74:	95 04       	cpc	r9, r5
    3a76:	09 f0       	breq	.+2      	; 0x3a7a <plan_buffer_line+0x41e>
    3a78:	58 cf       	rjmp	.-336    	; 0x392a <plan_buffer_line+0x2ce>
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    3a7a:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <block_buffer_head>
    3a7e:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    3a82:	98 13       	cpse	r25, r24
    3a84:	13 c0       	rjmp	.+38     	; 0x3aac <plan_buffer_line+0x450>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    3a86:	89 e2       	ldi	r24, 0x29	; 41
    3a88:	2f a5       	ldd	r18, Y+47	; 0x2f
    3a8a:	38 a9       	ldd	r19, Y+48	; 0x30
    3a8c:	82 9f       	mul	r24, r18
    3a8e:	f0 01       	movw	r30, r0
    3a90:	83 9f       	mul	r24, r19
    3a92:	f0 0d       	add	r31, r0
    3a94:	11 24       	eor	r1, r1
    3a96:	ea 5d       	subi	r30, 0xDA	; 218
    3a98:	fe 4f       	sbci	r31, 0xFE	; 254
    3a9a:	11 8a       	std	Z+17, r1	; 0x11
    3a9c:	12 8a       	std	Z+18, r1	; 0x12
    3a9e:	13 8a       	std	Z+19, r1	; 0x13
    3aa0:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    3aa2:	11 8e       	std	Z+25, r1	; 0x19
    3aa4:	12 8e       	std	Z+26, r1	; 0x1a
    3aa6:	13 8e       	std	Z+27, r1	; 0x1b
    3aa8:	14 8e       	std	Z+28, r1	; 0x1c
    3aaa:	90 c0       	rjmp	.+288    	; 0x3bcc <plan_buffer_line+0x570>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999) {
    3aac:	2f ee       	ldi	r18, 0xEF	; 239
    3aae:	3f ef       	ldi	r19, 0xFF	; 255
    3ab0:	4f e7       	ldi	r20, 0x7F	; 127
    3ab2:	5f e3       	ldi	r21, 0x3F	; 63
    3ab4:	6b a1       	ldd	r22, Y+35	; 0x23
    3ab6:	7c a1       	ldd	r23, Y+36	; 0x24
    3ab8:	8d a1       	ldd	r24, Y+37	; 0x25
    3aba:	9e a1       	ldd	r25, Y+38	; 0x26
    3abc:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    3ac0:	18 16       	cp	r1, r24
    3ac2:	7c f4       	brge	.+30     	; 0x3ae2 <plan_buffer_line+0x486>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    3ac4:	89 e2       	ldi	r24, 0x29	; 41
    3ac6:	4f a5       	ldd	r20, Y+47	; 0x2f
    3ac8:	58 a9       	ldd	r21, Y+48	; 0x30
    3aca:	84 9f       	mul	r24, r20
    3acc:	f0 01       	movw	r30, r0
    3ace:	85 9f       	mul	r24, r21
    3ad0:	f0 0d       	add	r31, r0
    3ad2:	11 24       	eor	r1, r1
    3ad4:	ea 5d       	subi	r30, 0xDA	; 218
    3ad6:	fe 4f       	sbci	r31, 0xFE	; 254
    3ad8:	11 8e       	std	Z+25, r1	; 0x19
    3ada:	12 8e       	std	Z+26, r1	; 0x1a
    3adc:	13 8e       	std	Z+27, r1	; 0x1b
    3ade:	14 8e       	std	Z+28, r1	; 0x1c
    3ae0:	75 c0       	rjmp	.+234    	; 0x3bcc <plan_buffer_line+0x570>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.999999); // Check for numerical round-off to avoid divide by zero.
    3ae2:	2f ee       	ldi	r18, 0xEF	; 239
    3ae4:	3f ef       	ldi	r19, 0xFF	; 255
    3ae6:	4f e7       	ldi	r20, 0x7F	; 127
    3ae8:	5f eb       	ldi	r21, 0xBF	; 191
    3aea:	6b a1       	ldd	r22, Y+35	; 0x23
    3aec:	7c a1       	ldd	r23, Y+36	; 0x24
    3aee:	8d a1       	ldd	r24, Y+37	; 0x25
    3af0:	9e a1       	ldd	r25, Y+38	; 0x26
    3af2:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    3af6:	18 16       	cp	r1, r24
    3af8:	44 f0       	brlt	.+16     	; 0x3b0a <plan_buffer_line+0x4ae>
    3afa:	8f ee       	ldi	r24, 0xEF	; 239
    3afc:	9f ef       	ldi	r25, 0xFF	; 255
    3afe:	af e7       	ldi	r26, 0x7F	; 127
    3b00:	bf eb       	ldi	r27, 0xBF	; 191
    3b02:	8b a3       	std	Y+35, r24	; 0x23
    3b04:	9c a3       	std	Y+36, r25	; 0x24
    3b06:	ad a3       	std	Y+37, r26	; 0x25
    3b08:	be a3       	std	Y+38, r27	; 0x26
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    3b0a:	2b a1       	ldd	r18, Y+35	; 0x23
    3b0c:	3c a1       	ldd	r19, Y+36	; 0x24
    3b0e:	4d a1       	ldd	r20, Y+37	; 0x25
    3b10:	5e a1       	ldd	r21, Y+38	; 0x26
    3b12:	60 e0       	ldi	r22, 0x00	; 0
    3b14:	70 e0       	ldi	r23, 0x00	; 0
    3b16:	80 e8       	ldi	r24, 0x80	; 128
    3b18:	9f e3       	ldi	r25, 0x3F	; 63
    3b1a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    3b1e:	20 e0       	ldi	r18, 0x00	; 0
    3b20:	30 e0       	ldi	r19, 0x00	; 0
    3b22:	40 e0       	ldi	r20, 0x00	; 0
    3b24:	5f e3       	ldi	r21, 0x3F	; 63
    3b26:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3b2a:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    3b2e:	6b 01       	movw	r12, r22
    3b30:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    3b32:	89 e2       	ldi	r24, 0x29	; 41
    3b34:	af a5       	ldd	r26, Y+47	; 0x2f
    3b36:	b8 a9       	ldd	r27, Y+48	; 0x30
    3b38:	8a 9f       	mul	r24, r26
    3b3a:	f0 01       	movw	r30, r0
    3b3c:	8b 9f       	mul	r24, r27
    3b3e:	f0 0d       	add	r31, r0
    3b40:	11 24       	eor	r1, r1
    3b42:	ea 5d       	subi	r30, 0xDA	; 218
    3b44:	fe 4f       	sbci	r31, 0xFE	; 254
    3b46:	20 91 ba 06 	lds	r18, 0x06BA	; 0x8006ba <settings+0x35>
    3b4a:	30 91 bb 06 	lds	r19, 0x06BB	; 0x8006bb <settings+0x36>
    3b4e:	40 91 bc 06 	lds	r20, 0x06BC	; 0x8006bc <settings+0x37>
    3b52:	50 91 bd 06 	lds	r21, 0x06BD	; 0x8006bd <settings+0x38>
    3b56:	61 a1       	ldd	r22, Z+33	; 0x21
    3b58:	72 a1       	ldd	r23, Z+34	; 0x22
    3b5a:	83 a1       	ldd	r24, Z+35	; 0x23
    3b5c:	94 a1       	ldd	r25, Z+36	; 0x24
    3b5e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3b62:	a7 01       	movw	r20, r14
    3b64:	96 01       	movw	r18, r12
    3b66:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3b6a:	4b 01       	movw	r8, r22
    3b6c:	5c 01       	movw	r10, r24
    3b6e:	a7 01       	movw	r20, r14
    3b70:	96 01       	movw	r18, r12
    3b72:	60 e0       	ldi	r22, 0x00	; 0
    3b74:	70 e0       	ldi	r23, 0x00	; 0
    3b76:	80 e8       	ldi	r24, 0x80	; 128
    3b78:	9f e3       	ldi	r25, 0x3F	; 63
    3b7a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    3b7e:	9b 01       	movw	r18, r22
    3b80:	ac 01       	movw	r20, r24
    3b82:	c5 01       	movw	r24, r10
    3b84:	b4 01       	movw	r22, r8
    3b86:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    3b8a:	e6 2e       	mov	r14, r22
    3b8c:	f7 2e       	mov	r15, r23
    3b8e:	08 2f       	mov	r16, r24
    3b90:	19 2f       	mov	r17, r25
    3b92:	20 e0       	ldi	r18, 0x00	; 0
    3b94:	30 e0       	ldi	r19, 0x00	; 0
    3b96:	a9 01       	movw	r20, r18
    3b98:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3b9c:	88 23       	and	r24, r24
    3b9e:	24 f4       	brge	.+8      	; 0x3ba8 <plan_buffer_line+0x54c>
    3ba0:	e1 2c       	mov	r14, r1
    3ba2:	f1 2c       	mov	r15, r1
    3ba4:	00 e0       	ldi	r16, 0x00	; 0
    3ba6:	10 e0       	ldi	r17, 0x00	; 0
    3ba8:	89 e2       	ldi	r24, 0x29	; 41
    3baa:	2f a5       	ldd	r18, Y+47	; 0x2f
    3bac:	38 a9       	ldd	r19, Y+48	; 0x30
    3bae:	82 9f       	mul	r24, r18
    3bb0:	f0 01       	movw	r30, r0
    3bb2:	83 9f       	mul	r24, r19
    3bb4:	f0 0d       	add	r31, r0
    3bb6:	11 24       	eor	r1, r1
    3bb8:	ea 5d       	subi	r30, 0xDA	; 218
    3bba:	fe 4f       	sbci	r31, 0xFE	; 254
    3bbc:	4e 2d       	mov	r20, r14
    3bbe:	5f 2d       	mov	r21, r15
    3bc0:	60 2f       	mov	r22, r16
    3bc2:	71 2f       	mov	r23, r17
    3bc4:	41 8f       	std	Z+25, r20	; 0x19
    3bc6:	52 8f       	std	Z+26, r21	; 0x1a
    3bc8:	63 8f       	std	Z+27, r22	; 0x1b
    3bca:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    3bcc:	2b a5       	ldd	r18, Y+43	; 0x2b
    3bce:	3c a5       	ldd	r19, Y+44	; 0x2c
    3bd0:	4d a5       	ldd	r20, Y+45	; 0x2d
    3bd2:	5e a5       	ldd	r21, Y+46	; 0x2e
    3bd4:	6b a5       	ldd	r22, Y+43	; 0x2b
    3bd6:	7c a5       	ldd	r23, Y+44	; 0x2c
    3bd8:	8d a5       	ldd	r24, Y+45	; 0x2d
    3bda:	9e a5       	ldd	r25, Y+46	; 0x2e
    3bdc:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3be0:	f6 2e       	mov	r15, r22
    3be2:	07 2f       	mov	r16, r23
    3be4:	18 2f       	mov	r17, r24
    3be6:	e9 2e       	mov	r14, r25
    3be8:	89 e2       	ldi	r24, 0x29	; 41
    3bea:	4f a5       	ldd	r20, Y+47	; 0x2f
    3bec:	58 a9       	ldd	r21, Y+48	; 0x30
    3bee:	84 9f       	mul	r24, r20
    3bf0:	f0 01       	movw	r30, r0
    3bf2:	85 9f       	mul	r24, r21
    3bf4:	f0 0d       	add	r31, r0
    3bf6:	11 24       	eor	r1, r1
    3bf8:	ea 5d       	subi	r30, 0xDA	; 218
    3bfa:	fe 4f       	sbci	r31, 0xFE	; 254
    3bfc:	8f 2d       	mov	r24, r15
    3bfe:	90 2f       	mov	r25, r16
    3c00:	a1 2f       	mov	r26, r17
    3c02:	be 2d       	mov	r27, r14
    3c04:	85 8f       	std	Z+29, r24	; 0x1d
    3c06:	96 8f       	std	Z+30, r25	; 0x1e
    3c08:	a7 8f       	std	Z+31, r26	; 0x1f
    3c0a:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    3c0c:	d1 8c       	ldd	r13, Z+25	; 0x19
    3c0e:	c2 8c       	ldd	r12, Z+26	; 0x1a
    3c10:	b3 8c       	ldd	r11, Z+27	; 0x1b
    3c12:	a4 8c       	ldd	r10, Z+28	; 0x1c
    3c14:	90 90 1e 01 	lds	r9, 0x011E	; 0x80011e <__data_end+0x18>
    3c18:	80 90 1f 01 	lds	r8, 0x011F	; 0x80011f <__data_end+0x19>
    3c1c:	70 90 20 01 	lds	r7, 0x0120	; 0x800120 <__data_end+0x1a>
    3c20:	60 90 21 01 	lds	r6, 0x0121	; 0x800121 <__data_end+0x1b>
    3c24:	29 2d       	mov	r18, r9
    3c26:	38 2d       	mov	r19, r8
    3c28:	47 2d       	mov	r20, r7
    3c2a:	56 2d       	mov	r21, r6
    3c2c:	6f 2d       	mov	r22, r15
    3c2e:	70 2f       	mov	r23, r16
    3c30:	81 2f       	mov	r24, r17
    3c32:	9e 2d       	mov	r25, r14
    3c34:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3c38:	88 23       	and	r24, r24
    3c3a:	2c f0       	brlt	.+10     	; 0x3c46 <plan_buffer_line+0x5ea>
    3c3c:	b9 2d       	mov	r27, r9
    3c3e:	a8 2d       	mov	r26, r8
    3c40:	f7 2d       	mov	r31, r7
    3c42:	e6 2d       	mov	r30, r6
    3c44:	04 c0       	rjmp	.+8      	; 0x3c4e <plan_buffer_line+0x5f2>
    3c46:	bf 2d       	mov	r27, r15
    3c48:	a0 2f       	mov	r26, r16
    3c4a:	f1 2f       	mov	r31, r17
    3c4c:	ee 2d       	mov	r30, r14
    3c4e:	2d 2d       	mov	r18, r13
    3c50:	3c 2d       	mov	r19, r12
    3c52:	4b 2d       	mov	r20, r11
    3c54:	5a 2d       	mov	r21, r10
    3c56:	6b 2f       	mov	r22, r27
    3c58:	7a 2f       	mov	r23, r26
    3c5a:	8f 2f       	mov	r24, r31
    3c5c:	9e 2f       	mov	r25, r30
    3c5e:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    3c62:	18 16       	cp	r1, r24
    3c64:	ac f0       	brlt	.+42     	; 0x3c90 <plan_buffer_line+0x634>
    3c66:	29 2d       	mov	r18, r9
    3c68:	38 2d       	mov	r19, r8
    3c6a:	47 2d       	mov	r20, r7
    3c6c:	56 2d       	mov	r21, r6
    3c6e:	6f 2d       	mov	r22, r15
    3c70:	70 2f       	mov	r23, r16
    3c72:	81 2f       	mov	r24, r17
    3c74:	9e 2d       	mov	r25, r14
    3c76:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3c7a:	88 23       	and	r24, r24
    3c7c:	2c f0       	brlt	.+10     	; 0x3c88 <plan_buffer_line+0x62c>
    3c7e:	d9 2c       	mov	r13, r9
    3c80:	c8 2c       	mov	r12, r8
    3c82:	b7 2c       	mov	r11, r7
    3c84:	a6 2c       	mov	r10, r6
    3c86:	04 c0       	rjmp	.+8      	; 0x3c90 <plan_buffer_line+0x634>
    3c88:	df 2c       	mov	r13, r15
    3c8a:	c0 2e       	mov	r12, r16
    3c8c:	b1 2e       	mov	r11, r17
    3c8e:	ae 2c       	mov	r10, r14
    3c90:	89 e2       	ldi	r24, 0x29	; 41
    3c92:	af a5       	ldd	r26, Y+47	; 0x2f
    3c94:	b8 a9       	ldd	r27, Y+48	; 0x30
    3c96:	8a 9f       	mul	r24, r26
    3c98:	f0 01       	movw	r30, r0
    3c9a:	8b 9f       	mul	r24, r27
    3c9c:	f0 0d       	add	r31, r0
    3c9e:	11 24       	eor	r1, r1
    3ca0:	ea 5d       	subi	r30, 0xDA	; 218
    3ca2:	fe 4f       	sbci	r31, 0xFE	; 254
    3ca4:	8d 2d       	mov	r24, r13
    3ca6:	9c 2d       	mov	r25, r12
    3ca8:	ab 2d       	mov	r26, r11
    3caa:	ba 2d       	mov	r27, r10
    3cac:	85 8b       	std	Z+21, r24	; 0x15
    3cae:	96 8b       	std	Z+22, r25	; 0x16
    3cb0:	a7 8b       	std	Z+23, r26	; 0x17
    3cb2:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    3cb4:	8c e0       	ldi	r24, 0x0C	; 12
    3cb6:	fe 01       	movw	r30, r28
    3cb8:	3d 96       	adiw	r30, 0x0d	; 13
    3cba:	a2 e1       	ldi	r26, 0x12	; 18
    3cbc:	b1 e0       	ldi	r27, 0x01	; 1
    3cbe:	01 90       	ld	r0, Z+
    3cc0:	0d 92       	st	X+, r0
    3cc2:	8a 95       	dec	r24
    3cc4:	e1 f7       	brne	.-8      	; 0x3cbe <plan_buffer_line+0x662>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    3cc6:	8f 2d       	mov	r24, r15
    3cc8:	90 2f       	mov	r25, r16
    3cca:	a1 2f       	mov	r26, r17
    3ccc:	be 2d       	mov	r27, r14
    3cce:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end+0x18>
    3cd2:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <__data_end+0x19>
    3cd6:	a0 93 20 01 	sts	0x0120, r26	; 0x800120 <__data_end+0x1a>
    3cda:	b0 93 21 01 	sts	0x0121, r27	; 0x800121 <__data_end+0x1b>
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    3cde:	8c e0       	ldi	r24, 0x0C	; 12
    3ce0:	fe 01       	movw	r30, r28
    3ce2:	31 96       	adiw	r30, 0x01	; 1
    3ce4:	a6 e0       	ldi	r26, 0x06	; 6
    3ce6:	b1 e0       	ldi	r27, 0x01	; 1
    3ce8:	01 90       	ld	r0, Z+
    3cea:	0d 92       	st	X+, r0
    3cec:	8a 95       	dec	r24
    3cee:	e1 f7       	brne	.-8      	; 0x3ce8 <plan_buffer_line+0x68c>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    3cf0:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <next_buffer_head>
    3cf4:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <block_buffer_head>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    3cf8:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    3cfa:	82 31       	cpi	r24, 0x12	; 18
    3cfc:	09 f4       	brne	.+2      	; 0x3d00 <plan_buffer_line+0x6a4>
    3cfe:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    3d00:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <next_buffer_head>
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    3d04:	0e 94 70 19 	call	0x32e0	; 0x32e0 <planner_recalculate>
}
    3d08:	e8 96       	adiw	r28, 0x38	; 56
    3d0a:	0f b6       	in	r0, 0x3f	; 63
    3d0c:	f8 94       	cli
    3d0e:	de bf       	out	0x3e, r29	; 62
    3d10:	0f be       	out	0x3f, r0	; 63
    3d12:	cd bf       	out	0x3d, r28	; 61
    3d14:	df 91       	pop	r29
    3d16:	cf 91       	pop	r28
    3d18:	1f 91       	pop	r17
    3d1a:	0f 91       	pop	r16
    3d1c:	ff 90       	pop	r15
    3d1e:	ef 90       	pop	r14
    3d20:	df 90       	pop	r13
    3d22:	cf 90       	pop	r12
    3d24:	bf 90       	pop	r11
    3d26:	af 90       	pop	r10
    3d28:	9f 90       	pop	r9
    3d2a:	8f 90       	pop	r8
    3d2c:	7f 90       	pop	r7
    3d2e:	6f 90       	pop	r6
    3d30:	5f 90       	pop	r5
    3d32:	4f 90       	pop	r4
    3d34:	3f 90       	pop	r3
    3d36:	2f 90       	pop	r2
    3d38:	08 95       	ret

00003d3a <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
    3d3a:	aa ea       	ldi	r26, 0xAA	; 170
    3d3c:	b5 e0       	ldi	r27, 0x05	; 5
    3d3e:	e6 e0       	ldi	r30, 0x06	; 6
    3d40:	f1 e0       	ldi	r31, 0x01	; 1
    3d42:	82 e1       	ldi	r24, 0x12	; 18
    3d44:	91 e0       	ldi	r25, 0x01	; 1
        pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys.position);
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    3d46:	4d 91       	ld	r20, X+
    3d48:	5d 91       	ld	r21, X+
    3d4a:	6d 91       	ld	r22, X+
    3d4c:	7d 91       	ld	r23, X+
    3d4e:	41 93       	st	Z+, r20
    3d50:	51 93       	st	Z+, r21
    3d52:	61 93       	st	Z+, r22
    3d54:	71 93       	st	Z+, r23
void plan_sync_position()
{
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference. 
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    3d56:	e8 17       	cp	r30, r24
    3d58:	f9 07       	cpc	r31, r25
    3d5a:	a9 f7       	brne	.-22     	; 0x3d46 <plan_sync_position+0xc>
      }
    #else
      pl.position[idx] = sys.position[idx];
    #endif
  }
}
    3d5c:	08 95       	ret

00003d5e <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    3d5e:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <block_buffer_head>
    3d62:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <block_buffer_tail>
    3d66:	89 17       	cp	r24, r25
    3d68:	10 f0       	brcs	.+4      	; 0x3d6e <plan_get_block_buffer_count+0x10>
    3d6a:	89 1b       	sub	r24, r25
    3d6c:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    3d6e:	8e 5e       	subi	r24, 0xEE	; 238
    3d70:	89 1b       	sub	r24, r25
}
    3d72:	08 95       	ret

00003d74 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    3d74:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    3d78:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <block_buffer_tail>
    3d7c:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <block_buffer_planned>
  planner_recalculate();  
    3d80:	0e 94 70 19 	call	0x32e0	; 0x32e0 <planner_recalculate>
    3d84:	08 95       	ret

00003d86 <printString>:
    serial_write('-');
    print_uint32_base10(-n);
  } else {
    print_uint32_base10(n);
  }
}
    3d86:	cf 93       	push	r28
    3d88:	df 93       	push	r29
    3d8a:	ec 01       	movw	r28, r24
    3d8c:	88 81       	ld	r24, Y
    3d8e:	88 23       	and	r24, r24
    3d90:	31 f0       	breq	.+12     	; 0x3d9e <printString+0x18>
    3d92:	21 96       	adiw	r28, 0x01	; 1
    3d94:	0e 94 29 28 	call	0x5052	; 0x5052 <serial_write>
    3d98:	89 91       	ld	r24, Y+
    3d9a:	81 11       	cpse	r24, r1
    3d9c:	fb cf       	rjmp	.-10     	; 0x3d94 <printString+0xe>
    3d9e:	df 91       	pop	r29
    3da0:	cf 91       	pop	r28
    3da2:	08 95       	ret

00003da4 <printPgmString>:
    3da4:	cf 93       	push	r28
    3da6:	df 93       	push	r29
    3da8:	ec 01       	movw	r28, r24
    3daa:	21 96       	adiw	r28, 0x01	; 1
    3dac:	fc 01       	movw	r30, r24
    3dae:	84 91       	lpm	r24, Z
    3db0:	88 23       	and	r24, r24
    3db2:	39 f0       	breq	.+14     	; 0x3dc2 <printPgmString+0x1e>
    3db4:	0e 94 29 28 	call	0x5052	; 0x5052 <serial_write>
    3db8:	fe 01       	movw	r30, r28
    3dba:	84 91       	lpm	r24, Z
    3dbc:	21 96       	adiw	r28, 0x01	; 1
    3dbe:	81 11       	cpse	r24, r1
    3dc0:	f9 cf       	rjmp	.-14     	; 0x3db4 <printPgmString+0x10>
    3dc2:	df 91       	pop	r29
    3dc4:	cf 91       	pop	r28
    3dc6:	08 95       	ret

00003dc8 <print_unsigned_int8>:
    3dc8:	cf 92       	push	r12
    3dca:	df 92       	push	r13
    3dcc:	ef 92       	push	r14
    3dce:	ff 92       	push	r15
    3dd0:	1f 93       	push	r17
    3dd2:	cf 93       	push	r28
    3dd4:	df 93       	push	r29
    3dd6:	cd b7       	in	r28, 0x3d	; 61
    3dd8:	de b7       	in	r29, 0x3e	; 62
    3dda:	56 2f       	mov	r21, r22
    3ddc:	14 2f       	mov	r17, r20
    3dde:	cd b6       	in	r12, 0x3d	; 61
    3de0:	de b6       	in	r13, 0x3e	; 62
    3de2:	2d b7       	in	r18, 0x3d	; 61
    3de4:	3e b7       	in	r19, 0x3e	; 62
    3de6:	24 1b       	sub	r18, r20
    3de8:	31 09       	sbc	r19, r1
    3dea:	0f b6       	in	r0, 0x3f	; 63
    3dec:	f8 94       	cli
    3dee:	3e bf       	out	0x3e, r19	; 62
    3df0:	0f be       	out	0x3f, r0	; 63
    3df2:	2d bf       	out	0x3d, r18	; 61
    3df4:	6d b7       	in	r22, 0x3d	; 61
    3df6:	7e b7       	in	r23, 0x3e	; 62
    3df8:	6f 5f       	subi	r22, 0xFF	; 255
    3dfa:	7f 4f       	sbci	r23, 0xFF	; 255
    3dfc:	7b 01       	movw	r14, r22
    3dfe:	44 23       	and	r20, r20
    3e00:	d1 f0       	breq	.+52     	; 0x3e36 <print_unsigned_int8+0x6e>
    3e02:	fb 01       	movw	r30, r22
    3e04:	9f ef       	ldi	r25, 0xFF	; 255
    3e06:	94 0f       	add	r25, r20
    3e08:	29 2f       	mov	r18, r25
    3e0a:	30 e0       	ldi	r19, 0x00	; 0
    3e0c:	2f 5f       	subi	r18, 0xFF	; 255
    3e0e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e10:	26 0f       	add	r18, r22
    3e12:	37 1f       	adc	r19, r23
    3e14:	65 2f       	mov	r22, r21
    3e16:	0e 94 2d 3d 	call	0x7a5a	; 0x7a5a <__udivmodqi4>
    3e1a:	91 93       	st	Z+, r25
    3e1c:	2e 17       	cp	r18, r30
    3e1e:	3f 07       	cpc	r19, r31
    3e20:	c9 f7       	brne	.-14     	; 0x3e14 <print_unsigned_int8+0x4c>
    3e22:	f7 01       	movw	r30, r14
    3e24:	e1 0f       	add	r30, r17
    3e26:	f1 1d       	adc	r31, r1
    3e28:	31 97       	sbiw	r30, 0x01	; 1
    3e2a:	80 81       	ld	r24, Z
    3e2c:	80 5d       	subi	r24, 0xD0	; 208
    3e2e:	0e 94 29 28 	call	0x5052	; 0x5052 <serial_write>
    3e32:	11 50       	subi	r17, 0x01	; 1
    3e34:	b1 f7       	brne	.-20     	; 0x3e22 <print_unsigned_int8+0x5a>
    3e36:	0f b6       	in	r0, 0x3f	; 63
    3e38:	f8 94       	cli
    3e3a:	de be       	out	0x3e, r13	; 62
    3e3c:	0f be       	out	0x3f, r0	; 63
    3e3e:	cd be       	out	0x3d, r12	; 61
    3e40:	df 91       	pop	r29
    3e42:	cf 91       	pop	r28
    3e44:	1f 91       	pop	r17
    3e46:	ff 90       	pop	r15
    3e48:	ef 90       	pop	r14
    3e4a:	df 90       	pop	r13
    3e4c:	cf 90       	pop	r12
    3e4e:	08 95       	ret

00003e50 <print_uint8_base2>:
    3e50:	48 e0       	ldi	r20, 0x08	; 8
    3e52:	62 e0       	ldi	r22, 0x02	; 2
    3e54:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <print_unsigned_int8>
    3e58:	08 95       	ret

00003e5a <print_uint8_base10>:
    3e5a:	8a 30       	cpi	r24, 0x0A	; 10
    3e5c:	20 f0       	brcs	.+8      	; 0x3e66 <print_uint8_base10+0xc>
    3e5e:	84 36       	cpi	r24, 0x64	; 100
    3e60:	20 f0       	brcs	.+8      	; 0x3e6a <print_uint8_base10+0x10>
    3e62:	43 e0       	ldi	r20, 0x03	; 3
    3e64:	03 c0       	rjmp	.+6      	; 0x3e6c <print_uint8_base10+0x12>
    3e66:	41 e0       	ldi	r20, 0x01	; 1
    3e68:	01 c0       	rjmp	.+2      	; 0x3e6c <print_uint8_base10+0x12>
    3e6a:	42 e0       	ldi	r20, 0x02	; 2
    3e6c:	6a e0       	ldi	r22, 0x0A	; 10
    3e6e:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <print_unsigned_int8>
    3e72:	08 95       	ret

00003e74 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    3e74:	8f 92       	push	r8
    3e76:	9f 92       	push	r9
    3e78:	af 92       	push	r10
    3e7a:	bf 92       	push	r11
    3e7c:	cf 92       	push	r12
    3e7e:	df 92       	push	r13
    3e80:	ef 92       	push	r14
    3e82:	ff 92       	push	r15
    3e84:	0f 93       	push	r16
    3e86:	1f 93       	push	r17
    3e88:	cf 93       	push	r28
    3e8a:	df 93       	push	r29
    3e8c:	cd b7       	in	r28, 0x3d	; 61
    3e8e:	de b7       	in	r29, 0x3e	; 62
    3e90:	2a 97       	sbiw	r28, 0x0a	; 10
    3e92:	0f b6       	in	r0, 0x3f	; 63
    3e94:	f8 94       	cli
    3e96:	de bf       	out	0x3e, r29	; 62
    3e98:	0f be       	out	0x3f, r0	; 63
    3e9a:	cd bf       	out	0x3d, r28	; 61
    3e9c:	6b 01       	movw	r12, r22
    3e9e:	7c 01       	movw	r14, r24
    3ea0:	04 2f       	mov	r16, r20
  if (n < 0) {
    3ea2:	20 e0       	ldi	r18, 0x00	; 0
    3ea4:	30 e0       	ldi	r19, 0x00	; 0
    3ea6:	a9 01       	movw	r20, r18
    3ea8:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    3eac:	88 23       	and	r24, r24
    3eae:	3c f4       	brge	.+14     	; 0x3ebe <printFloat+0x4a>
    serial_write('-');
    3eb0:	8d e2       	ldi	r24, 0x2D	; 45
    3eb2:	0e 94 29 28 	call	0x5052	; 0x5052 <serial_write>
    n = -n;
    3eb6:	f7 fa       	bst	r15, 7
    3eb8:	f0 94       	com	r15
    3eba:	f7 f8       	bld	r15, 7
    3ebc:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3ebe:	02 30       	cpi	r16, 0x02	; 2
    3ec0:	88 f0       	brcs	.+34     	; 0x3ee4 <printFloat+0x70>
    3ec2:	10 2f       	mov	r17, r16
    n *= 100;
    3ec4:	20 e0       	ldi	r18, 0x00	; 0
    3ec6:	30 e0       	ldi	r19, 0x00	; 0
    3ec8:	48 ec       	ldi	r20, 0xC8	; 200
    3eca:	52 e4       	ldi	r21, 0x42	; 66
    3ecc:	c7 01       	movw	r24, r14
    3ece:	b6 01       	movw	r22, r12
    3ed0:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3ed4:	6b 01       	movw	r12, r22
    3ed6:	7c 01       	movw	r14, r24
    decimals -= 2;
    3ed8:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3eda:	12 30       	cpi	r17, 0x02	; 2
    3edc:	98 f7       	brcc	.-26     	; 0x3ec4 <printFloat+0x50>
    3ede:	80 2f       	mov	r24, r16
    3ee0:	81 70       	andi	r24, 0x01	; 1
    3ee2:	01 c0       	rjmp	.+2      	; 0x3ee6 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    3ee4:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    3ee6:	88 23       	and	r24, r24
    3ee8:	51 f0       	breq	.+20     	; 0x3efe <printFloat+0x8a>
    3eea:	20 e0       	ldi	r18, 0x00	; 0
    3eec:	30 e0       	ldi	r19, 0x00	; 0
    3eee:	40 e2       	ldi	r20, 0x20	; 32
    3ef0:	51 e4       	ldi	r21, 0x41	; 65
    3ef2:	c7 01       	movw	r24, r14
    3ef4:	b6 01       	movw	r22, r12
    3ef6:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3efa:	6b 01       	movw	r12, r22
    3efc:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    3efe:	20 e0       	ldi	r18, 0x00	; 0
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	40 e0       	ldi	r20, 0x00	; 0
    3f04:	5f e3       	ldi	r21, 0x3F	; 63
    3f06:	c7 01       	movw	r24, r14
    3f08:	b6 01       	movw	r22, r12
    3f0a:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    3f0e:	0e 94 3e 3a 	call	0x747c	; 0x747c <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    3f12:	2e e2       	ldi	r18, 0x2E	; 46
    3f14:	fe 01       	movw	r30, r28
    3f16:	e0 0f       	add	r30, r16
    3f18:	f1 1d       	adc	r31, r1
    3f1a:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    3f1c:	61 15       	cp	r22, r1
    3f1e:	71 05       	cpc	r23, r1
    3f20:	81 05       	cpc	r24, r1
    3f22:	91 05       	cpc	r25, r1
    3f24:	41 f1       	breq	.+80     	; 0x3f76 <printFloat+0x102>
    3f26:	10 e0       	ldi	r17, 0x00	; 0
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    3f28:	0f 2e       	mov	r0, r31
    3f2a:	fa e0       	ldi	r31, 0x0A	; 10
    3f2c:	8f 2e       	mov	r8, r31
    3f2e:	91 2c       	mov	r9, r1
    3f30:	a1 2c       	mov	r10, r1
    3f32:	b1 2c       	mov	r11, r1
    3f34:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    3f36:	01 13       	cpse	r16, r17
    3f38:	03 c0       	rjmp	.+6      	; 0x3f40 <printFloat+0xcc>
    3f3a:	21 e0       	ldi	r18, 0x01	; 1
    3f3c:	21 0f       	add	r18, r17
    3f3e:	01 c0       	rjmp	.+2      	; 0x3f42 <printFloat+0xce>
    3f40:	21 2f       	mov	r18, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    3f42:	11 e0       	ldi	r17, 0x01	; 1
    3f44:	12 0f       	add	r17, r18
    3f46:	ee 24       	eor	r14, r14
    3f48:	e3 94       	inc	r14
    3f4a:	f1 2c       	mov	r15, r1
    3f4c:	ec 0e       	add	r14, r28
    3f4e:	fd 1e       	adc	r15, r29
    3f50:	e2 0e       	add	r14, r18
    3f52:	f1 1c       	adc	r15, r1
    3f54:	a5 01       	movw	r20, r10
    3f56:	94 01       	movw	r18, r8
    3f58:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <__udivmodsi4>
    3f5c:	60 5d       	subi	r22, 0xD0	; 208
    3f5e:	f7 01       	movw	r30, r14
    3f60:	60 83       	st	Z, r22
    a /= 10;
    3f62:	62 2f       	mov	r22, r18
    3f64:	73 2f       	mov	r23, r19
    3f66:	84 2f       	mov	r24, r20
    3f68:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    3f6a:	61 15       	cp	r22, r1
    3f6c:	71 05       	cpc	r23, r1
    3f6e:	81 05       	cpc	r24, r1
    3f70:	91 05       	cpc	r25, r1
    3f72:	09 f7       	brne	.-62     	; 0x3f36 <printFloat+0xc2>
    3f74:	01 c0       	rjmp	.+2      	; 0x3f78 <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    3f76:	10 e0       	ldi	r17, 0x00	; 0
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3f78:	10 17       	cp	r17, r16
    3f7a:	60 f4       	brcc	.+24     	; 0x3f94 <printFloat+0x120>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    3f7c:	80 e3       	ldi	r24, 0x30	; 48
    3f7e:	e1 e0       	ldi	r30, 0x01	; 1
    3f80:	f0 e0       	ldi	r31, 0x00	; 0
    3f82:	ec 0f       	add	r30, r28
    3f84:	fd 1f       	adc	r31, r29
    3f86:	e1 0f       	add	r30, r17
    3f88:	f1 1d       	adc	r31, r1
    3f8a:	80 83       	st	Z, r24
    3f8c:	1f 5f       	subi	r17, 0xFF	; 255
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3f8e:	01 13       	cpse	r16, r17
    3f90:	f6 cf       	rjmp	.-20     	; 0x3f7e <printFloat+0x10a>
    3f92:	02 c0       	rjmp	.+4      	; 0x3f98 <printFloat+0x124>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    3f94:	01 13       	cpse	r16, r17
    3f96:	08 c0       	rjmp	.+16     	; 0x3fa8 <printFloat+0x134>
    i++;
    buf[i++] = '0'; 
    3f98:	12 e0       	ldi	r17, 0x02	; 2
    3f9a:	10 0f       	add	r17, r16
    3f9c:	0f 5f       	subi	r16, 0xFF	; 255
    3f9e:	fe 01       	movw	r30, r28
    3fa0:	e0 0f       	add	r30, r16
    3fa2:	f1 1d       	adc	r31, r1
    3fa4:	80 e3       	ldi	r24, 0x30	; 48
    3fa6:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3fa8:	11 23       	and	r17, r17
    3faa:	41 f0       	breq	.+16     	; 0x3fbc <printFloat+0x148>
    serial_write(buf[i-1]);
    3fac:	fe 01       	movw	r30, r28
    3fae:	e1 0f       	add	r30, r17
    3fb0:	f1 1d       	adc	r31, r1
    3fb2:	80 81       	ld	r24, Z
    3fb4:	0e 94 29 28 	call	0x5052	; 0x5052 <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3fb8:	11 50       	subi	r17, 0x01	; 1
    3fba:	c1 f7       	brne	.-16     	; 0x3fac <printFloat+0x138>
    serial_write(buf[i-1]);
}
    3fbc:	2a 96       	adiw	r28, 0x0a	; 10
    3fbe:	0f b6       	in	r0, 0x3f	; 63
    3fc0:	f8 94       	cli
    3fc2:	de bf       	out	0x3e, r29	; 62
    3fc4:	0f be       	out	0x3f, r0	; 63
    3fc6:	cd bf       	out	0x3d, r28	; 61
    3fc8:	df 91       	pop	r29
    3fca:	cf 91       	pop	r28
    3fcc:	1f 91       	pop	r17
    3fce:	0f 91       	pop	r16
    3fd0:	ff 90       	pop	r15
    3fd2:	ef 90       	pop	r14
    3fd4:	df 90       	pop	r13
    3fd6:	cf 90       	pop	r12
    3fd8:	bf 90       	pop	r11
    3fda:	af 90       	pop	r10
    3fdc:	9f 90       	pop	r9
    3fde:	8f 90       	pop	r8
    3fe0:	08 95       	ret

00003fe2 <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    3fe2:	20 91 c2 06 	lds	r18, 0x06C2	; 0x8006c2 <settings+0x3d>
    3fe6:	20 ff       	sbrs	r18, 0
    3fe8:	0a c0       	rjmp	.+20     	; 0x3ffe <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    3fea:	2b e8       	ldi	r18, 0x8B	; 139
    3fec:	32 e4       	ldi	r19, 0x42	; 66
    3fee:	41 e2       	ldi	r20, 0x21	; 33
    3ff0:	5d e3       	ldi	r21, 0x3D	; 61
    3ff2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    3ff6:	44 e0       	ldi	r20, 0x04	; 4
    3ff8:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <printFloat>
    3ffc:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    3ffe:	43 e0       	ldi	r20, 0x03	; 3
    4000:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <printFloat>
    4004:	08 95       	ret

00004006 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    4006:	20 91 c2 06 	lds	r18, 0x06C2	; 0x8006c2 <settings+0x3d>
    400a:	20 ff       	sbrs	r18, 0
    400c:	0a c0       	rjmp	.+20     	; 0x4022 <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    400e:	2b e8       	ldi	r18, 0x8B	; 139
    4010:	32 e4       	ldi	r19, 0x42	; 66
    4012:	41 e2       	ldi	r20, 0x21	; 33
    4014:	5d e3       	ldi	r21, 0x3D	; 61
    4016:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    401a:	41 e0       	ldi	r20, 0x01	; 1
    401c:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <printFloat>
    4020:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    4022:	40 e0       	ldi	r20, 0x00	; 0
    4024:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <printFloat>
    4028:	08 95       	ret

0000402a <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    402a:	43 e0       	ldi	r20, 0x03	; 3
    402c:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <printFloat>
    4030:	08 95       	ret

00004032 <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    4032:	3d 98       	cbi	0x07, 5	; 7
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    4034:	45 9a       	sbi	0x08, 5	; 8
    4036:	08 95       	ret

00004038 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    4038:	10 92 c4 05 	sts	0x05C4, r1	; 0x8005c4 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    403c:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <settings+0x3d>
    4040:	99 23       	and	r25, r25
    4042:	1c f0       	brlt	.+6      	; 0x404a <probe_configure_invert_mask+0x12>
    4044:	90 e2       	ldi	r25, 0x20	; 32
    4046:	90 93 c4 05 	sts	0x05C4, r25	; 0x8005c4 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    404a:	88 23       	and	r24, r24
    404c:	31 f0       	breq	.+12     	; 0x405a <probe_configure_invert_mask+0x22>
    404e:	90 91 c4 05 	lds	r25, 0x05C4	; 0x8005c4 <probe_invert_mask>
    4052:	80 e2       	ldi	r24, 0x20	; 32
    4054:	89 27       	eor	r24, r25
    4056:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <probe_invert_mask>
    405a:	08 95       	ret

0000405c <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    405c:	86 b1       	in	r24, 0x06	; 6
    405e:	80 72       	andi	r24, 0x20	; 32
    4060:	90 91 c4 05 	lds	r25, 0x05C4	; 0x8005c4 <probe_invert_mask>
    4064:	89 27       	eor	r24, r25
    4066:	08 95       	ret

00004068 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys_probe_state == PROBE_ACTIVE) {
    4068:	80 91 2c 05 	lds	r24, 0x052C	; 0x80052c <sys_probe_state>
    406c:	81 30       	cpi	r24, 0x01	; 1
    406e:	a1 f4       	brne	.+40     	; 0x4098 <probe_state_monitor+0x30>
    if (probe_get_state()) {
    4070:	0e 94 2e 20 	call	0x405c	; 0x405c <probe_get_state>
    4074:	88 23       	and	r24, r24
    4076:	81 f0       	breq	.+32     	; 0x4098 <probe_state_monitor+0x30>
      sys_probe_state = PROBE_OFF;
    4078:	10 92 2c 05 	sts	0x052C, r1	; 0x80052c <sys_probe_state>
      memcpy(sys.probe_position, sys.position, sizeof(sys.position));
    407c:	8c e0       	ldi	r24, 0x0C	; 12
    407e:	ea ea       	ldi	r30, 0xAA	; 170
    4080:	f5 e0       	ldi	r31, 0x05	; 5
    4082:	a6 eb       	ldi	r26, 0xB6	; 182
    4084:	b5 e0       	ldi	r27, 0x05	; 5
    4086:	01 90       	ld	r0, Z+
    4088:	0d 92       	st	X+, r0
    408a:	8a 95       	dec	r24
    408c:	e1 f7       	brne	.-8      	; 0x4086 <probe_state_monitor+0x1e>
      bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    408e:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    4092:	80 64       	ori	r24, 0x40	; 64
    4094:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    4098:	08 95       	ret

0000409a <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    409a:	af 92       	push	r10
    409c:	bf 92       	push	r11
    409e:	cf 92       	push	r12
    40a0:	df 92       	push	r13
    40a2:	ef 92       	push	r14
    40a4:	ff 92       	push	r15
    40a6:	0f 93       	push	r16
    40a8:	1f 93       	push	r17
    40aa:	cf 93       	push	r28
    40ac:	df 93       	push	r29
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40ae:	c6 ea       	ldi	r28, 0xA6	; 166
    40b0:	d5 e0       	ldi	r29, 0x05	; 5
    40b2:	01 e0       	ldi	r16, 0x01	; 1
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
            sys.state = STATE_CYCLE;
    40b4:	68 94       	set
    40b6:	aa 24       	eor	r10, r10
    40b8:	a3 f8       	bld	r10, 3
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    40ba:	0f 2e       	mov	r0, r31
    40bc:	fe e2       	ldi	r31, 0x2E	; 46
    40be:	ef 2e       	mov	r14, r31
    40c0:	f5 e0       	ldi	r31, 0x05	; 5
    40c2:	ff 2e       	mov	r15, r31
    40c4:	f0 2d       	mov	r31, r0
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
          sys.suspend |= SUSPEND_ENERGIZE;
          sys.state = STATE_SAFETY_DOOR;
    40c6:	68 94       	set
    40c8:	cc 24       	eor	r12, r12
    40ca:	c5 f8       	bld	r12, 5
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    40cc:	68 94       	set
    40ce:	dd 24       	eor	r13, r13
    40d0:	d4 f8       	bld	r13, 4
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    40d2:	68 94       	set
    40d4:	bb 24       	eor	r11, r11
    40d6:	b6 f8       	bld	r11, 6
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    40d8:	10 91 2d 05 	lds	r17, 0x052D	; 0x80052d <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    40dc:	11 23       	and	r17, r17
    40de:	b1 f1       	breq	.+108    	; 0x414c <protocol_execute_realtime+0xb2>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40e0:	09 83       	std	Y+1, r16	; 0x01
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    40e2:	11 ff       	sbrs	r17, 1
    40e4:	04 c0       	rjmp	.+8      	; 0x40ee <protocol_execute_realtime+0x54>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    40e6:	80 2f       	mov	r24, r16
    40e8:	0e 94 b2 22 	call	0x4564	; 0x4564 <report_alarm_message>
    40ec:	17 c0       	rjmp	.+46     	; 0x411c <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    40ee:	12 ff       	sbrs	r17, 2
    40f0:	04 c0       	rjmp	.+8      	; 0x40fa <protocol_execute_realtime+0x60>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    40f2:	82 e0       	ldi	r24, 0x02	; 2
    40f4:	0e 94 b2 22 	call	0x4564	; 0x4564 <report_alarm_message>
    40f8:	11 c0       	rjmp	.+34     	; 0x411c <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    40fa:	13 ff       	sbrs	r17, 3
    40fc:	04 c0       	rjmp	.+8      	; 0x4106 <protocol_execute_realtime+0x6c>
      report_alarm_message(ALARM_ABORT_CYCLE);
    40fe:	83 e0       	ldi	r24, 0x03	; 3
    4100:	0e 94 b2 22 	call	0x4564	; 0x4564 <report_alarm_message>
    4104:	0b c0       	rjmp	.+22     	; 0x411c <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    4106:	14 ff       	sbrs	r17, 4
    4108:	04 c0       	rjmp	.+8      	; 0x4112 <protocol_execute_realtime+0x78>
      report_alarm_message(ALARM_PROBE_FAIL);
    410a:	84 e0       	ldi	r24, 0x04	; 4
    410c:	0e 94 b2 22 	call	0x4564	; 0x4564 <report_alarm_message>
    4110:	05 c0       	rjmp	.+10     	; 0x411c <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_HOMING_FAIL) {
    4112:	15 ff       	sbrs	r17, 5
    4114:	03 c0       	rjmp	.+6      	; 0x411c <protocol_execute_realtime+0x82>
      report_alarm_message(ALARM_HOMING_FAIL);
    4116:	85 e0       	ldi	r24, 0x05	; 5
    4118:	0e 94 b2 22 	call	0x4564	; 0x4564 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    411c:	10 ff       	sbrs	r17, 0
    411e:	0f c0       	rjmp	.+30     	; 0x413e <protocol_execute_realtime+0xa4>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    4120:	80 2f       	mov	r24, r16
    4122:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
      bit_false_atomic(sys_rt_exec_state,EXEC_RESET); // Disable any existing reset
    4126:	9f b7       	in	r25, 0x3f	; 63
    4128:	f8 94       	cli
    412a:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    412e:	8f 7e       	andi	r24, 0xEF	; 239
    4130:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    4134:	9f bf       	out	0x3f, r25	; 63
        // TODO: Allow status reports during a critical alarm. Still need to think about implications of this.
//         if (sys_rt_exec_state & EXEC_STATUS_REPORT) { 
//           report_realtime_status();
//           bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT); 
//         }
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    4136:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    413a:	84 ff       	sbrs	r24, 4
    413c:	fc cf       	rjmp	.-8      	; 0x4136 <protocol_execute_realtime+0x9c>
    }
    bit_false_atomic(sys_rt_exec_alarm,0xFF); // Clear all alarm flags
    413e:	8f b7       	in	r24, 0x3f	; 63
    4140:	f8 94       	cli
    4142:	90 91 2d 05 	lds	r25, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    4146:	10 92 2d 05 	sts	0x052D, r1	; 0x80052d <sys_rt_exec_alarm>
    414a:	8f bf       	out	0x3f, r24	; 63
  }
  
  // Check amd execute realtime commands
  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    414c:	10 91 2b 05 	lds	r17, 0x052B	; 0x80052b <sys_rt_exec_state>
  if (rt_exec) { // Enter only if any bit flag is true
    4150:	11 23       	and	r17, r17
    4152:	09 f4       	brne	.+2      	; 0x4156 <protocol_execute_realtime+0xbc>
    4154:	a5 c0       	rjmp	.+330    	; 0x42a0 <protocol_execute_realtime+0x206>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    4156:	14 ff       	sbrs	r17, 4
    4158:	04 c0       	rjmp	.+8      	; 0x4162 <protocol_execute_realtime+0xc8>
      sys.abort = true;  // Only place this is set true.
    415a:	81 e0       	ldi	r24, 0x01	; 1
    415c:	80 93 a6 05 	sts	0x05A6, r24	; 0x8005a6 <sys>
      return; // Nothing else to do but exit.
    4160:	bf c0       	rjmp	.+382    	; 0x42e0 <protocol_execute_realtime+0x246>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    4162:	10 ff       	sbrs	r17, 0
    4164:	0a c0       	rjmp	.+20     	; 0x417a <protocol_execute_realtime+0xe0>
      report_realtime_status();
    4166:	0e 94 0d 27 	call	0x4e1a	; 0x4e1a <report_realtime_status>
      bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT);
    416a:	9f b7       	in	r25, 0x3f	; 63
    416c:	f8 94       	cli
    416e:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    4172:	8e 7f       	andi	r24, 0xFE	; 254
    4174:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    4178:	9f bf       	out	0x3f, r25	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    417a:	81 2f       	mov	r24, r17
    417c:	88 76       	andi	r24, 0x68	; 104
    417e:	09 f4       	brne	.+2      	; 0x4182 <protocol_execute_realtime+0xe8>
    4180:	a9 c0       	rjmp	.+338    	; 0x42d4 <protocol_execute_realtime+0x23a>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	88 23       	and	r24, r24
    4186:	59 f0       	breq	.+22     	; 0x419e <protocol_execute_realtime+0x104>
    4188:	98 2f       	mov	r25, r24
    418a:	9c 77       	andi	r25, 0x7C	; 124
    418c:	09 f0       	breq	.+2      	; 0x4190 <protocol_execute_realtime+0xf6>
    418e:	9f c0       	rjmp	.+318    	; 0x42ce <protocol_execute_realtime+0x234>
    4190:	23 c0       	rjmp	.+70     	; 0x41d8 <protocol_execute_realtime+0x13e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    4192:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    4196:	0a 83       	std	Y+2, r16	; 0x02
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    4198:	89 81       	ldd	r24, Y+1	; 0x01
    419a:	81 11       	cpse	r24, r1
    419c:	05 c0       	rjmp	.+10     	; 0x41a8 <protocol_execute_realtime+0x10e>
    419e:	82 e0       	ldi	r24, 0x02	; 2
    41a0:	8a 83       	std	Y+2, r24	; 0x02
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    41a2:	16 fd       	sbrc	r17, 6
    41a4:	06 c0       	rjmp	.+12     	; 0x41b2 <protocol_execute_realtime+0x118>
    41a6:	99 c0       	rjmp	.+306    	; 0x42da <protocol_execute_realtime+0x240>
    41a8:	16 ff       	sbrs	r17, 6
    41aa:	06 c0       	rjmp	.+12     	; 0x41b8 <protocol_execute_realtime+0x11e>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    41ac:	88 30       	cpi	r24, 0x08	; 8
    41ae:	09 f4       	brne	.+2      	; 0x41b2 <protocol_execute_realtime+0x118>
    41b0:	b9 82       	std	Y+1, r11	; 0x01
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    41b2:	8a 81       	ldd	r24, Y+2	; 0x02
    41b4:	88 60       	ori	r24, 0x08	; 8
    41b6:	8a 83       	std	Y+2, r24	; 0x02
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    41b8:	13 ff       	sbrs	r17, 3
    41ba:	03 c0       	rjmp	.+6      	; 0x41c2 <protocol_execute_realtime+0x128>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    41bc:	89 81       	ldd	r24, Y+1	; 0x01
    41be:	85 ff       	sbrs	r24, 5
    41c0:	d9 82       	std	Y+1, r13	; 0x01
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    41c2:	15 ff       	sbrs	r17, 5
    41c4:	09 c0       	rjmp	.+18     	; 0x41d8 <protocol_execute_realtime+0x13e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    41c6:	86 e0       	ldi	r24, 0x06	; 6
    41c8:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    41cc:	8a 81       	ldd	r24, Y+2	; 0x02
    41ce:	81 fd       	sbrc	r24, 1
    41d0:	14 60       	ori	r17, 0x04	; 4
          sys.suspend |= SUSPEND_ENERGIZE;
    41d2:	84 60       	ori	r24, 0x04	; 4
    41d4:	8a 83       	std	Y+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    41d6:	c9 82       	std	Y+1, r12	; 0x01
        }
         
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    41d8:	9f b7       	in	r25, 0x3f	; 63
    41da:	f8 94       	cli
    41dc:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    41e0:	87 79       	andi	r24, 0x97	; 151
    41e2:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    41e6:	9f bf       	out	0x3f, r25	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    41e8:	11 ff       	sbrs	r17, 1
    41ea:	3d c0       	rjmp	.+122    	; 0x4266 <protocol_execute_realtime+0x1cc>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    41ec:	81 2f       	mov	r24, r17
    41ee:	88 76       	andi	r24, 0x68	; 104
    41f0:	91 f5       	brne	.+100    	; 0x4256 <protocol_execute_realtime+0x1bc>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    41f2:	89 81       	ldd	r24, Y+1	; 0x01
    41f4:	88 23       	and	r24, r24
    41f6:	29 f0       	breq	.+10     	; 0x4202 <protocol_execute_realtime+0x168>
    41f8:	80 75       	andi	r24, 0x50	; 80
    41fa:	69 f1       	breq	.+90     	; 0x4256 <protocol_execute_realtime+0x1bc>
    41fc:	8a 81       	ldd	r24, Y+2	; 0x02
    41fe:	81 ff       	sbrs	r24, 1
    4200:	2a c0       	rjmp	.+84     	; 0x4256 <protocol_execute_realtime+0x1bc>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    4202:	8a 81       	ldd	r24, Y+2	; 0x02
    4204:	82 ff       	sbrs	r24, 2
    4206:	18 c0       	rjmp	.+48     	; 0x4238 <protocol_execute_realtime+0x19e>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    4208:	f7 01       	movw	r30, r14
    420a:	81 85       	ldd	r24, Z+9	; 0x09
    420c:	88 23       	and	r24, r24
    420e:	51 f0       	breq	.+20     	; 0x4224 <protocol_execute_realtime+0x18a>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    4210:	42 85       	ldd	r20, Z+10	; 0x0a
    4212:	53 85       	ldd	r21, Z+11	; 0x0b
    4214:	64 85       	ldd	r22, Z+12	; 0x0c
    4216:	75 85       	ldd	r23, Z+13	; 0x0d
    4218:	0e 94 d9 2b 	call	0x57b2	; 0x57b2 <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    421c:	80 ea       	ldi	r24, 0xA0	; 160
    421e:	9f e0       	ldi	r25, 0x0F	; 15
    4220:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    4224:	f7 01       	movw	r30, r14
    4226:	80 85       	ldd	r24, Z+8	; 0x08
    4228:	88 23       	and	r24, r24
    422a:	31 f0       	breq	.+12     	; 0x4238 <protocol_execute_realtime+0x19e>
              coolant_set_state(gc_state.modal.coolant); 
    422c:	0e 94 0a 05 	call	0xa14	; 0xa14 <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    4230:	88 ee       	ldi	r24, 0xE8	; 232
    4232:	93 e0       	ldi	r25, 0x03	; 3
    4234:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    4238:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <plan_get_current_block>
    423c:	89 2b       	or	r24, r25
    423e:	49 f0       	breq	.+18     	; 0x4252 <protocol_execute_realtime+0x1b8>
    4240:	8a 81       	ldd	r24, Y+2	; 0x02
    4242:	83 fd       	sbrc	r24, 3
    4244:	06 c0       	rjmp	.+12     	; 0x4252 <protocol_execute_realtime+0x1b8>
            sys.state = STATE_CYCLE;
    4246:	a9 82       	std	Y+1, r10	; 0x01
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    4248:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <st_prep_buffer>
            st_wake_up();
    424c:	0e 94 4f 2c 	call	0x589e	; 0x589e <st_wake_up>
    4250:	01 c0       	rjmp	.+2      	; 0x4254 <protocol_execute_realtime+0x1ba>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    4252:	19 82       	std	Y+1, r1	; 0x01
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    4254:	1a 82       	std	Y+2, r1	; 0x02
        }
      }    
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_START);
    4256:	9f b7       	in	r25, 0x3f	; 63
    4258:	f8 94       	cli
    425a:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    425e:	8d 7f       	andi	r24, 0xFD	; 253
    4260:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    4264:	9f bf       	out	0x3f, r25	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    4266:	12 ff       	sbrs	r17, 2
    4268:	1b c0       	rjmp	.+54     	; 0x42a0 <protocol_execute_realtime+0x206>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR) && !(sys.soft_limit)) {
    426a:	89 81       	ldd	r24, Y+1	; 0x01
    426c:	80 73       	andi	r24, 0x30	; 48
    426e:	71 f0       	breq	.+28     	; 0x428c <protocol_execute_realtime+0x1f2>
    4270:	8b 81       	ldd	r24, Y+3	; 0x03
    4272:	81 11       	cpse	r24, r1
    4274:	0b c0       	rjmp	.+22     	; 0x428c <protocol_execute_realtime+0x1f2>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    4276:	8a 81       	ldd	r24, Y+2	; 0x02
    4278:	82 ff       	sbrs	r24, 2
    427a:	04 c0       	rjmp	.+8      	; 0x4284 <protocol_execute_realtime+0x1ea>
          spindle_stop();
    427c:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <spindle_stop>
          coolant_stop();
    4280:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY);
    4284:	8a 81       	ldd	r24, Y+2	; 0x02
    4286:	82 60       	ori	r24, 0x02	; 2
    4288:	8a 83       	std	Y+2, r24	; 0x02
    428a:	02 c0       	rjmp	.+4      	; 0x4290 <protocol_execute_realtime+0x1f6>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    428c:	1a 82       	std	Y+2, r1	; 0x02
        sys.state = STATE_IDLE;
    428e:	19 82       	std	Y+1, r1	; 0x01
      }
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    4290:	9f b7       	in	r25, 0x3f	; 63
    4292:	f8 94       	cli
    4294:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    4298:	8b 7f       	andi	r24, 0xFB	; 251
    429a:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    429e:	9f bf       	out	0x3f, r25	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    42a0:	89 81       	ldd	r24, Y+1	; 0x01
    42a2:	8c 77       	andi	r24, 0x7C	; 124
    42a4:	11 f0       	breq	.+4      	; 0x42aa <protocol_execute_realtime+0x210>
    42a6:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    42aa:	89 81       	ldd	r24, Y+1	; 0x01
    42ac:	80 32       	cpi	r24, 0x20	; 32
    42ae:	41 f4       	brne	.+16     	; 0x42c0 <protocol_execute_realtime+0x226>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    42b0:	8a 81       	ldd	r24, Y+2	; 0x02
    42b2:	81 ff       	sbrs	r24, 1
    42b4:	05 c0       	rjmp	.+10     	; 0x42c0 <protocol_execute_realtime+0x226>
      if (!(system_check_safety_door_ajar())) {
    42b6:	0e 94 81 36 	call	0x6d02	; 0x6d02 <system_check_safety_door_ajar>
    42ba:	81 11       	cpse	r24, r1
    42bc:	01 c0       	rjmp	.+2      	; 0x42c0 <protocol_execute_realtime+0x226>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    42be:	d9 82       	std	Y+1, r13	; 0x01
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    42c0:	8a 81       	ldd	r24, Y+2	; 0x02
    42c2:	81 11       	cpse	r24, r1
    42c4:	09 cf       	rjmp	.-494    	; 0x40d8 <protocol_execute_realtime+0x3e>
    42c6:	0c c0       	rjmp	.+24     	; 0x42e0 <protocol_execute_realtime+0x246>
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    42c8:	16 ff       	sbrs	r17, 6
    42ca:	76 cf       	rjmp	.-276    	; 0x41b8 <protocol_execute_realtime+0x11e>
    42cc:	72 cf       	rjmp	.-284    	; 0x41b2 <protocol_execute_realtime+0x118>
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    42ce:	88 30       	cpi	r24, 0x08	; 8
    42d0:	d9 f7       	brne	.-10     	; 0x42c8 <protocol_execute_realtime+0x22e>
    42d2:	5f cf       	rjmp	.-322    	; 0x4192 <protocol_execute_realtime+0xf8>
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    42d4:	11 fd       	sbrc	r17, 1
    42d6:	8d cf       	rjmp	.-230    	; 0x41f2 <protocol_execute_realtime+0x158>
    42d8:	c6 cf       	rjmp	.-116    	; 0x4266 <protocol_execute_realtime+0x1cc>
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    42da:	13 fd       	sbrc	r17, 3
    42dc:	71 cf       	rjmp	.-286    	; 0x41c0 <protocol_execute_realtime+0x126>
    42de:	71 cf       	rjmp	.-286    	; 0x41c2 <protocol_execute_realtime+0x128>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    42e0:	df 91       	pop	r29
    42e2:	cf 91       	pop	r28
    42e4:	1f 91       	pop	r17
    42e6:	0f 91       	pop	r16
    42e8:	ff 90       	pop	r15
    42ea:	ef 90       	pop	r14
    42ec:	df 90       	pop	r13
    42ee:	cf 90       	pop	r12
    42f0:	bf 90       	pop	r11
    42f2:	af 90       	pop	r10
    42f4:	08 95       	ret

000042f6 <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); } 
    42f6:	9f b7       	in	r25, 0x3f	; 63
    42f8:	f8 94       	cli
    42fa:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    42fe:	82 60       	ori	r24, 0x02	; 2
    4300:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    4304:	9f bf       	out	0x3f, r25	; 63
    4306:	08 95       	ret

00004308 <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    4308:	bf 92       	push	r11
    430a:	cf 92       	push	r12
    430c:	df 92       	push	r13
    430e:	ef 92       	push	r14
    4310:	ff 92       	push	r15
    4312:	0f 93       	push	r16
    4314:	1f 93       	push	r17
    4316:	cf 93       	push	r28
    4318:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    431a:	0e 94 25 23 	call	0x464a	; 0x464a <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    431e:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    4322:	81 30       	cpi	r24, 0x01	; 1
    4324:	81 f4       	brne	.+32     	; 0x4346 <protocol_main_loop+0x3e>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    4326:	82 e0       	ldi	r24, 0x02	; 2
    4328:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    432c:	f1 2c       	mov	r15, r1
    432e:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    4330:	c6 ea       	ldi	r28, 0xA6	; 166
    4332:	d5 e0       	ldi	r29, 0x05	; 5
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    4334:	d1 2c       	mov	r13, r1

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    4336:	08 e0       	ldi	r16, 0x08	; 8
    4338:	14 e0       	ldi	r17, 0x04	; 4
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    433a:	cc 24       	eor	r12, r12
    433c:	c3 94       	inc	r12
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    433e:	68 94       	set
    4340:	bb 24       	eor	r11, r11
    4342:	b1 f8       	bld	r11, 1
    4344:	78 c0       	rjmp	.+240    	; 0x4436 <protocol_main_loop+0x12e>
  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    report_feedback_message(MESSAGE_ALARM_LOCK); 
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    4346:	0e 94 81 36 	call	0x6d02	; 0x6d02 <system_check_safety_door_ajar>
    434a:	88 23       	and	r24, r24
    434c:	41 f0       	breq	.+16     	; 0x435e <protocol_main_loop+0x56>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    434e:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    4352:	80 62       	ori	r24, 0x20	; 32
    4354:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    4358:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    435c:	02 c0       	rjmp	.+4      	; 0x4362 <protocol_main_loop+0x5a>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    435e:	10 92 a7 05 	sts	0x05A7, r1	; 0x8005a7 <sys+0x1>
    } 
    system_execute_startup(line); // Execute startup script.
    4362:	88 e0       	ldi	r24, 0x08	; 8
    4364:	94 e0       	ldi	r25, 0x04	; 4
    4366:	0e 94 83 36 	call	0x6d06	; 0x6d06 <system_execute_startup>
    436a:	e0 cf       	rjmp	.-64     	; 0x432c <protocol_main_loop+0x24>
	#if( 1 )
    while((c = serial_read()) != SERIAL_NO_DATA) {
	#else
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
    436c:	8a 30       	cpi	r24, 0x0A	; 10
    436e:	11 f0       	breq	.+4      	; 0x4374 <protocol_main_loop+0x6c>
    4370:	8d 30       	cpi	r24, 0x0D	; 13
    4372:	79 f5       	brne	.+94     	; 0x43d2 <protocol_main_loop+0xca>
        line[char_counter] = 0; // Set string termination character.
    4374:	ef 2d       	mov	r30, r15
    4376:	f0 e0       	ldi	r31, 0x00	; 0
    4378:	e8 5f       	subi	r30, 0xF8	; 248
    437a:	fb 4f       	sbci	r31, 0xFB	; 251
    437c:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    437e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    4382:	88 81       	ld	r24, Y
    4384:	81 11       	cpse	r24, r1
    4386:	51 c0       	rjmp	.+162    	; 0x442a <protocol_main_loop+0x122>

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    4388:	f8 01       	movw	r30, r16
    438a:	80 81       	ld	r24, Z
    438c:	81 11       	cpse	r24, r1
    438e:	06 c0       	rjmp	.+12     	; 0x439c <protocol_main_loop+0x94>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    4390:	8d 2d       	mov	r24, r13
    4392:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    4396:	fd 2c       	mov	r15, r13
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    4398:	ed 2c       	mov	r14, r13
    439a:	4d c0       	rjmp	.+154    	; 0x4436 <protocol_main_loop+0x12e>

  if (line[0] == 0) {
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);

  } else if (line[0] == '$') {
    439c:	84 32       	cpi	r24, 0x24	; 36
    439e:	41 f4       	brne	.+16     	; 0x43b0 <protocol_main_loop+0xa8>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    43a0:	c8 01       	movw	r24, r16
    43a2:	0e 94 a5 36 	call	0x6d4a	; 0x6d4a <system_execute_line>
    43a6:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43aa:	fd 2c       	mov	r15, r13
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43ac:	ed 2c       	mov	r14, r13
    43ae:	43 c0       	rjmp	.+134    	; 0x4436 <protocol_main_loop+0x12e>

  } else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  } else if (sys.state == STATE_ALARM) {
    43b0:	89 81       	ldd	r24, Y+1	; 0x01
    43b2:	81 30       	cpi	r24, 0x01	; 1
    43b4:	31 f4       	brne	.+12     	; 0x43c2 <protocol_main_loop+0xba>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    43b6:	89 e0       	ldi	r24, 0x09	; 9
    43b8:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43bc:	fd 2c       	mov	r15, r13
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43be:	ed 2c       	mov	r14, r13
    43c0:	3a c0       	rjmp	.+116    	; 0x4436 <protocol_main_loop+0x12e>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);

  } else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    43c2:	c8 01       	movw	r24, r16
    43c4:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    43c8:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43cc:	fd 2c       	mov	r15, r13
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43ce:	ed 2c       	mov	r14, r13
    43d0:	32 c0       	rjmp	.+100    	; 0x4436 <protocol_main_loop+0x12e>
        char_counter = 0;
      } else {
        if (comment != COMMENT_NONE) {
    43d2:	ee 20       	and	r14, r14
    43d4:	39 f0       	breq	.+14     	; 0x43e4 <protocol_main_loop+0xdc>
          // Throw away all comment characters
          if (c == ')') {
    43d6:	89 32       	cpi	r24, 0x29	; 41
    43d8:	71 f5       	brne	.+92     	; 0x4436 <protocol_main_loop+0x12e>
            // End of comment. Resume line. But, not if semicolon type comment.
            if (comment == COMMENT_TYPE_PARENTHESES) { comment = COMMENT_NONE; }
    43da:	f1 e0       	ldi	r31, 0x01	; 1
    43dc:	ef 12       	cpse	r14, r31
    43de:	2b c0       	rjmp	.+86     	; 0x4436 <protocol_main_loop+0x12e>
    43e0:	ed 2c       	mov	r14, r13
    43e2:	29 c0       	rjmp	.+82     	; 0x4436 <protocol_main_loop+0x12e>
          }
        } else {
          if (c <= ' ') { 
    43e4:	81 32       	cpi	r24, 0x21	; 33
    43e6:	38 f1       	brcs	.+78     	; 0x4436 <protocol_main_loop+0x12e>
            // Throw away whitepace and control characters  
          } else if (c == '/') { 
    43e8:	8f 32       	cpi	r24, 0x2F	; 47
    43ea:	29 f1       	breq	.+74     	; 0x4436 <protocol_main_loop+0x12e>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    43ec:	88 32       	cpi	r24, 0x28	; 40
    43ee:	01 f1       	breq	.+64     	; 0x4430 <protocol_main_loop+0x128>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
          } else if (c == ';') {
    43f0:	8b 33       	cpi	r24, 0x3B	; 59
    43f2:	01 f1       	breq	.+64     	; 0x4434 <protocol_main_loop+0x12c>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute 
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.

          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    43f4:	9e e4       	ldi	r25, 0x4E	; 78
    43f6:	9f 15       	cp	r25, r15
    43f8:	28 f4       	brcc	.+10     	; 0x4404 <protocol_main_loop+0xfc>
            // Detect line buffer overflow. Report error and reset line buffer.
            report_status_message(STATUS_OVERFLOW);
    43fa:	8b e0       	ldi	r24, 0x0B	; 11
    43fc:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
            comment = COMMENT_NONE;
            char_counter = 0;
    4400:	fd 2c       	mov	r15, r13
    4402:	19 c0       	rjmp	.+50     	; 0x4436 <protocol_main_loop+0x12e>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    4404:	9f e9       	ldi	r25, 0x9F	; 159
    4406:	98 0f       	add	r25, r24
    4408:	9a 31       	cpi	r25, 0x1A	; 26
    440a:	40 f4       	brcc	.+16     	; 0x441c <protocol_main_loop+0x114>
            line[char_counter++] = c-'a'+'A';
    440c:	ef 2d       	mov	r30, r15
    440e:	f0 e0       	ldi	r31, 0x00	; 0
    4410:	e8 5f       	subi	r30, 0xF8	; 248
    4412:	fb 4f       	sbci	r31, 0xFB	; 251
    4414:	80 52       	subi	r24, 0x20	; 32
    4416:	80 83       	st	Z, r24
    4418:	f3 94       	inc	r15
    441a:	0d c0       	rjmp	.+26     	; 0x4436 <protocol_main_loop+0x12e>
          } else {
            line[char_counter++] = c;
    441c:	ef 2d       	mov	r30, r15
    441e:	f0 e0       	ldi	r31, 0x00	; 0
    4420:	e8 5f       	subi	r30, 0xF8	; 248
    4422:	fb 4f       	sbci	r31, 0xFB	; 251
    4424:	80 83       	st	Z, r24
    4426:	f3 94       	inc	r15
    4428:	06 c0       	rjmp	.+12     	; 0x4436 <protocol_main_loop+0x12e>
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    442a:	fd 2c       	mov	r15, r13
	while((c = serial_read_test()) != SERIAL_NO_DATA) {
	#endif
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    442c:	ed 2c       	mov	r14, r13
    442e:	03 c0       	rjmp	.+6      	; 0x4436 <protocol_main_loop+0x12e>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    4430:	ec 2c       	mov	r14, r12
    4432:	01 c0       	rjmp	.+2      	; 0x4436 <protocol_main_loop+0x12e>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    4434:	eb 2c       	mov	r14, r11
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
	#if( 1 )
    while((c = serial_read()) != SERIAL_NO_DATA) {
    4436:	0e 94 6f 28 	call	0x50de	; 0x50de <serial_read>
    443a:	8f 3f       	cpi	r24, 0xFF	; 255
    443c:	09 f0       	breq	.+2      	; 0x4440 <protocol_main_loop+0x138>
    443e:	96 cf       	rjmp	.-212    	; 0x436c <protocol_main_loop+0x64>
    }
    
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    4440:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    4444:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    4448:	88 81       	ld	r24, Y
    444a:	88 23       	and	r24, r24
    444c:	a1 f3       	breq	.-24     	; 0x4436 <protocol_main_loop+0x12e>
              
  }
  
  return; /* Never reached */
}
    444e:	df 91       	pop	r29
    4450:	cf 91       	pop	r28
    4452:	1f 91       	pop	r17
    4454:	0f 91       	pop	r16
    4456:	ff 90       	pop	r15
    4458:	ef 90       	pop	r14
    445a:	df 90       	pop	r13
    445c:	cf 90       	pop	r12
    445e:	bf 90       	pop	r11
    4460:	08 95       	ret

00004462 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    4462:	cf 93       	push	r28
    4464:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    4466:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    446a:	c6 ea       	ldi	r28, 0xA6	; 166
    446c:	d5 e0       	ldi	r29, 0x05	; 5
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    446e:	0e 94 4d 20 	call	0x409a	; 0x409a <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    4472:	88 81       	ld	r24, Y
    4474:	81 11       	cpse	r24, r1
    4476:	07 c0       	rjmp	.+14     	; 0x4486 <protocol_buffer_synchronize+0x24>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    4478:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <plan_get_current_block>
    447c:	89 2b       	or	r24, r25
    447e:	b9 f7       	brne	.-18     	; 0x446e <protocol_buffer_synchronize+0xc>
    4480:	89 81       	ldd	r24, Y+1	; 0x01
    4482:	88 30       	cpi	r24, 0x08	; 8
    4484:	a1 f3       	breq	.-24     	; 0x446e <protocol_buffer_synchronize+0xc>
}
    4486:	df 91       	pop	r29
    4488:	cf 91       	pop	r28
    448a:	08 95       	ret

0000448c <report_status_message>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  printPgmString(PSTR("]\r\n"));
}
    448c:	cf 93       	push	r28
    448e:	c8 2f       	mov	r28, r24
    4490:	81 11       	cpse	r24, r1
    4492:	05 c0       	rjmp	.+10     	; 0x449e <report_status_message+0x12>
    4494:	84 ec       	ldi	r24, 0xC4	; 196
    4496:	99 e0       	ldi	r25, 0x09	; 9
    4498:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    449c:	61 c0       	rjmp	.+194    	; 0x4560 <report_status_message+0xd4>
    449e:	8c eb       	ldi	r24, 0xBC	; 188
    44a0:	99 e0       	ldi	r25, 0x09	; 9
    44a2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44a6:	8c 2f       	mov	r24, r28
    44a8:	90 e0       	ldi	r25, 0x00	; 0
    44aa:	fc 01       	movw	r30, r24
    44ac:	31 97       	sbiw	r30, 0x01	; 1
    44ae:	e6 31       	cpi	r30, 0x16	; 22
    44b0:	f1 05       	cpc	r31, r1
    44b2:	08 f0       	brcs	.+2      	; 0x44b6 <report_status_message+0x2a>
    44b4:	4a c0       	rjmp	.+148    	; 0x454a <report_status_message+0xbe>
    44b6:	e9 52       	subi	r30, 0x29	; 41
    44b8:	ff 4f       	sbci	r31, 0xFF	; 255
    44ba:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
    44be:	84 ea       	ldi	r24, 0xA4	; 164
    44c0:	99 e0       	ldi	r25, 0x09	; 9
    44c2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44c6:	48 c0       	rjmp	.+144    	; 0x4558 <report_status_message+0xcc>
    44c8:	82 e9       	ldi	r24, 0x92	; 146
    44ca:	99 e0       	ldi	r25, 0x09	; 9
    44cc:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44d0:	43 c0       	rjmp	.+134    	; 0x4558 <report_status_message+0xcc>
    44d2:	80 e8       	ldi	r24, 0x80	; 128
    44d4:	99 e0       	ldi	r25, 0x09	; 9
    44d6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44da:	3e c0       	rjmp	.+124    	; 0x4558 <report_status_message+0xcc>
    44dc:	86 e7       	ldi	r24, 0x76	; 118
    44de:	99 e0       	ldi	r25, 0x09	; 9
    44e0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44e4:	39 c0       	rjmp	.+114    	; 0x4558 <report_status_message+0xcc>
    44e6:	85 e6       	ldi	r24, 0x65	; 101
    44e8:	99 e0       	ldi	r25, 0x09	; 9
    44ea:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44ee:	34 c0       	rjmp	.+104    	; 0x4558 <report_status_message+0xcc>
    44f0:	86 e5       	ldi	r24, 0x56	; 86
    44f2:	99 e0       	ldi	r25, 0x09	; 9
    44f4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    44f8:	2f c0       	rjmp	.+94     	; 0x4558 <report_status_message+0xcc>
    44fa:	85 e3       	ldi	r24, 0x35	; 53
    44fc:	99 e0       	ldi	r25, 0x09	; 9
    44fe:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4502:	2a c0       	rjmp	.+84     	; 0x4558 <report_status_message+0xcc>
    4504:	8c e2       	ldi	r24, 0x2C	; 44
    4506:	99 e0       	ldi	r25, 0x09	; 9
    4508:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    450c:	25 c0       	rjmp	.+74     	; 0x4558 <report_status_message+0xcc>
    450e:	81 e2       	ldi	r24, 0x21	; 33
    4510:	99 e0       	ldi	r25, 0x09	; 9
    4512:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4516:	20 c0       	rjmp	.+64     	; 0x4558 <report_status_message+0xcc>
    4518:	8e e0       	ldi	r24, 0x0E	; 14
    451a:	99 e0       	ldi	r25, 0x09	; 9
    451c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4520:	1b c0       	rjmp	.+54     	; 0x4558 <report_status_message+0xcc>
    4522:	80 e0       	ldi	r24, 0x00	; 0
    4524:	99 e0       	ldi	r25, 0x09	; 9
    4526:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    452a:	16 c0       	rjmp	.+44     	; 0x4558 <report_status_message+0xcc>
    452c:	8a ee       	ldi	r24, 0xEA	; 234
    452e:	98 e0       	ldi	r25, 0x08	; 8
    4530:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4534:	11 c0       	rjmp	.+34     	; 0x4558 <report_status_message+0xcc>
    4536:	86 ed       	ldi	r24, 0xD6	; 214
    4538:	98 e0       	ldi	r25, 0x08	; 8
    453a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    453e:	0c c0       	rjmp	.+24     	; 0x4558 <report_status_message+0xcc>
    4540:	82 ec       	ldi	r24, 0xC2	; 194
    4542:	98 e0       	ldi	r25, 0x08	; 8
    4544:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4548:	07 c0       	rjmp	.+14     	; 0x4558 <report_status_message+0xcc>
    454a:	80 eb       	ldi	r24, 0xB0	; 176
    454c:	98 e0       	ldi	r25, 0x08	; 8
    454e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4552:	8c 2f       	mov	r24, r28
    4554:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4558:	8d ea       	ldi	r24, 0xAD	; 173
    455a:	98 e0       	ldi	r25, 0x08	; 8
    455c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4560:	cf 91       	pop	r28
    4562:	08 95       	ret

00004564 <report_alarm_message>:
    4564:	cf 93       	push	r28
    4566:	c8 2f       	mov	r28, r24
    4568:	85 ea       	ldi	r24, 0xA5	; 165
    456a:	98 e0       	ldi	r25, 0x08	; 8
    456c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4570:	c3 30       	cpi	r28, 0x03	; 3
    4572:	a9 f0       	breq	.+42     	; 0x459e <report_alarm_message+0x3a>
    4574:	2c f4       	brge	.+10     	; 0x4580 <report_alarm_message+0x1c>
    4576:	c1 30       	cpi	r28, 0x01	; 1
    4578:	41 f0       	breq	.+16     	; 0x458a <report_alarm_message+0x26>
    457a:	c2 30       	cpi	r28, 0x02	; 2
    457c:	59 f0       	breq	.+22     	; 0x4594 <report_alarm_message+0x30>
    457e:	1d c0       	rjmp	.+58     	; 0x45ba <report_alarm_message+0x56>
    4580:	c4 30       	cpi	r28, 0x04	; 4
    4582:	91 f0       	breq	.+36     	; 0x45a8 <report_alarm_message+0x44>
    4584:	c5 30       	cpi	r28, 0x05	; 5
    4586:	a9 f0       	breq	.+42     	; 0x45b2 <report_alarm_message+0x4e>
    4588:	18 c0       	rjmp	.+48     	; 0x45ba <report_alarm_message+0x56>
    458a:	8a e9       	ldi	r24, 0x9A	; 154
    458c:	98 e0       	ldi	r25, 0x08	; 8
    458e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4592:	13 c0       	rjmp	.+38     	; 0x45ba <report_alarm_message+0x56>
    4594:	8f e8       	ldi	r24, 0x8F	; 143
    4596:	98 e0       	ldi	r25, 0x08	; 8
    4598:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    459c:	0e c0       	rjmp	.+28     	; 0x45ba <report_alarm_message+0x56>
    459e:	8c e7       	ldi	r24, 0x7C	; 124
    45a0:	98 e0       	ldi	r25, 0x08	; 8
    45a2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45a6:	09 c0       	rjmp	.+18     	; 0x45ba <report_alarm_message+0x56>
    45a8:	81 e7       	ldi	r24, 0x71	; 113
    45aa:	98 e0       	ldi	r25, 0x08	; 8
    45ac:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45b0:	04 c0       	rjmp	.+8      	; 0x45ba <report_alarm_message+0x56>
    45b2:	85 e6       	ldi	r24, 0x65	; 101
    45b4:	98 e0       	ldi	r25, 0x08	; 8
    45b6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45ba:	82 e6       	ldi	r24, 0x62	; 98
    45bc:	98 e0       	ldi	r25, 0x08	; 8
    45be:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45c2:	84 ef       	ldi	r24, 0xF4	; 244
    45c4:	91 e0       	ldi	r25, 0x01	; 1
    45c6:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>
    45ca:	cf 91       	pop	r28
    45cc:	08 95       	ret

000045ce <report_feedback_message>:
    45ce:	cf 93       	push	r28
    45d0:	c8 2f       	mov	r28, r24
    45d2:	80 e6       	ldi	r24, 0x60	; 96
    45d4:	98 e0       	ldi	r25, 0x08	; 8
    45d6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45da:	8c 2f       	mov	r24, r28
    45dc:	90 e0       	ldi	r25, 0x00	; 0
    45de:	fc 01       	movw	r30, r24
    45e0:	31 97       	sbiw	r30, 0x01	; 1
    45e2:	e8 30       	cpi	r30, 0x08	; 8
    45e4:	f1 05       	cpc	r31, r1
    45e6:	58 f5       	brcc	.+86     	; 0x463e <report_feedback_message+0x70>
    45e8:	e3 51       	subi	r30, 0x13	; 19
    45ea:	ff 4f       	sbci	r31, 0xFF	; 255
    45ec:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
    45f0:	8e e4       	ldi	r24, 0x4E	; 78
    45f2:	98 e0       	ldi	r25, 0x08	; 8
    45f4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    45f8:	22 c0       	rjmp	.+68     	; 0x463e <report_feedback_message+0x70>
    45fa:	8a e3       	ldi	r24, 0x3A	; 58
    45fc:	98 e0       	ldi	r25, 0x08	; 8
    45fe:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4602:	1d c0       	rjmp	.+58     	; 0x463e <report_feedback_message+0x70>
    4604:	88 e2       	ldi	r24, 0x28	; 40
    4606:	98 e0       	ldi	r25, 0x08	; 8
    4608:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    460c:	18 c0       	rjmp	.+48     	; 0x463e <report_feedback_message+0x70>
    460e:	80 e2       	ldi	r24, 0x20	; 32
    4610:	98 e0       	ldi	r25, 0x08	; 8
    4612:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4616:	13 c0       	rjmp	.+38     	; 0x463e <report_feedback_message+0x70>
    4618:	87 e1       	ldi	r24, 0x17	; 23
    461a:	98 e0       	ldi	r25, 0x08	; 8
    461c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4620:	0e c0       	rjmp	.+28     	; 0x463e <report_feedback_message+0x70>
    4622:	8c e0       	ldi	r24, 0x0C	; 12
    4624:	98 e0       	ldi	r25, 0x08	; 8
    4626:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    462a:	09 c0       	rjmp	.+18     	; 0x463e <report_feedback_message+0x70>
    462c:	84 e0       	ldi	r24, 0x04	; 4
    462e:	98 e0       	ldi	r25, 0x08	; 8
    4630:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4634:	04 c0       	rjmp	.+8      	; 0x463e <report_feedback_message+0x70>
    4636:	81 ef       	ldi	r24, 0xF1	; 241
    4638:	97 e0       	ldi	r25, 0x07	; 7
    463a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    463e:	8d ee       	ldi	r24, 0xED	; 237
    4640:	97 e0       	ldi	r25, 0x07	; 7
    4642:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4646:	cf 91       	pop	r28
    4648:	08 95       	ret

0000464a <report_init_message>:
    464a:	80 ed       	ldi	r24, 0xD0	; 208
    464c:	97 e0       	ldi	r25, 0x07	; 7
    464e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4652:	08 95       	ret

00004654 <report_grbl_help>:
    4654:	8c e8       	ldi	r24, 0x8C	; 140
    4656:	96 e0       	ldi	r25, 0x06	; 6
    4658:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    465c:	08 95       	ret

0000465e <report_grbl_settings>:
    465e:	1f 93       	push	r17
    4660:	cf 93       	push	r28
    4662:	df 93       	push	r29
    4664:	88 e8       	ldi	r24, 0x88	; 136
    4666:	96 e0       	ldi	r25, 0x06	; 6
    4668:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    466c:	c5 e8       	ldi	r28, 0x85	; 133
    466e:	d6 e0       	ldi	r29, 0x06	; 6
    4670:	88 a9       	ldd	r24, Y+48	; 0x30
    4672:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4676:	8f e6       	ldi	r24, 0x6F	; 111
    4678:	96 e0       	ldi	r25, 0x06	; 6
    467a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    467e:	8b a9       	ldd	r24, Y+51	; 0x33
    4680:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4684:	81 e5       	ldi	r24, 0x51	; 81
    4686:	96 e0       	ldi	r25, 0x06	; 6
    4688:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    468c:	89 a9       	ldd	r24, Y+49	; 0x31
    468e:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4692:	88 e3       	ldi	r24, 0x38	; 56
    4694:	96 e0       	ldi	r25, 0x06	; 6
    4696:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    469a:	89 a9       	ldd	r24, Y+49	; 0x31
    469c:	0e 94 28 1f 	call	0x3e50	; 0x3e50 <print_uint8_base2>
    46a0:	81 e3       	ldi	r24, 0x31	; 49
    46a2:	96 e0       	ldi	r25, 0x06	; 6
    46a4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    46a8:	8a a9       	ldd	r24, Y+50	; 0x32
    46aa:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    46ae:	89 e1       	ldi	r24, 0x19	; 25
    46b0:	96 e0       	ldi	r25, 0x06	; 6
    46b2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    46b6:	8a a9       	ldd	r24, Y+50	; 0x32
    46b8:	0e 94 28 1f 	call	0x3e50	; 0x3e50 <print_uint8_base2>
    46bc:	82 e1       	ldi	r24, 0x12	; 18
    46be:	96 e0       	ldi	r25, 0x06	; 6
    46c0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    46c4:	8d ad       	ldd	r24, Y+61	; 0x3d
    46c6:	82 fb       	bst	r24, 2
    46c8:	88 27       	eor	r24, r24
    46ca:	80 f9       	bld	r24, 0
    46cc:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    46d0:	81 ef       	ldi	r24, 0xF1	; 241
    46d2:	95 e0       	ldi	r25, 0x05	; 5
    46d4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    46d8:	8d ad       	ldd	r24, Y+61	; 0x3d
    46da:	86 fb       	bst	r24, 6
    46dc:	88 27       	eor	r24, r24
    46de:	80 f9       	bld	r24, 0
    46e0:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    46e4:	81 ed       	ldi	r24, 0xD1	; 209
    46e6:	95 e0       	ldi	r25, 0x05	; 5
    46e8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    46ec:	8d ad       	ldd	r24, Y+61	; 0x3d
    46ee:	88 1f       	adc	r24, r24
    46f0:	88 27       	eor	r24, r24
    46f2:	88 1f       	adc	r24, r24
    46f4:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    46f8:	81 eb       	ldi	r24, 0xB1	; 177
    46fa:	95 e0       	ldi	r25, 0x05	; 5
    46fc:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4700:	8c a9       	ldd	r24, Y+52	; 0x34
    4702:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4706:	8b e9       	ldi	r24, 0x9B	; 155
    4708:	95 e0       	ldi	r25, 0x05	; 5
    470a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    470e:	8c a9       	ldd	r24, Y+52	; 0x34
    4710:	0e 94 28 1f 	call	0x3e50	; 0x3e50 <print_uint8_base2>
    4714:	83 e9       	ldi	r24, 0x93	; 147
    4716:	95 e0       	ldi	r25, 0x05	; 5
    4718:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    471c:	6d a9       	ldd	r22, Y+53	; 0x35
    471e:	7e a9       	ldd	r23, Y+54	; 0x36
    4720:	8f a9       	ldd	r24, Y+55	; 0x37
    4722:	98 ad       	ldd	r25, Y+56	; 0x38
    4724:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    4728:	83 e7       	ldi	r24, 0x73	; 115
    472a:	95 e0       	ldi	r25, 0x05	; 5
    472c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4730:	69 ad       	ldd	r22, Y+57	; 0x39
    4732:	7a ad       	ldd	r23, Y+58	; 0x3a
    4734:	8b ad       	ldd	r24, Y+59	; 0x3b
    4736:	9c ad       	ldd	r25, Y+60	; 0x3c
    4738:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    473c:	88 e5       	ldi	r24, 0x58	; 88
    473e:	95 e0       	ldi	r25, 0x05	; 5
    4740:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4744:	8d ad       	ldd	r24, Y+61	; 0x3d
    4746:	81 70       	andi	r24, 0x01	; 1
    4748:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    474c:	8b e3       	ldi	r24, 0x3B	; 59
    474e:	95 e0       	ldi	r25, 0x05	; 5
    4750:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4754:	8d ad       	ldd	r24, Y+61	; 0x3d
    4756:	85 fb       	bst	r24, 5
    4758:	88 27       	eor	r24, r24
    475a:	80 f9       	bld	r24, 0
    475c:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4760:	80 e2       	ldi	r24, 0x20	; 32
    4762:	95 e0       	ldi	r25, 0x05	; 5
    4764:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4768:	8d ad       	ldd	r24, Y+61	; 0x3d
    476a:	83 fb       	bst	r24, 3
    476c:	88 27       	eor	r24, r24
    476e:	80 f9       	bld	r24, 0
    4770:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4774:	85 e0       	ldi	r24, 0x05	; 5
    4776:	95 e0       	ldi	r25, 0x05	; 5
    4778:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    477c:	8d ad       	ldd	r24, Y+61	; 0x3d
    477e:	82 95       	swap	r24
    4780:	81 70       	andi	r24, 0x01	; 1
    4782:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4786:	89 ee       	ldi	r24, 0xE9	; 233
    4788:	94 e0       	ldi	r25, 0x04	; 4
    478a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    478e:	8e ad       	ldd	r24, Y+62	; 0x3e
    4790:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4794:	8f ec       	ldi	r24, 0xCF	; 207
    4796:	94 e0       	ldi	r25, 0x04	; 4
    4798:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    479c:	8e ad       	ldd	r24, Y+62	; 0x3e
    479e:	0e 94 28 1f 	call	0x3e50	; 0x3e50 <print_uint8_base2>
    47a2:	87 ec       	ldi	r24, 0xC7	; 199
    47a4:	94 e0       	ldi	r25, 0x04	; 4
    47a6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    47aa:	60 91 c4 06 	lds	r22, 0x06C4	; 0x8006c4 <settings+0x3f>
    47ae:	70 91 c5 06 	lds	r23, 0x06C5	; 0x8006c5 <settings+0x40>
    47b2:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <settings+0x41>
    47b6:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <settings+0x42>
    47ba:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    47be:	8a ea       	ldi	r24, 0xAA	; 170
    47c0:	94 e0       	ldi	r25, 0x04	; 4
    47c2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    47c6:	60 91 c8 06 	lds	r22, 0x06C8	; 0x8006c8 <settings+0x43>
    47ca:	70 91 c9 06 	lds	r23, 0x06C9	; 0x8006c9 <settings+0x44>
    47ce:	80 91 ca 06 	lds	r24, 0x06CA	; 0x8006ca <settings+0x45>
    47d2:	90 91 cb 06 	lds	r25, 0x06CB	; 0x8006cb <settings+0x46>
    47d6:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    47da:	8d e8       	ldi	r24, 0x8D	; 141
    47dc:	94 e0       	ldi	r25, 0x04	; 4
    47de:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    47e2:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <settings+0x47>
    47e6:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    47ea:	8e e6       	ldi	r24, 0x6E	; 110
    47ec:	94 e0       	ldi	r25, 0x04	; 4
    47ee:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    47f2:	60 91 ce 06 	lds	r22, 0x06CE	; 0x8006ce <settings+0x49>
    47f6:	70 91 cf 06 	lds	r23, 0x06CF	; 0x8006cf <settings+0x4a>
    47fa:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <settings+0x4b>
    47fe:	90 91 d1 06 	lds	r25, 0x06D1	; 0x8006d1 <settings+0x4c>
    4802:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    4806:	85 e5       	ldi	r24, 0x55	; 85
    4808:	94 e0       	ldi	r25, 0x04	; 4
    480a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    480e:	14 e6       	ldi	r17, 0x64	; 100
    4810:	d0 e0       	ldi	r29, 0x00	; 0
    4812:	f2 c0       	rjmp	.+484    	; 0x49f8 <report_grbl_settings+0x39a>
    4814:	83 e5       	ldi	r24, 0x53	; 83
    4816:	94 e0       	ldi	r25, 0x04	; 4
    4818:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    481c:	8c 2f       	mov	r24, r28
    481e:	81 0f       	add	r24, r17
    4820:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4824:	81 e5       	ldi	r24, 0x51	; 81
    4826:	94 e0       	ldi	r25, 0x04	; 4
    4828:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    482c:	d1 30       	cpi	r29, 0x01	; 1
    482e:	11 f1       	breq	.+68     	; 0x4874 <report_grbl_settings+0x216>
    4830:	30 f0       	brcs	.+12     	; 0x483e <report_grbl_settings+0x1e0>
    4832:	d2 30       	cpi	r29, 0x02	; 2
    4834:	d1 f1       	breq	.+116    	; 0x48aa <report_grbl_settings+0x24c>
    4836:	d3 30       	cpi	r29, 0x03	; 3
    4838:	09 f0       	breq	.+2      	; 0x483c <report_grbl_settings+0x1de>
    483a:	70 c0       	rjmp	.+224    	; 0x491c <report_grbl_settings+0x2be>
    483c:	54 c0       	rjmp	.+168    	; 0x48e6 <report_grbl_settings+0x288>
    483e:	ec 2f       	mov	r30, r28
    4840:	f0 e0       	ldi	r31, 0x00	; 0
    4842:	ee 0f       	add	r30, r30
    4844:	ff 1f       	adc	r31, r31
    4846:	ee 0f       	add	r30, r30
    4848:	ff 1f       	adc	r31, r31
    484a:	eb 57       	subi	r30, 0x7B	; 123
    484c:	f9 4f       	sbci	r31, 0xF9	; 249
    484e:	60 81       	ld	r22, Z
    4850:	71 81       	ldd	r23, Z+1	; 0x01
    4852:	82 81       	ldd	r24, Z+2	; 0x02
    4854:	93 81       	ldd	r25, Z+3	; 0x03
    4856:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    485a:	8e e4       	ldi	r24, 0x4E	; 78
    485c:	94 e0       	ldi	r25, 0x04	; 4
    485e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4862:	c1 30       	cpi	r28, 0x01	; 1
    4864:	09 f4       	brne	.+2      	; 0x4868 <report_grbl_settings+0x20a>
    4866:	6a c0       	rjmp	.+212    	; 0x493c <report_grbl_settings+0x2de>
    4868:	08 f4       	brcc	.+2      	; 0x486c <report_grbl_settings+0x20e>
    486a:	62 c0       	rjmp	.+196    	; 0x4930 <report_grbl_settings+0x2d2>
    486c:	c2 30       	cpi	r28, 0x02	; 2
    486e:	09 f4       	brne	.+2      	; 0x4872 <report_grbl_settings+0x214>
    4870:	6b c0       	rjmp	.+214    	; 0x4948 <report_grbl_settings+0x2ea>
    4872:	7f c0       	rjmp	.+254    	; 0x4972 <report_grbl_settings+0x314>
    4874:	ec 2f       	mov	r30, r28
    4876:	f0 e0       	ldi	r31, 0x00	; 0
    4878:	ee 0f       	add	r30, r30
    487a:	ff 1f       	adc	r31, r31
    487c:	ee 0f       	add	r30, r30
    487e:	ff 1f       	adc	r31, r31
    4880:	ef 56       	subi	r30, 0x6F	; 111
    4882:	f9 4f       	sbci	r31, 0xF9	; 249
    4884:	60 81       	ld	r22, Z
    4886:	71 81       	ldd	r23, Z+1	; 0x01
    4888:	82 81       	ldd	r24, Z+2	; 0x02
    488a:	93 81       	ldd	r25, Z+3	; 0x03
    488c:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    4890:	8e e4       	ldi	r24, 0x4E	; 78
    4892:	94 e0       	ldi	r25, 0x04	; 4
    4894:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4898:	c1 30       	cpi	r28, 0x01	; 1
    489a:	09 f4       	brne	.+2      	; 0x489e <report_grbl_settings+0x240>
    489c:	4f c0       	rjmp	.+158    	; 0x493c <report_grbl_settings+0x2de>
    489e:	08 f4       	brcc	.+2      	; 0x48a2 <report_grbl_settings+0x244>
    48a0:	47 c0       	rjmp	.+142    	; 0x4930 <report_grbl_settings+0x2d2>
    48a2:	c2 30       	cpi	r28, 0x02	; 2
    48a4:	09 f4       	brne	.+2      	; 0x48a8 <report_grbl_settings+0x24a>
    48a6:	50 c0       	rjmp	.+160    	; 0x4948 <report_grbl_settings+0x2ea>
    48a8:	72 c0       	rjmp	.+228    	; 0x498e <report_grbl_settings+0x330>
    48aa:	ec 2f       	mov	r30, r28
    48ac:	f0 e0       	ldi	r31, 0x00	; 0
    48ae:	ee 0f       	add	r30, r30
    48b0:	ff 1f       	adc	r31, r31
    48b2:	ee 0f       	add	r30, r30
    48b4:	ff 1f       	adc	r31, r31
    48b6:	e3 56       	subi	r30, 0x63	; 99
    48b8:	f9 4f       	sbci	r31, 0xF9	; 249
    48ba:	20 e0       	ldi	r18, 0x00	; 0
    48bc:	30 e0       	ldi	r19, 0x00	; 0
    48be:	41 e6       	ldi	r20, 0x61	; 97
    48c0:	55 e4       	ldi	r21, 0x45	; 69
    48c2:	60 81       	ld	r22, Z
    48c4:	71 81       	ldd	r23, Z+1	; 0x01
    48c6:	82 81       	ldd	r24, Z+2	; 0x02
    48c8:	93 81       	ldd	r25, Z+3	; 0x03
    48ca:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    48ce:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    48d2:	8e e4       	ldi	r24, 0x4E	; 78
    48d4:	94 e0       	ldi	r25, 0x04	; 4
    48d6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    48da:	c1 30       	cpi	r28, 0x01	; 1
    48dc:	79 f1       	breq	.+94     	; 0x493c <report_grbl_settings+0x2de>
    48de:	40 f1       	brcs	.+80     	; 0x4930 <report_grbl_settings+0x2d2>
    48e0:	c2 30       	cpi	r28, 0x02	; 2
    48e2:	91 f1       	breq	.+100    	; 0x4948 <report_grbl_settings+0x2ea>
    48e4:	62 c0       	rjmp	.+196    	; 0x49aa <report_grbl_settings+0x34c>
    48e6:	ec 2f       	mov	r30, r28
    48e8:	f0 e0       	ldi	r31, 0x00	; 0
    48ea:	ee 0f       	add	r30, r30
    48ec:	ff 1f       	adc	r31, r31
    48ee:	ee 0f       	add	r30, r30
    48f0:	ff 1f       	adc	r31, r31
    48f2:	e7 55       	subi	r30, 0x57	; 87
    48f4:	f9 4f       	sbci	r31, 0xF9	; 249
    48f6:	80 81       	ld	r24, Z
    48f8:	91 81       	ldd	r25, Z+1	; 0x01
    48fa:	a2 81       	ldd	r26, Z+2	; 0x02
    48fc:	b3 81       	ldd	r27, Z+3	; 0x03
    48fe:	bc 01       	movw	r22, r24
    4900:	cd 01       	movw	r24, r26
    4902:	90 58       	subi	r25, 0x80	; 128
    4904:	0e 94 15 20 	call	0x402a	; 0x402a <printFloat_SettingValue>
    4908:	8e e4       	ldi	r24, 0x4E	; 78
    490a:	94 e0       	ldi	r25, 0x04	; 4
    490c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4910:	c1 30       	cpi	r28, 0x01	; 1
    4912:	a1 f0       	breq	.+40     	; 0x493c <report_grbl_settings+0x2de>
    4914:	68 f0       	brcs	.+26     	; 0x4930 <report_grbl_settings+0x2d2>
    4916:	c2 30       	cpi	r28, 0x02	; 2
    4918:	b9 f0       	breq	.+46     	; 0x4948 <report_grbl_settings+0x2ea>
    491a:	55 c0       	rjmp	.+170    	; 0x49c6 <report_grbl_settings+0x368>
    491c:	8e e4       	ldi	r24, 0x4E	; 78
    491e:	94 e0       	ldi	r25, 0x04	; 4
    4920:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4924:	c1 30       	cpi	r28, 0x01	; 1
    4926:	51 f0       	breq	.+20     	; 0x493c <report_grbl_settings+0x2de>
    4928:	18 f0       	brcs	.+6      	; 0x4930 <report_grbl_settings+0x2d2>
    492a:	c2 30       	cpi	r28, 0x02	; 2
    492c:	69 f0       	breq	.+26     	; 0x4948 <report_grbl_settings+0x2ea>
    492e:	19 c0       	rjmp	.+50     	; 0x4962 <report_grbl_settings+0x304>
    4930:	8c e4       	ldi	r24, 0x4C	; 76
    4932:	94 e0       	ldi	r25, 0x04	; 4
    4934:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4938:	c0 e0       	ldi	r28, 0x00	; 0
    493a:	66 c0       	rjmp	.+204    	; 0x4a08 <report_grbl_settings+0x3aa>
    493c:	8a e4       	ldi	r24, 0x4A	; 74
    493e:	94 e0       	ldi	r25, 0x04	; 4
    4940:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4944:	c1 e0       	ldi	r28, 0x01	; 1
    4946:	60 c0       	rjmp	.+192    	; 0x4a08 <report_grbl_settings+0x3aa>
    4948:	88 e4       	ldi	r24, 0x48	; 72
    494a:	94 e0       	ldi	r25, 0x04	; 4
    494c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4950:	c2 e0       	ldi	r28, 0x02	; 2
    4952:	d1 30       	cpi	r29, 0x01	; 1
    4954:	d9 f0       	breq	.+54     	; 0x498c <report_grbl_settings+0x32e>
    4956:	68 f0       	brcs	.+26     	; 0x4972 <report_grbl_settings+0x314>
    4958:	d2 30       	cpi	r29, 0x02	; 2
    495a:	31 f1       	breq	.+76     	; 0x49a8 <report_grbl_settings+0x34a>
    495c:	d3 30       	cpi	r29, 0x03	; 3
    495e:	91 f1       	breq	.+100    	; 0x49c4 <report_grbl_settings+0x366>
    4960:	90 c0       	rjmp	.+288    	; 0x4a82 <report_grbl_settings+0x424>
    4962:	d1 30       	cpi	r29, 0x01	; 1
    4964:	a1 f0       	breq	.+40     	; 0x498e <report_grbl_settings+0x330>
    4966:	28 f0       	brcs	.+10     	; 0x4972 <report_grbl_settings+0x314>
    4968:	d2 30       	cpi	r29, 0x02	; 2
    496a:	f9 f0       	breq	.+62     	; 0x49aa <report_grbl_settings+0x34c>
    496c:	d3 30       	cpi	r29, 0x03	; 3
    496e:	b9 f5       	brne	.+110    	; 0x49de <report_grbl_settings+0x380>
    4970:	2a c0       	rjmp	.+84     	; 0x49c6 <report_grbl_settings+0x368>
    4972:	8e e3       	ldi	r24, 0x3E	; 62
    4974:	94 e0       	ldi	r25, 0x04	; 4
    4976:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    497a:	87 e0       	ldi	r24, 0x07	; 7
    497c:	94 e0       	ldi	r25, 0x04	; 4
    497e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4982:	cf 5f       	subi	r28, 0xFF	; 255
    4984:	c3 30       	cpi	r28, 0x03	; 3
    4986:	08 f4       	brcc	.+2      	; 0x498a <report_grbl_settings+0x32c>
    4988:	55 c0       	rjmp	.+170    	; 0x4a34 <report_grbl_settings+0x3d6>
    498a:	31 c0       	rjmp	.+98     	; 0x49ee <report_grbl_settings+0x390>
    498c:	c2 e0       	ldi	r28, 0x02	; 2
    498e:	8c e2       	ldi	r24, 0x2C	; 44
    4990:	94 e0       	ldi	r25, 0x04	; 4
    4992:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4996:	87 e0       	ldi	r24, 0x07	; 7
    4998:	94 e0       	ldi	r25, 0x04	; 4
    499a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    499e:	cf 5f       	subi	r28, 0xFF	; 255
    49a0:	c3 30       	cpi	r28, 0x03	; 3
    49a2:	08 f4       	brcc	.+2      	; 0x49a6 <report_grbl_settings+0x348>
    49a4:	54 c0       	rjmp	.+168    	; 0x4a4e <report_grbl_settings+0x3f0>
    49a6:	23 c0       	rjmp	.+70     	; 0x49ee <report_grbl_settings+0x390>
    49a8:	c2 e0       	ldi	r28, 0x02	; 2
    49aa:	8b e1       	ldi	r24, 0x1B	; 27
    49ac:	94 e0       	ldi	r25, 0x04	; 4
    49ae:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    49b2:	87 e0       	ldi	r24, 0x07	; 7
    49b4:	94 e0       	ldi	r25, 0x04	; 4
    49b6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    49ba:	cf 5f       	subi	r28, 0xFF	; 255
    49bc:	c3 30       	cpi	r28, 0x03	; 3
    49be:	08 f4       	brcc	.+2      	; 0x49c2 <report_grbl_settings+0x364>
    49c0:	53 c0       	rjmp	.+166    	; 0x4a68 <report_grbl_settings+0x40a>
    49c2:	15 c0       	rjmp	.+42     	; 0x49ee <report_grbl_settings+0x390>
    49c4:	c2 e0       	ldi	r28, 0x02	; 2
    49c6:	8b e0       	ldi	r24, 0x0B	; 11
    49c8:	94 e0       	ldi	r25, 0x04	; 4
    49ca:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    49ce:	87 e0       	ldi	r24, 0x07	; 7
    49d0:	94 e0       	ldi	r25, 0x04	; 4
    49d2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    49d6:	cf 5f       	subi	r28, 0xFF	; 255
    49d8:	c3 30       	cpi	r28, 0x03	; 3
    49da:	f8 f0       	brcs	.+62     	; 0x4a1a <report_grbl_settings+0x3bc>
    49dc:	08 c0       	rjmp	.+16     	; 0x49ee <report_grbl_settings+0x390>
    49de:	87 e0       	ldi	r24, 0x07	; 7
    49e0:	94 e0       	ldi	r25, 0x04	; 4
    49e2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    49e6:	cf 5f       	subi	r28, 0xFF	; 255
    49e8:	c3 30       	cpi	r28, 0x03	; 3
    49ea:	08 f4       	brcc	.+2      	; 0x49ee <report_grbl_settings+0x390>
    49ec:	13 cf       	rjmp	.-474    	; 0x4814 <report_grbl_settings+0x1b6>
    49ee:	16 5f       	subi	r17, 0xF6	; 246
    49f0:	df 5f       	subi	r29, 0xFF	; 255
    49f2:	1c 38       	cpi	r17, 0x8C	; 140
    49f4:	09 f4       	brne	.+2      	; 0x49f8 <report_grbl_settings+0x39a>
    49f6:	4a c0       	rjmp	.+148    	; 0x4a8c <report_grbl_settings+0x42e>
    49f8:	c0 e0       	ldi	r28, 0x00	; 0
    49fa:	0c cf       	rjmp	.-488    	; 0x4814 <report_grbl_settings+0x1b6>
    49fc:	87 e0       	ldi	r24, 0x07	; 7
    49fe:	94 e0       	ldi	r25, 0x04	; 4
    4a00:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a04:	cf 5f       	subi	r28, 0xFF	; 255
    4a06:	06 cf       	rjmp	.-500    	; 0x4814 <report_grbl_settings+0x1b6>
    4a08:	d1 30       	cpi	r29, 0x01	; 1
    4a0a:	09 f2       	breq	.-126    	; 0x498e <report_grbl_settings+0x330>
    4a0c:	08 f4       	brcc	.+2      	; 0x4a10 <report_grbl_settings+0x3b2>
    4a0e:	b1 cf       	rjmp	.-158    	; 0x4972 <report_grbl_settings+0x314>
    4a10:	d2 30       	cpi	r29, 0x02	; 2
    4a12:	59 f2       	breq	.-106    	; 0x49aa <report_grbl_settings+0x34c>
    4a14:	d3 30       	cpi	r29, 0x03	; 3
    4a16:	91 f7       	brne	.-28     	; 0x49fc <report_grbl_settings+0x39e>
    4a18:	d6 cf       	rjmp	.-84     	; 0x49c6 <report_grbl_settings+0x368>
    4a1a:	83 e5       	ldi	r24, 0x53	; 83
    4a1c:	94 e0       	ldi	r25, 0x04	; 4
    4a1e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a22:	81 2f       	mov	r24, r17
    4a24:	8c 0f       	add	r24, r28
    4a26:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4a2a:	81 e5       	ldi	r24, 0x51	; 81
    4a2c:	94 e0       	ldi	r25, 0x04	; 4
    4a2e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a32:	59 cf       	rjmp	.-334    	; 0x48e6 <report_grbl_settings+0x288>
    4a34:	83 e5       	ldi	r24, 0x53	; 83
    4a36:	94 e0       	ldi	r25, 0x04	; 4
    4a38:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a3c:	81 2f       	mov	r24, r17
    4a3e:	8c 0f       	add	r24, r28
    4a40:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4a44:	81 e5       	ldi	r24, 0x51	; 81
    4a46:	94 e0       	ldi	r25, 0x04	; 4
    4a48:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a4c:	f8 ce       	rjmp	.-528    	; 0x483e <report_grbl_settings+0x1e0>
    4a4e:	83 e5       	ldi	r24, 0x53	; 83
    4a50:	94 e0       	ldi	r25, 0x04	; 4
    4a52:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a56:	81 2f       	mov	r24, r17
    4a58:	8c 0f       	add	r24, r28
    4a5a:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4a5e:	81 e5       	ldi	r24, 0x51	; 81
    4a60:	94 e0       	ldi	r25, 0x04	; 4
    4a62:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a66:	06 cf       	rjmp	.-500    	; 0x4874 <report_grbl_settings+0x216>
    4a68:	83 e5       	ldi	r24, 0x53	; 83
    4a6a:	94 e0       	ldi	r25, 0x04	; 4
    4a6c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a70:	81 2f       	mov	r24, r17
    4a72:	8c 0f       	add	r24, r28
    4a74:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4a78:	81 e5       	ldi	r24, 0x51	; 81
    4a7a:	94 e0       	ldi	r25, 0x04	; 4
    4a7c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a80:	14 cf       	rjmp	.-472    	; 0x48aa <report_grbl_settings+0x24c>
    4a82:	87 e0       	ldi	r24, 0x07	; 7
    4a84:	94 e0       	ldi	r25, 0x04	; 4
    4a86:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a8a:	b1 cf       	rjmp	.-158    	; 0x49ee <report_grbl_settings+0x390>
    4a8c:	df 91       	pop	r29
    4a8e:	cf 91       	pop	r28
    4a90:	1f 91       	pop	r17
    4a92:	08 95       	ret

00004a94 <report_probe_parameters>:
    4a94:	cf 93       	push	r28
    4a96:	81 e0       	ldi	r24, 0x01	; 1
    4a98:	94 e0       	ldi	r25, 0x04	; 4
    4a9a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4a9e:	c0 e0       	ldi	r28, 0x00	; 0
    4aa0:	6c 2f       	mov	r22, r28
    4aa2:	86 eb       	ldi	r24, 0xB6	; 182
    4aa4:	95 e0       	ldi	r25, 0x05	; 5
    4aa6:	0e 94 95 38 	call	0x712a	; 0x712a <system_convert_axis_steps_to_mpos>
    4aaa:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
    4aae:	c2 30       	cpi	r28, 0x02	; 2
    4ab0:	20 f4       	brcc	.+8      	; 0x4aba <report_probe_parameters+0x26>
    4ab2:	8f ef       	ldi	r24, 0xFF	; 255
    4ab4:	93 e0       	ldi	r25, 0x03	; 3
    4ab6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4aba:	cf 5f       	subi	r28, 0xFF	; 255
    4abc:	c3 30       	cpi	r28, 0x03	; 3
    4abe:	81 f7       	brne	.-32     	; 0x4aa0 <report_probe_parameters+0xc>
    4ac0:	8d ef       	ldi	r24, 0xFD	; 253
    4ac2:	93 e0       	ldi	r25, 0x03	; 3
    4ac4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ac8:	80 91 c2 05 	lds	r24, 0x05C2	; 0x8005c2 <sys+0x1c>
    4acc:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4ad0:	89 ef       	ldi	r24, 0xF9	; 249
    4ad2:	93 e0       	ldi	r25, 0x03	; 3
    4ad4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ad8:	cf 91       	pop	r28
    4ada:	08 95       	ret

00004adc <report_ngc_parameters>:
    4adc:	ef 92       	push	r14
    4ade:	ff 92       	push	r15
    4ae0:	0f 93       	push	r16
    4ae2:	1f 93       	push	r17
    4ae4:	cf 93       	push	r28
    4ae6:	df 93       	push	r29
    4ae8:	cd b7       	in	r28, 0x3d	; 61
    4aea:	de b7       	in	r29, 0x3e	; 62
    4aec:	2c 97       	sbiw	r28, 0x0c	; 12
    4aee:	0f b6       	in	r0, 0x3f	; 63
    4af0:	f8 94       	cli
    4af2:	de bf       	out	0x3e, r29	; 62
    4af4:	0f be       	out	0x3f, r0	; 63
    4af6:	cd bf       	out	0x3d, r28	; 61
    4af8:	00 e0       	ldi	r16, 0x00	; 0
    4afa:	be 01       	movw	r22, r28
    4afc:	6f 5f       	subi	r22, 0xFF	; 255
    4afe:	7f 4f       	sbci	r23, 0xFF	; 255
    4b00:	80 2f       	mov	r24, r16
    4b02:	0e 94 22 2a 	call	0x5444	; 0x5444 <settings_read_coord_data>
    4b06:	81 11       	cpse	r24, r1
    4b08:	04 c0       	rjmp	.+8      	; 0x4b12 <report_ngc_parameters+0x36>
    4b0a:	87 e0       	ldi	r24, 0x07	; 7
    4b0c:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
    4b10:	6e c0       	rjmp	.+220    	; 0x4bee <report_ngc_parameters+0x112>
    4b12:	86 ef       	ldi	r24, 0xF6	; 246
    4b14:	93 e0       	ldi	r25, 0x03	; 3
    4b16:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b1a:	06 30       	cpi	r16, 0x06	; 6
    4b1c:	19 f0       	breq	.+6      	; 0x4b24 <report_ngc_parameters+0x48>
    4b1e:	07 30       	cpi	r16, 0x07	; 7
    4b20:	31 f0       	breq	.+12     	; 0x4b2e <report_ngc_parameters+0x52>
    4b22:	0a c0       	rjmp	.+20     	; 0x4b38 <report_ngc_parameters+0x5c>
    4b24:	83 ef       	ldi	r24, 0xF3	; 243
    4b26:	93 e0       	ldi	r25, 0x03	; 3
    4b28:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b2c:	09 c0       	rjmp	.+18     	; 0x4b40 <report_ngc_parameters+0x64>
    4b2e:	80 ef       	ldi	r24, 0xF0	; 240
    4b30:	93 e0       	ldi	r25, 0x03	; 3
    4b32:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b36:	04 c0       	rjmp	.+8      	; 0x4b40 <report_ngc_parameters+0x64>
    4b38:	86 e3       	ldi	r24, 0x36	; 54
    4b3a:	80 0f       	add	r24, r16
    4b3c:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4b40:	8e ee       	ldi	r24, 0xEE	; 238
    4b42:	93 e0       	ldi	r25, 0x03	; 3
    4b44:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b48:	ce 01       	movw	r24, r28
    4b4a:	01 96       	adiw	r24, 0x01	; 1
    4b4c:	7c 01       	movw	r14, r24
    4b4e:	10 e0       	ldi	r17, 0x00	; 0
    4b50:	f7 01       	movw	r30, r14
    4b52:	61 91       	ld	r22, Z+
    4b54:	71 91       	ld	r23, Z+
    4b56:	81 91       	ld	r24, Z+
    4b58:	91 91       	ld	r25, Z+
    4b5a:	7f 01       	movw	r14, r30
    4b5c:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
    4b60:	12 30       	cpi	r17, 0x02	; 2
    4b62:	28 f4       	brcc	.+10     	; 0x4b6e <report_ngc_parameters+0x92>
    4b64:	8c ee       	ldi	r24, 0xEC	; 236
    4b66:	93 e0       	ldi	r25, 0x03	; 3
    4b68:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b6c:	04 c0       	rjmp	.+8      	; 0x4b76 <report_ngc_parameters+0x9a>
    4b6e:	88 ee       	ldi	r24, 0xE8	; 232
    4b70:	93 e0       	ldi	r25, 0x03	; 3
    4b72:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b76:	1f 5f       	subi	r17, 0xFF	; 255
    4b78:	13 30       	cpi	r17, 0x03	; 3
    4b7a:	51 f7       	brne	.-44     	; 0x4b50 <report_ngc_parameters+0x74>
    4b7c:	0f 5f       	subi	r16, 0xFF	; 255
    4b7e:	08 30       	cpi	r16, 0x08	; 8
    4b80:	09 f0       	breq	.+2      	; 0x4b84 <report_ngc_parameters+0xa8>
    4b82:	bb cf       	rjmp	.-138    	; 0x4afa <report_ngc_parameters+0x1e>
    4b84:	82 ee       	ldi	r24, 0xE2	; 226
    4b86:	93 e0       	ldi	r25, 0x03	; 3
    4b88:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4b8c:	0f 2e       	mov	r0, r31
    4b8e:	fd e5       	ldi	r31, 0x5D	; 93
    4b90:	ef 2e       	mov	r14, r31
    4b92:	f5 e0       	ldi	r31, 0x05	; 5
    4b94:	ff 2e       	mov	r15, r31
    4b96:	f0 2d       	mov	r31, r0
    4b98:	10 e0       	ldi	r17, 0x00	; 0
    4b9a:	f7 01       	movw	r30, r14
    4b9c:	61 91       	ld	r22, Z+
    4b9e:	71 91       	ld	r23, Z+
    4ba0:	81 91       	ld	r24, Z+
    4ba2:	91 91       	ld	r25, Z+
    4ba4:	7f 01       	movw	r14, r30
    4ba6:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
    4baa:	12 30       	cpi	r17, 0x02	; 2
    4bac:	28 f4       	brcc	.+10     	; 0x4bb8 <report_ngc_parameters+0xdc>
    4bae:	80 ee       	ldi	r24, 0xE0	; 224
    4bb0:	93 e0       	ldi	r25, 0x03	; 3
    4bb2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4bb6:	04 c0       	rjmp	.+8      	; 0x4bc0 <report_ngc_parameters+0xe4>
    4bb8:	8c ed       	ldi	r24, 0xDC	; 220
    4bba:	93 e0       	ldi	r25, 0x03	; 3
    4bbc:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4bc0:	1f 5f       	subi	r17, 0xFF	; 255
    4bc2:	13 30       	cpi	r17, 0x03	; 3
    4bc4:	51 f7       	brne	.-44     	; 0x4b9a <report_ngc_parameters+0xbe>
    4bc6:	86 ed       	ldi	r24, 0xD6	; 214
    4bc8:	93 e0       	ldi	r25, 0x03	; 3
    4bca:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4bce:	60 91 69 05 	lds	r22, 0x0569	; 0x800569 <gc_state+0x3b>
    4bd2:	70 91 6a 05 	lds	r23, 0x056A	; 0x80056a <gc_state+0x3c>
    4bd6:	80 91 6b 05 	lds	r24, 0x056B	; 0x80056b <gc_state+0x3d>
    4bda:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <gc_state+0x3e>
    4bde:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
    4be2:	82 ed       	ldi	r24, 0xD2	; 210
    4be4:	93 e0       	ldi	r25, 0x03	; 3
    4be6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4bea:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <report_probe_parameters>
    4bee:	2c 96       	adiw	r28, 0x0c	; 12
    4bf0:	0f b6       	in	r0, 0x3f	; 63
    4bf2:	f8 94       	cli
    4bf4:	de bf       	out	0x3e, r29	; 62
    4bf6:	0f be       	out	0x3f, r0	; 63
    4bf8:	cd bf       	out	0x3d, r28	; 61
    4bfa:	df 91       	pop	r29
    4bfc:	cf 91       	pop	r28
    4bfe:	1f 91       	pop	r17
    4c00:	0f 91       	pop	r16
    4c02:	ff 90       	pop	r15
    4c04:	ef 90       	pop	r14
    4c06:	08 95       	ret

00004c08 <report_gcode_modes>:
    4c08:	cf 93       	push	r28
    4c0a:	df 93       	push	r29
    4c0c:	80 ed       	ldi	r24, 0xD0	; 208
    4c0e:	93 e0       	ldi	r25, 0x03	; 3
    4c10:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c14:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <gc_state>
    4c18:	82 30       	cpi	r24, 0x02	; 2
    4c1a:	a9 f0       	breq	.+42     	; 0x4c46 <report_gcode_modes+0x3e>
    4c1c:	28 f4       	brcc	.+10     	; 0x4c28 <report_gcode_modes+0x20>
    4c1e:	88 23       	and	r24, r24
    4c20:	41 f0       	breq	.+16     	; 0x4c32 <report_gcode_modes+0x2a>
    4c22:	81 30       	cpi	r24, 0x01	; 1
    4c24:	59 f0       	breq	.+22     	; 0x4c3c <report_gcode_modes+0x34>
    4c26:	1e c0       	rjmp	.+60     	; 0x4c64 <report_gcode_modes+0x5c>
    4c28:	83 30       	cpi	r24, 0x03	; 3
    4c2a:	91 f0       	breq	.+36     	; 0x4c50 <report_gcode_modes+0x48>
    4c2c:	88 30       	cpi	r24, 0x08	; 8
    4c2e:	a9 f0       	breq	.+42     	; 0x4c5a <report_gcode_modes+0x52>
    4c30:	19 c0       	rjmp	.+50     	; 0x4c64 <report_gcode_modes+0x5c>
    4c32:	8d ec       	ldi	r24, 0xCD	; 205
    4c34:	93 e0       	ldi	r25, 0x03	; 3
    4c36:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c3a:	1d c0       	rjmp	.+58     	; 0x4c76 <report_gcode_modes+0x6e>
    4c3c:	8a ec       	ldi	r24, 0xCA	; 202
    4c3e:	93 e0       	ldi	r25, 0x03	; 3
    4c40:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c44:	18 c0       	rjmp	.+48     	; 0x4c76 <report_gcode_modes+0x6e>
    4c46:	87 ec       	ldi	r24, 0xC7	; 199
    4c48:	93 e0       	ldi	r25, 0x03	; 3
    4c4a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c4e:	13 c0       	rjmp	.+38     	; 0x4c76 <report_gcode_modes+0x6e>
    4c50:	84 ec       	ldi	r24, 0xC4	; 196
    4c52:	93 e0       	ldi	r25, 0x03	; 3
    4c54:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c58:	0e c0       	rjmp	.+28     	; 0x4c76 <report_gcode_modes+0x6e>
    4c5a:	80 ec       	ldi	r24, 0xC0	; 192
    4c5c:	93 e0       	ldi	r25, 0x03	; 3
    4c5e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c62:	09 c0       	rjmp	.+18     	; 0x4c76 <report_gcode_modes+0x6e>
    4c64:	8b eb       	ldi	r24, 0xBB	; 187
    4c66:	93 e0       	ldi	r25, 0x03	; 3
    4c68:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c6c:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <gc_state>
    4c70:	82 50       	subi	r24, 0x02	; 2
    4c72:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4c76:	88 eb       	ldi	r24, 0xB8	; 184
    4c78:	93 e0       	ldi	r25, 0x03	; 3
    4c7a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4c7e:	ce e2       	ldi	r28, 0x2E	; 46
    4c80:	d5 e0       	ldi	r29, 0x05	; 5
    4c82:	8e 81       	ldd	r24, Y+6	; 0x06
    4c84:	8a 5c       	subi	r24, 0xCA	; 202
    4c86:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4c8a:	8c 81       	ldd	r24, Y+4	; 0x04
    4c8c:	81 30       	cpi	r24, 0x01	; 1
    4c8e:	49 f0       	breq	.+18     	; 0x4ca2 <report_gcode_modes+0x9a>
    4c90:	18 f0       	brcs	.+6      	; 0x4c98 <report_gcode_modes+0x90>
    4c92:	82 30       	cpi	r24, 0x02	; 2
    4c94:	59 f0       	breq	.+22     	; 0x4cac <report_gcode_modes+0xa4>
    4c96:	0e c0       	rjmp	.+28     	; 0x4cb4 <report_gcode_modes+0xac>
    4c98:	83 eb       	ldi	r24, 0xB3	; 179
    4c9a:	93 e0       	ldi	r25, 0x03	; 3
    4c9c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ca0:	09 c0       	rjmp	.+18     	; 0x4cb4 <report_gcode_modes+0xac>
    4ca2:	8e ea       	ldi	r24, 0xAE	; 174
    4ca4:	93 e0       	ldi	r25, 0x03	; 3
    4ca6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4caa:	04 c0       	rjmp	.+8      	; 0x4cb4 <report_gcode_modes+0xac>
    4cac:	89 ea       	ldi	r24, 0xA9	; 169
    4cae:	93 e0       	ldi	r25, 0x03	; 3
    4cb0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4cb4:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <gc_state+0x2>
    4cb8:	81 11       	cpse	r24, r1
    4cba:	05 c0       	rjmp	.+10     	; 0x4cc6 <report_gcode_modes+0xbe>
    4cbc:	84 ea       	ldi	r24, 0xA4	; 164
    4cbe:	93 e0       	ldi	r25, 0x03	; 3
    4cc0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4cc4:	04 c0       	rjmp	.+8      	; 0x4cce <report_gcode_modes+0xc6>
    4cc6:	8f e9       	ldi	r24, 0x9F	; 159
    4cc8:	93 e0       	ldi	r25, 0x03	; 3
    4cca:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4cce:	80 91 31 05 	lds	r24, 0x0531	; 0x800531 <gc_state+0x3>
    4cd2:	81 11       	cpse	r24, r1
    4cd4:	05 c0       	rjmp	.+10     	; 0x4ce0 <report_gcode_modes+0xd8>
    4cd6:	8a e9       	ldi	r24, 0x9A	; 154
    4cd8:	93 e0       	ldi	r25, 0x03	; 3
    4cda:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4cde:	04 c0       	rjmp	.+8      	; 0x4ce8 <report_gcode_modes+0xe0>
    4ce0:	85 e9       	ldi	r24, 0x95	; 149
    4ce2:	93 e0       	ldi	r25, 0x03	; 3
    4ce4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ce8:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <gc_state+0x1>
    4cec:	81 30       	cpi	r24, 0x01	; 1
    4cee:	29 f4       	brne	.+10     	; 0x4cfa <report_gcode_modes+0xf2>
    4cf0:	80 e9       	ldi	r24, 0x90	; 144
    4cf2:	93 e0       	ldi	r25, 0x03	; 3
    4cf4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4cf8:	04 c0       	rjmp	.+8      	; 0x4d02 <report_gcode_modes+0xfa>
    4cfa:	8b e8       	ldi	r24, 0x8B	; 139
    4cfc:	93 e0       	ldi	r25, 0x03	; 3
    4cfe:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d02:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <gc_state+0x7>
    4d06:	81 30       	cpi	r24, 0x01	; 1
    4d08:	49 f0       	breq	.+18     	; 0x4d1c <report_gcode_modes+0x114>
    4d0a:	18 f0       	brcs	.+6      	; 0x4d12 <report_gcode_modes+0x10a>
    4d0c:	82 30       	cpi	r24, 0x02	; 2
    4d0e:	59 f0       	breq	.+22     	; 0x4d26 <report_gcode_modes+0x11e>
    4d10:	0e c0       	rjmp	.+28     	; 0x4d2e <report_gcode_modes+0x126>
    4d12:	87 e8       	ldi	r24, 0x87	; 135
    4d14:	93 e0       	ldi	r25, 0x03	; 3
    4d16:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d1a:	09 c0       	rjmp	.+18     	; 0x4d2e <report_gcode_modes+0x126>
    4d1c:	83 e8       	ldi	r24, 0x83	; 131
    4d1e:	93 e0       	ldi	r25, 0x03	; 3
    4d20:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d24:	04 c0       	rjmp	.+8      	; 0x4d2e <report_gcode_modes+0x126>
    4d26:	8f e7       	ldi	r24, 0x7F	; 127
    4d28:	93 e0       	ldi	r25, 0x03	; 3
    4d2a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d2e:	80 91 37 05 	lds	r24, 0x0537	; 0x800537 <gc_state+0x9>
    4d32:	81 30       	cpi	r24, 0x01	; 1
    4d34:	21 f0       	breq	.+8      	; 0x4d3e <report_gcode_modes+0x136>
    4d36:	68 f0       	brcs	.+26     	; 0x4d52 <report_gcode_modes+0x14a>
    4d38:	82 30       	cpi	r24, 0x02	; 2
    4d3a:	31 f0       	breq	.+12     	; 0x4d48 <report_gcode_modes+0x140>
    4d3c:	0e c0       	rjmp	.+28     	; 0x4d5a <report_gcode_modes+0x152>
    4d3e:	8b e7       	ldi	r24, 0x7B	; 123
    4d40:	93 e0       	ldi	r25, 0x03	; 3
    4d42:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d46:	09 c0       	rjmp	.+18     	; 0x4d5a <report_gcode_modes+0x152>
    4d48:	87 e7       	ldi	r24, 0x77	; 119
    4d4a:	93 e0       	ldi	r25, 0x03	; 3
    4d4c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d50:	04 c0       	rjmp	.+8      	; 0x4d5a <report_gcode_modes+0x152>
    4d52:	83 e7       	ldi	r24, 0x73	; 115
    4d54:	93 e0       	ldi	r25, 0x03	; 3
    4d56:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d5a:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <gc_state+0x8>
    4d5e:	88 23       	and	r24, r24
    4d60:	19 f0       	breq	.+6      	; 0x4d68 <report_gcode_modes+0x160>
    4d62:	82 30       	cpi	r24, 0x02	; 2
    4d64:	31 f0       	breq	.+12     	; 0x4d72 <report_gcode_modes+0x16a>
    4d66:	09 c0       	rjmp	.+18     	; 0x4d7a <report_gcode_modes+0x172>
    4d68:	8f e6       	ldi	r24, 0x6F	; 111
    4d6a:	93 e0       	ldi	r25, 0x03	; 3
    4d6c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d70:	04 c0       	rjmp	.+8      	; 0x4d7a <report_gcode_modes+0x172>
    4d72:	8b e6       	ldi	r24, 0x6B	; 107
    4d74:	93 e0       	ldi	r25, 0x03	; 3
    4d76:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d7a:	88 e6       	ldi	r24, 0x68	; 104
    4d7c:	93 e0       	ldi	r25, 0x03	; 3
    4d7e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d82:	ce e2       	ldi	r28, 0x2E	; 46
    4d84:	d5 e0       	ldi	r29, 0x05	; 5
    4d86:	8a 89       	ldd	r24, Y+18	; 0x12
    4d88:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4d8c:	85 e6       	ldi	r24, 0x65	; 101
    4d8e:	93 e0       	ldi	r25, 0x03	; 3
    4d90:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4d94:	6e 85       	ldd	r22, Y+14	; 0x0e
    4d96:	7f 85       	ldd	r23, Y+15	; 0x0f
    4d98:	88 89       	ldd	r24, Y+16	; 0x10
    4d9a:	99 89       	ldd	r25, Y+17	; 0x11
    4d9c:	0e 94 03 20 	call	0x4006	; 0x4006 <printFloat_RateValue>
    4da0:	82 e6       	ldi	r24, 0x62	; 98
    4da2:	93 e0       	ldi	r25, 0x03	; 3
    4da4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4da8:	6a 85       	ldd	r22, Y+10	; 0x0a
    4daa:	7b 85       	ldd	r23, Y+11	; 0x0b
    4dac:	8c 85       	ldd	r24, Y+12	; 0x0c
    4dae:	9d 85       	ldd	r25, Y+13	; 0x0d
    4db0:	0e 94 03 20 	call	0x4006	; 0x4006 <printFloat_RateValue>
    4db4:	8e e5       	ldi	r24, 0x5E	; 94
    4db6:	93 e0       	ldi	r25, 0x03	; 3
    4db8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4dbc:	df 91       	pop	r29
    4dbe:	cf 91       	pop	r28
    4dc0:	08 95       	ret

00004dc2 <report_startup_line>:
    4dc2:	1f 93       	push	r17
    4dc4:	cf 93       	push	r28
    4dc6:	df 93       	push	r29
    4dc8:	18 2f       	mov	r17, r24
    4dca:	eb 01       	movw	r28, r22
    4dcc:	8b e5       	ldi	r24, 0x5B	; 91
    4dce:	93 e0       	ldi	r25, 0x03	; 3
    4dd0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4dd4:	81 2f       	mov	r24, r17
    4dd6:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    4dda:	89 e5       	ldi	r24, 0x59	; 89
    4ddc:	93 e0       	ldi	r25, 0x03	; 3
    4dde:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4de2:	ce 01       	movw	r24, r28
    4de4:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <printString>
    4de8:	86 e5       	ldi	r24, 0x56	; 86
    4dea:	93 e0       	ldi	r25, 0x03	; 3
    4dec:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4df0:	df 91       	pop	r29
    4df2:	cf 91       	pop	r28
    4df4:	1f 91       	pop	r17
    4df6:	08 95       	ret

00004df8 <report_build_info>:
    4df8:	cf 93       	push	r28
    4dfa:	df 93       	push	r29
    4dfc:	ec 01       	movw	r28, r24
    4dfe:	86 e4       	ldi	r24, 0x46	; 70
    4e00:	93 e0       	ldi	r25, 0x03	; 3
    4e02:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e06:	ce 01       	movw	r24, r28
    4e08:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <printString>
    4e0c:	82 e4       	ldi	r24, 0x42	; 66
    4e0e:	93 e0       	ldi	r25, 0x03	; 3
    4e10:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e14:	df 91       	pop	r29
    4e16:	cf 91       	pop	r28
    4e18:	08 95       	ret

00004e1a <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    4e1a:	af 92       	push	r10
    4e1c:	bf 92       	push	r11
    4e1e:	cf 92       	push	r12
    4e20:	df 92       	push	r13
    4e22:	ff 92       	push	r15
    4e24:	0f 93       	push	r16
    4e26:	1f 93       	push	r17
    4e28:	cf 93       	push	r28
    4e2a:	df 93       	push	r29
    4e2c:	cd b7       	in	r28, 0x3d	; 61
    4e2e:	de b7       	in	r29, 0x3e	; 62
    4e30:	68 97       	sbiw	r28, 0x18	; 24
    4e32:	0f b6       	in	r0, 0x3f	; 63
    4e34:	f8 94       	cli
    4e36:	de bf       	out	0x3e, r29	; 62
    4e38:	0f be       	out	0x3f, r0	; 63
    4e3a:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    4e3c:	8c e0       	ldi	r24, 0x0C	; 12
    4e3e:	ea ea       	ldi	r30, 0xAA	; 170
    4e40:	f5 e0       	ldi	r31, 0x05	; 5
    4e42:	de 01       	movw	r26, r28
    4e44:	11 96       	adiw	r26, 0x01	; 1
    4e46:	01 90       	ld	r0, Z+
    4e48:	0d 92       	st	X+, r0
    4e4a:	8a 95       	dec	r24
    4e4c:	e1 f7       	brne	.-8      	; 0x4e46 <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    4e4e:	e0 91 a7 05 	lds	r30, 0x05A7	; 0x8005a7 <sys+0x1>
    4e52:	8e 2f       	mov	r24, r30
    4e54:	90 e0       	ldi	r25, 0x00	; 0
    4e56:	81 34       	cpi	r24, 0x41	; 65
    4e58:	91 05       	cpc	r25, r1
    4e5a:	38 f5       	brcc	.+78     	; 0x4eaa <report_realtime_status+0x90>
    4e5c:	fc 01       	movw	r30, r24
    4e5e:	eb 50       	subi	r30, 0x0B	; 11
    4e60:	ff 4f       	sbci	r31, 0xFF	; 255
    4e62:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    4e66:	8c e3       	ldi	r24, 0x3C	; 60
    4e68:	93 e0       	ldi	r25, 0x03	; 3
    4e6a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e6e:	1d c0       	rjmp	.+58     	; 0x4eaa <report_realtime_status+0x90>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    4e70:	87 e3       	ldi	r24, 0x37	; 55
    4e72:	93 e0       	ldi	r25, 0x03	; 3
    4e74:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e78:	18 c0       	rjmp	.+48     	; 0x4eaa <report_realtime_status+0x90>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    4e7a:	81 e3       	ldi	r24, 0x31	; 49
    4e7c:	93 e0       	ldi	r25, 0x03	; 3
    4e7e:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e82:	13 c0       	rjmp	.+38     	; 0x4eaa <report_realtime_status+0x90>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    4e84:	8b e2       	ldi	r24, 0x2B	; 43
    4e86:	93 e0       	ldi	r25, 0x03	; 3
    4e88:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e8c:	0e c0       	rjmp	.+28     	; 0x4eaa <report_realtime_status+0x90>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    4e8e:	84 e2       	ldi	r24, 0x24	; 36
    4e90:	93 e0       	ldi	r25, 0x03	; 3
    4e92:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4e96:	09 c0       	rjmp	.+18     	; 0x4eaa <report_realtime_status+0x90>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    4e98:	8d e1       	ldi	r24, 0x1D	; 29
    4e9a:	93 e0       	ldi	r25, 0x03	; 3
    4e9c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ea0:	04 c0       	rjmp	.+8      	; 0x4eaa <report_realtime_status+0x90>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    4ea2:	87 e1       	ldi	r24, 0x17	; 23
    4ea4:	93 e0       	ldi	r25, 0x03	; 3
    4ea6:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    4eaa:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4eae:	83 70       	andi	r24, 0x03	; 3
    4eb0:	39 f0       	breq	.+14     	; 0x4ec0 <report_realtime_status+0xa6>
    system_convert_array_steps_to_mpos(print_position,current_position);
    4eb2:	be 01       	movw	r22, r28
    4eb4:	6f 5f       	subi	r22, 0xFF	; 255
    4eb6:	7f 4f       	sbci	r23, 0xFF	; 255
    4eb8:	ce 01       	movw	r24, r28
    4eba:	0d 96       	adiw	r24, 0x0d	; 13
    4ebc:	0e 94 b1 38 	call	0x7162	; 0x7162 <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    4ec0:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4ec4:	80 ff       	sbrs	r24, 0
    4ec6:	1a c0       	rjmp	.+52     	; 0x4efc <report_realtime_status+0xe2>
    printPgmString(PSTR(",MPos:")); 
    4ec8:	80 e1       	ldi	r24, 0x10	; 16
    4eca:	93 e0       	ldi	r25, 0x03	; 3
    4ecc:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4ed0:	6e 01       	movw	r12, r28
    4ed2:	2d e0       	ldi	r18, 0x0D	; 13
    4ed4:	c2 0e       	add	r12, r18
    4ed6:	d1 1c       	adc	r13, r1
    for (idx=0; idx< N_AXIS; idx++) {
    4ed8:	10 e0       	ldi	r17, 0x00	; 0
      printFloat_CoordValue(print_position[idx]);
    4eda:	f6 01       	movw	r30, r12
    4edc:	61 91       	ld	r22, Z+
    4ede:	71 91       	ld	r23, Z+
    4ee0:	81 91       	ld	r24, Z+
    4ee2:	91 91       	ld	r25, Z+
    4ee4:	6f 01       	movw	r12, r30
    4ee6:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4eea:	12 30       	cpi	r17, 0x02	; 2
    4eec:	20 f4       	brcc	.+8      	; 0x4ef6 <report_realtime_status+0xdc>
    4eee:	8e e0       	ldi	r24, 0x0E	; 14
    4ef0:	93 e0       	ldi	r25, 0x03	; 3
    4ef2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4ef6:	1f 5f       	subi	r17, 0xFF	; 255
    4ef8:	13 30       	cpi	r17, 0x03	; 3
    4efa:	79 f7       	brne	.-34     	; 0x4eda <report_realtime_status+0xc0>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    4efc:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4f00:	81 ff       	sbrs	r24, 1
    4f02:	4c c0       	rjmp	.+152    	; 0x4f9c <report_realtime_status+0x182>
    printPgmString(PSTR(",WPos:")); 
    4f04:	87 e0       	ldi	r24, 0x07	; 7
    4f06:	93 e0       	ldi	r25, 0x03	; 3
    4f08:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    4f0c:	8e 01       	movw	r16, r28
    4f0e:	03 5f       	subi	r16, 0xF3	; 243
    4f10:	1f 4f       	sbci	r17, 0xFF	; 255
    4f12:	0f 2e       	mov	r0, r31
    4f14:	f1 e5       	ldi	r31, 0x51	; 81
    4f16:	cf 2e       	mov	r12, r31
    4f18:	f5 e0       	ldi	r31, 0x05	; 5
    4f1a:	df 2e       	mov	r13, r31
    4f1c:	f0 2d       	mov	r31, r0
    for (idx=0; idx< N_AXIS; idx++) {
    4f1e:	f1 2c       	mov	r15, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[idx] -= gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    4f20:	f6 01       	movw	r30, r12
    4f22:	61 91       	ld	r22, Z+
    4f24:	71 91       	ld	r23, Z+
    4f26:	81 91       	ld	r24, Z+
    4f28:	91 91       	ld	r25, Z+
    4f2a:	6f 01       	movw	r12, r30
    4f2c:	20 85       	ldd	r18, Z+8	; 0x08
    4f2e:	31 85       	ldd	r19, Z+9	; 0x09
    4f30:	42 85       	ldd	r20, Z+10	; 0x0a
    4f32:	53 85       	ldd	r21, Z+11	; 0x0b
    4f34:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    4f38:	9b 01       	movw	r18, r22
    4f3a:	ac 01       	movw	r20, r24
    4f3c:	f8 01       	movw	r30, r16
    4f3e:	60 81       	ld	r22, Z
    4f40:	71 81       	ldd	r23, Z+1	; 0x01
    4f42:	82 81       	ldd	r24, Z+2	; 0x02
    4f44:	93 81       	ldd	r25, Z+3	; 0x03
    4f46:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    4f4a:	f8 01       	movw	r30, r16
    4f4c:	60 83       	st	Z, r22
    4f4e:	71 83       	std	Z+1, r23	; 0x01
    4f50:	82 83       	std	Z+2, r24	; 0x02
    4f52:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { print_position[idx] -= gc_state.tool_length_offset; }    
    4f54:	f2 e0       	ldi	r31, 0x02	; 2
    4f56:	ff 12       	cpse	r15, r31
    4f58:	12 c0       	rjmp	.+36     	; 0x4f7e <report_realtime_status+0x164>
    4f5a:	20 91 69 05 	lds	r18, 0x0569	; 0x800569 <gc_state+0x3b>
    4f5e:	30 91 6a 05 	lds	r19, 0x056A	; 0x80056a <gc_state+0x3c>
    4f62:	40 91 6b 05 	lds	r20, 0x056B	; 0x80056b <gc_state+0x3d>
    4f66:	50 91 6c 05 	lds	r21, 0x056C	; 0x80056c <gc_state+0x3e>
    4f6a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    4f6e:	f8 01       	movw	r30, r16
    4f70:	60 83       	st	Z, r22
    4f72:	71 83       	std	Z+1, r23	; 0x01
    4f74:	82 83       	std	Z+2, r24	; 0x02
    4f76:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[idx]);
    4f78:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
    4f7c:	0f c0       	rjmp	.+30     	; 0x4f9c <report_realtime_status+0x182>
    4f7e:	0e 94 f1 1f 	call	0x3fe2	; 0x3fe2 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4f82:	f1 e0       	ldi	r31, 0x01	; 1
    4f84:	ff 15       	cp	r31, r15
    4f86:	20 f0       	brcs	.+8      	; 0x4f90 <report_realtime_status+0x176>
    4f88:	85 e0       	ldi	r24, 0x05	; 5
    4f8a:	93 e0       	ldi	r25, 0x03	; 3
    4f8c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4f90:	f3 94       	inc	r15
    4f92:	0c 5f       	subi	r16, 0xFC	; 252
    4f94:	1f 4f       	sbci	r17, 0xFF	; 255
    4f96:	23 e0       	ldi	r18, 0x03	; 3
    4f98:	f2 12       	cpse	r15, r18
    4f9a:	c2 cf       	rjmp	.-124    	; 0x4f20 <report_realtime_status+0x106>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    4f9c:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4fa0:	82 ff       	sbrs	r24, 2
    4fa2:	08 c0       	rjmp	.+16     	; 0x4fb4 <report_realtime_status+0x19a>
    printPgmString(PSTR(",Buf:"));
    4fa4:	8f ef       	ldi	r24, 0xFF	; 255
    4fa6:	92 e0       	ldi	r25, 0x02	; 2
    4fa8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    4fac:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <plan_get_block_buffer_count>
    4fb0:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    4fb4:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4fb8:	83 ff       	sbrs	r24, 3
    4fba:	08 c0       	rjmp	.+16     	; 0x4fcc <report_realtime_status+0x1b2>
    printPgmString(PSTR(",RX:"));
    4fbc:	8a ef       	ldi	r24, 0xFA	; 250
    4fbe:	92 e0       	ldi	r25, 0x02	; 2
    4fc0:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    4fc4:	0e 94 08 28 	call	0x5010	; 0x5010 <serial_get_rx_buffer_count>
    4fc8:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <print_uint8_base10>
    // Report realtime rate 
    printPgmString(PSTR(",F:")); 
    printFloat_RateValue(st_get_realtime_rate());
  #endif    
  
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_LIMIT_PINS)) {
    4fcc:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <settings+0x34>
    4fd0:	84 ff       	sbrs	r24, 4
    4fd2:	0a c0       	rjmp	.+20     	; 0x4fe8 <report_realtime_status+0x1ce>
    printPgmString(PSTR(",Lim:"));
    4fd4:	84 ef       	ldi	r24, 0xF4	; 244
    4fd6:	92 e0       	ldi	r25, 0x02	; 2
    4fd8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
    print_unsigned_int8(limits_get_state(),2,N_AXIS);
    4fdc:	0e 94 25 11 	call	0x224a	; 0x224a <limits_get_state>
    4fe0:	43 e0       	ldi	r20, 0x03	; 3
    4fe2:	62 e0       	ldi	r22, 0x02	; 2
    4fe4:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <print_unsigned_int8>
  #ifdef REPORT_CONTROL_PIN_STATE 
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    4fe8:	80 ef       	ldi	r24, 0xF0	; 240
    4fea:	92 e0       	ldi	r25, 0x02	; 2
    4fec:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
}
    4ff0:	68 96       	adiw	r28, 0x18	; 24
    4ff2:	0f b6       	in	r0, 0x3f	; 63
    4ff4:	f8 94       	cli
    4ff6:	de bf       	out	0x3e, r29	; 62
    4ff8:	0f be       	out	0x3f, r0	; 63
    4ffa:	cd bf       	out	0x3d, r28	; 61
    4ffc:	df 91       	pop	r29
    4ffe:	cf 91       	pop	r28
    5000:	1f 91       	pop	r17
    5002:	0f 91       	pop	r16
    5004:	ff 90       	pop	r15
    5006:	df 90       	pop	r13
    5008:	cf 90       	pop	r12
    500a:	bf 90       	pop	r11
    500c:	af 90       	pop	r10
    500e:	08 95       	ret

00005010 <serial_get_rx_buffer_count>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_BUFFER_SIZE - (ttail-serial_tx_buffer_head));
}
    5010:	90 91 5a 04 	lds	r25, 0x045A	; 0x80045a <serial_rx_buffer_tail>
    5014:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <serial_rx_buffer_head>
    5018:	89 17       	cp	r24, r25
    501a:	10 f0       	brcs	.+4      	; 0x5020 <serial_get_rx_buffer_count+0x10>
    501c:	89 1b       	sub	r24, r25
    501e:	08 95       	ret
    5020:	80 58       	subi	r24, 0x80	; 128
    5022:	89 1b       	sub	r24, r25
    5024:	08 95       	ret

00005026 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    5026:	e0 ec       	ldi	r30, 0xC0	; 192
    5028:	f0 e0       	ldi	r31, 0x00	; 0
    502a:	80 81       	ld	r24, Z
    502c:	82 60       	ori	r24, 0x02	; 2
    502e:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    5030:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
  UBRR0L = UBRR0_value;
    5034:	80 e1       	ldi	r24, 0x10	; 16
    5036:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    503a:	e1 ec       	ldi	r30, 0xC1	; 193
    503c:	f0 e0       	ldi	r31, 0x00	; 0
    503e:	80 81       	ld	r24, Z
    5040:	80 61       	ori	r24, 0x10	; 16
    5042:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    5044:	80 81       	ld	r24, Z
    5046:	88 60       	ori	r24, 0x08	; 8
    5048:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    504a:	80 81       	ld	r24, Z
    504c:	80 68       	ori	r24, 0x80	; 128
    504e:	80 83       	st	Z, r24
    5050:	08 95       	ret

00005052 <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    5052:	e0 91 59 04 	lds	r30, 0x0459	; 0x800459 <serial_tx_buffer_head>
    5056:	21 e0       	ldi	r18, 0x01	; 1
    5058:	2e 0f       	add	r18, r30
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    505a:	20 34       	cpi	r18, 0x40	; 64
    505c:	31 f4       	brne	.+12     	; 0x506a <serial_write+0x18>
    505e:	20 e0       	ldi	r18, 0x00	; 0
    5060:	04 c0       	rjmp	.+8      	; 0x506a <serial_write+0x18>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    5062:	90 91 2b 05 	lds	r25, 0x052B	; 0x80052b <sys_rt_exec_state>
    5066:	94 fd       	sbrc	r25, 4
    5068:	0f c0       	rjmp	.+30     	; 0x5088 <serial_write+0x36>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    506a:	90 91 58 04 	lds	r25, 0x0458	; 0x800458 <serial_tx_buffer_tail>
    506e:	92 17       	cp	r25, r18
    5070:	c1 f3       	breq	.-16     	; 0x5062 <serial_write+0x10>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    5072:	f0 e0       	ldi	r31, 0x00	; 0
    5074:	eb 53       	subi	r30, 0x3B	; 59
    5076:	fa 4f       	sbci	r31, 0xFA	; 250
    5078:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    507a:	20 93 59 04 	sts	0x0459, r18	; 0x800459 <serial_tx_buffer_head>
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    507e:	e1 ec       	ldi	r30, 0xC1	; 193
    5080:	f0 e0       	ldi	r31, 0x00	; 0
    5082:	80 81       	ld	r24, Z
    5084:	80 62       	ori	r24, 0x20	; 32
    5086:	80 83       	st	Z, r24
    5088:	08 95       	ret

0000508a <__vector_19>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    508a:	1f 92       	push	r1
    508c:	0f 92       	push	r0
    508e:	0f b6       	in	r0, 0x3f	; 63
    5090:	0f 92       	push	r0
    5092:	11 24       	eor	r1, r1
    5094:	8f 93       	push	r24
    5096:	9f 93       	push	r25
    5098:	ef 93       	push	r30
    509a:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    509c:	80 91 58 04 	lds	r24, 0x0458	; 0x800458 <serial_tx_buffer_tail>
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    50a0:	e8 2f       	mov	r30, r24
    50a2:	f0 e0       	ldi	r31, 0x00	; 0
    50a4:	eb 53       	subi	r30, 0x3B	; 59
    50a6:	fa 4f       	sbci	r31, 0xFA	; 250
    50a8:	90 81       	ld	r25, Z
    50aa:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  
    // Update tail position
    tail++;
    50ae:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    50b0:	80 34       	cpi	r24, 0x40	; 64
    50b2:	09 f4       	brne	.+2      	; 0x50b6 <__vector_19+0x2c>
    50b4:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    50b6:	80 93 58 04 	sts	0x0458, r24	; 0x800458 <serial_tx_buffer_tail>
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    50ba:	90 91 59 04 	lds	r25, 0x0459	; 0x800459 <serial_tx_buffer_head>
    50be:	89 13       	cpse	r24, r25
    50c0:	05 c0       	rjmp	.+10     	; 0x50cc <__vector_19+0x42>
    50c2:	e1 ec       	ldi	r30, 0xC1	; 193
    50c4:	f0 e0       	ldi	r31, 0x00	; 0
    50c6:	80 81       	ld	r24, Z
    50c8:	8f 7d       	andi	r24, 0xDF	; 223
    50ca:	80 83       	st	Z, r24
}
    50cc:	ff 91       	pop	r31
    50ce:	ef 91       	pop	r30
    50d0:	9f 91       	pop	r25
    50d2:	8f 91       	pop	r24
    50d4:	0f 90       	pop	r0
    50d6:	0f be       	out	0x3f, r0	; 63
    50d8:	0f 90       	pop	r0
    50da:	1f 90       	pop	r1
    50dc:	18 95       	reti

000050de <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    50de:	90 91 5a 04 	lds	r25, 0x045A	; 0x80045a <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    50e2:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <serial_rx_buffer_head>
    50e6:	98 17       	cp	r25, r24
    50e8:	61 f0       	breq	.+24     	; 0x5102 <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    50ea:	e9 2f       	mov	r30, r25
    50ec:	f0 e0       	ldi	r31, 0x00	; 0
    50ee:	eb 5f       	subi	r30, 0xFB	; 251
    50f0:	f9 4f       	sbci	r31, 0xF9	; 249
    50f2:	80 81       	ld	r24, Z
    
    tail++;
    50f4:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    50f6:	90 38       	cpi	r25, 0x80	; 128
    50f8:	09 f4       	brne	.+2      	; 0x50fc <serial_read+0x1e>
    50fa:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    50fc:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <serial_rx_buffer_tail>
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    5100:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    5102:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    5104:	08 95       	ret

00005106 <__vector_18>:


ISR(SERIAL_RX)
{
    5106:	1f 92       	push	r1
    5108:	0f 92       	push	r0
    510a:	0f b6       	in	r0, 0x3f	; 63
    510c:	0f 92       	push	r0
    510e:	11 24       	eor	r1, r1
    5110:	2f 93       	push	r18
    5112:	3f 93       	push	r19
    5114:	4f 93       	push	r20
    5116:	5f 93       	push	r21
    5118:	6f 93       	push	r22
    511a:	7f 93       	push	r23
    511c:	8f 93       	push	r24
    511e:	9f 93       	push	r25
    5120:	af 93       	push	r26
    5122:	bf 93       	push	r27
    5124:	ef 93       	push	r30
    5126:	ff 93       	push	r31
  uint8_t data = UDR0;
    5128:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    512c:	8f 33       	cpi	r24, 0x3F	; 63
    512e:	59 f0       	breq	.+22     	; 0x5146 <__vector_18+0x40>
    5130:	28 f4       	brcc	.+10     	; 0x513c <__vector_18+0x36>
    5132:	88 31       	cpi	r24, 0x18	; 24
    5134:	61 f1       	breq	.+88     	; 0x518e <__vector_18+0x88>
    5136:	81 32       	cpi	r24, 0x21	; 33
    5138:	c1 f0       	breq	.+48     	; 0x516a <__vector_18+0x64>
    513a:	2c c0       	rjmp	.+88     	; 0x5194 <__vector_18+0x8e>
    513c:	80 34       	cpi	r24, 0x40	; 64
    513e:	f1 f0       	breq	.+60     	; 0x517c <__vector_18+0x76>
    5140:	8e 37       	cpi	r24, 0x7E	; 126
    5142:	51 f0       	breq	.+20     	; 0x5158 <__vector_18+0x52>
    5144:	27 c0       	rjmp	.+78     	; 0x5194 <__vector_18+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys_rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    5146:	9f b7       	in	r25, 0x3f	; 63
    5148:	f8 94       	cli
    514a:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    514e:	81 60       	ori	r24, 0x01	; 1
    5150:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    5154:	9f bf       	out	0x3f, r25	; 63
    5156:	2f c0       	rjmp	.+94     	; 0x51b6 <__vector_18+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    5158:	9f b7       	in	r25, 0x3f	; 63
    515a:	f8 94       	cli
    515c:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    5160:	82 60       	ori	r24, 0x02	; 2
    5162:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    5166:	9f bf       	out	0x3f, r25	; 63
    5168:	26 c0       	rjmp	.+76     	; 0x51b6 <__vector_18+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    516a:	9f b7       	in	r25, 0x3f	; 63
    516c:	f8 94       	cli
    516e:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    5172:	88 60       	ori	r24, 0x08	; 8
    5174:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    5178:	9f bf       	out	0x3f, r25	; 63
    517a:	1d c0       	rjmp	.+58     	; 0x51b6 <__vector_18+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys_rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    517c:	9f b7       	in	r25, 0x3f	; 63
    517e:	f8 94       	cli
    5180:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    5184:	80 62       	ori	r24, 0x20	; 32
    5186:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    518a:	9f bf       	out	0x3f, r25	; 63
    518c:	14 c0       	rjmp	.+40     	; 0x51b6 <__vector_18+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    518e:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
    5192:	11 c0       	rjmp	.+34     	; 0x51b6 <__vector_18+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    5194:	e0 91 5b 04 	lds	r30, 0x045B	; 0x80045b <serial_rx_buffer_head>
    5198:	91 e0       	ldi	r25, 0x01	; 1
    519a:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    519c:	90 38       	cpi	r25, 0x80	; 128
    519e:	09 f4       	brne	.+2      	; 0x51a2 <__vector_18+0x9c>
    51a0:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    51a2:	20 91 5a 04 	lds	r18, 0x045A	; 0x80045a <serial_rx_buffer_tail>
    51a6:	92 17       	cp	r25, r18
    51a8:	31 f0       	breq	.+12     	; 0x51b6 <__vector_18+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    51aa:	f0 e0       	ldi	r31, 0x00	; 0
    51ac:	eb 5f       	subi	r30, 0xFB	; 251
    51ae:	f9 4f       	sbci	r31, 0xF9	; 249
    51b0:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    51b2:	90 93 5b 04 	sts	0x045B, r25	; 0x80045b <serial_rx_buffer_head>
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    51b6:	ff 91       	pop	r31
    51b8:	ef 91       	pop	r30
    51ba:	bf 91       	pop	r27
    51bc:	af 91       	pop	r26
    51be:	9f 91       	pop	r25
    51c0:	8f 91       	pop	r24
    51c2:	7f 91       	pop	r23
    51c4:	6f 91       	pop	r22
    51c6:	5f 91       	pop	r21
    51c8:	4f 91       	pop	r20
    51ca:	3f 91       	pop	r19
    51cc:	2f 91       	pop	r18
    51ce:	0f 90       	pop	r0
    51d0:	0f be       	out	0x3f, r0	; 63
    51d2:	0f 90       	pop	r0
    51d4:	1f 90       	pop	r1
    51d6:	18 95       	reti

000051d8 <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    51d8:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <serial_rx_buffer_head>
    51dc:	80 93 5a 04 	sts	0x045A, r24	; 0x80045a <serial_rx_buffer_tail>
    51e0:	08 95       	ret

000051e2 <servo_init>:
 */ 
#include "grbl.h"

void servo_init()
{
	SERVO_PWM_DDR |= (1<<SERVO_PWM_YBIT) | (1<<SERVO_PWM_ZBIT); // Configure as PWM output pin.
    51e2:	23 9a       	sbi	0x04, 3	; 4
	SERVO2_PWM_DDR |= (1<<SERVO_PWM_YBIT) | (1<<SERVO_PWM_ZBIT); // Configure as PWM output pin.
    51e4:	53 9a       	sbi	0x0a, 3	; 10
	
	//Set for fast PWM using compare A and B registers
	TCCRA_REGISTER = (1<<5) | (1<<COMA_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
    51e6:	83 ea       	ldi	r24, 0xA3	; 163
    51e8:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x07; // set to 1/1024 Prescaler
    51ec:	e1 eb       	ldi	r30, 0xB1	; 177
    51ee:	f0 e0       	ldi	r31, 0x00	; 0
    51f0:	80 81       	ld	r24, Z
    51f2:	87 60       	ori	r24, 0x07	; 7
    51f4:	80 83       	st	Z, r24
	
	SERVO_OCRY = 9;
    51f6:	89 e0       	ldi	r24, 0x09	; 9
    51f8:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
	SERVO_OCRZ = 1 ;
    51fc:	81 e0       	ldi	r24, 0x01	; 1
    51fe:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    5202:	08 95       	ret

00005204 <settings_store_startup_line>:

// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    5204:	21 e5       	ldi	r18, 0x51	; 81
    5206:	82 9f       	mul	r24, r18
    5208:	c0 01       	movw	r24, r0
    520a:	11 24       	eor	r1, r1
    520c:	40 e5       	ldi	r20, 0x50	; 80
    520e:	50 e0       	ldi	r21, 0x00	; 0
    5210:	9d 5f       	subi	r25, 0xFD	; 253
    5212:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    5216:	08 95       	ret

00005218 <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    5218:	40 e5       	ldi	r20, 0x50	; 80
    521a:	50 e0       	ldi	r21, 0x00	; 0
    521c:	bc 01       	movw	r22, r24
    521e:	8e ea       	ldi	r24, 0xAE	; 174
    5220:	93 e0       	ldi	r25, 0x03	; 3
    5222:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    5226:	08 95       	ret

00005228 <settings_write_coord_data>:

// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    5228:	2d e0       	ldi	r18, 0x0D	; 13
    522a:	82 9f       	mul	r24, r18
    522c:	c0 01       	movw	r24, r0
    522e:	11 24       	eor	r1, r1
    5230:	4c e0       	ldi	r20, 0x0C	; 12
    5232:	50 e0       	ldi	r21, 0x00	; 0
    5234:	9e 5f       	subi	r25, 0xFE	; 254
    5236:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    523a:	08 95       	ret

0000523c <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    523c:	69 e0       	ldi	r22, 0x09	; 9
    523e:	80 e0       	ldi	r24, 0x00	; 0
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    5246:	4d e4       	ldi	r20, 0x4D	; 77
    5248:	50 e0       	ldi	r21, 0x00	; 0
    524a:	65 e8       	ldi	r22, 0x85	; 133
    524c:	76 e0       	ldi	r23, 0x06	; 6
    524e:	81 e0       	ldi	r24, 0x01	; 1
    5250:	90 e0       	ldi	r25, 0x00	; 0
    5252:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    5256:	08 95       	ret

00005258 <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore(uint8_t restore_flag) {  
    5258:	0f 93       	push	r16
    525a:	1f 93       	push	r17
    525c:	cf 93       	push	r28
    525e:	df 93       	push	r29
    5260:	cd b7       	in	r28, 0x3d	; 61
    5262:	de b7       	in	r29, 0x3e	; 62
    5264:	2c 97       	sbiw	r28, 0x0c	; 12
    5266:	0f b6       	in	r0, 0x3f	; 63
    5268:	f8 94       	cli
    526a:	de bf       	out	0x3e, r29	; 62
    526c:	0f be       	out	0x3f, r0	; 63
    526e:	cd bf       	out	0x3d, r28	; 61
    5270:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    5272:	80 ff       	sbrs	r24, 0
    5274:	84 c0       	rjmp	.+264    	; 0x537e <settings_restore+0x126>
	settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    5276:	e5 e8       	ldi	r30, 0x85	; 133
    5278:	f6 e0       	ldi	r31, 0x06	; 6
    527a:	8a e0       	ldi	r24, 0x0A	; 10
    527c:	80 ab       	std	Z+48, r24	; 0x30
	settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    527e:	89 e1       	ldi	r24, 0x19	; 25
    5280:	83 ab       	std	Z+51, r24	; 0x33
	settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    5282:	11 aa       	std	Z+49, r1	; 0x31
	settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    5284:	12 aa       	std	Z+50, r1	; 0x32
	settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    5286:	83 e0       	ldi	r24, 0x03	; 3
    5288:	84 ab       	std	Z+52, r24	; 0x34
	settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    528a:	8a e0       	ldi	r24, 0x0A	; 10
    528c:	97 ed       	ldi	r25, 0xD7	; 215
    528e:	a3 e2       	ldi	r26, 0x23	; 35
    5290:	bc e3       	ldi	r27, 0x3C	; 60
    5292:	85 ab       	std	Z+53, r24	; 0x35
    5294:	96 ab       	std	Z+54, r25	; 0x36
    5296:	a7 ab       	std	Z+55, r26	; 0x37
    5298:	b0 af       	std	Z+56, r27	; 0x38
	settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    529a:	8f e6       	ldi	r24, 0x6F	; 111
    529c:	92 e1       	ldi	r25, 0x12	; 18
    529e:	a3 e0       	ldi	r26, 0x03	; 3
    52a0:	bb e3       	ldi	r27, 0x3B	; 59
    52a2:	81 af       	std	Z+57, r24	; 0x39
    52a4:	92 af       	std	Z+58, r25	; 0x3a
    52a6:	a3 af       	std	Z+59, r26	; 0x3b
    52a8:	b4 af       	std	Z+60, r27	; 0x3c
	settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    52aa:	16 ae       	std	Z+62, r1	; 0x3e
	settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    52ac:	80 e0       	ldi	r24, 0x00	; 0
    52ae:	90 e0       	ldi	r25, 0x00	; 0
    52b0:	a8 ec       	ldi	r26, 0xC8	; 200
    52b2:	b1 e4       	ldi	r27, 0x41	; 65
    52b4:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <settings+0x3f>
    52b8:	90 93 c5 06 	sts	0x06C5, r25	; 0x8006c5 <settings+0x40>
    52bc:	a0 93 c6 06 	sts	0x06C6, r26	; 0x8006c6 <settings+0x41>
    52c0:	b0 93 c7 06 	sts	0x06C7, r27	; 0x8006c7 <settings+0x42>
	settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    52c4:	80 e0       	ldi	r24, 0x00	; 0
    52c6:	90 e0       	ldi	r25, 0x00	; 0
    52c8:	aa ef       	ldi	r26, 0xFA	; 250
    52ca:	b3 e4       	ldi	r27, 0x43	; 67
    52cc:	80 93 c8 06 	sts	0x06C8, r24	; 0x8006c8 <settings+0x43>
    52d0:	90 93 c9 06 	sts	0x06C9, r25	; 0x8006c9 <settings+0x44>
    52d4:	a0 93 ca 06 	sts	0x06CA, r26	; 0x8006ca <settings+0x45>
    52d8:	b0 93 cb 06 	sts	0x06CB, r27	; 0x8006cb <settings+0x46>
	settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    52dc:	2a ef       	ldi	r18, 0xFA	; 250
    52de:	30 e0       	ldi	r19, 0x00	; 0
    52e0:	30 93 cd 06 	sts	0x06CD, r19	; 0x8006cd <settings+0x48>
    52e4:	20 93 cc 06 	sts	0x06CC, r18	; 0x8006cc <settings+0x47>
	settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    52e8:	40 e0       	ldi	r20, 0x00	; 0
    52ea:	50 e0       	ldi	r21, 0x00	; 0
    52ec:	60 e8       	ldi	r22, 0x80	; 128
    52ee:	7f e3       	ldi	r23, 0x3F	; 63
    52f0:	40 93 ce 06 	sts	0x06CE, r20	; 0x8006ce <settings+0x49>
    52f4:	50 93 cf 06 	sts	0x06CF, r21	; 0x8006cf <settings+0x4a>
    52f8:	60 93 d0 06 	sts	0x06D0, r22	; 0x8006d0 <settings+0x4b>
    52fc:	70 93 d1 06 	sts	0x06D1, r23	; 0x8006d1 <settings+0x4c>

	settings.flags = 0;
    5300:	15 ae       	std	Z+61, r1	; 0x3d
	if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
	if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
	if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
	if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
  
	settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    5302:	40 e0       	ldi	r20, 0x00	; 0
    5304:	50 e0       	ldi	r21, 0x00	; 0
    5306:	6a e7       	ldi	r22, 0x7A	; 122
    5308:	73 e4       	ldi	r23, 0x43	; 67
    530a:	40 83       	st	Z, r20
    530c:	51 83       	std	Z+1, r21	; 0x01
    530e:	62 83       	std	Z+2, r22	; 0x02
    5310:	73 83       	std	Z+3, r23	; 0x03
	settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    5312:	44 83       	std	Z+4, r20	; 0x04
    5314:	55 83       	std	Z+5, r21	; 0x05
    5316:	66 83       	std	Z+6, r22	; 0x06
    5318:	77 83       	std	Z+7, r23	; 0x07
	settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    531a:	40 87       	std	Z+8, r20	; 0x08
    531c:	51 87       	std	Z+9, r21	; 0x09
    531e:	62 87       	std	Z+10, r22	; 0x0a
    5320:	73 87       	std	Z+11, r23	; 0x0b
	settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    5322:	84 87       	std	Z+12, r24	; 0x0c
    5324:	95 87       	std	Z+13, r25	; 0x0d
    5326:	a6 87       	std	Z+14, r26	; 0x0e
    5328:	b7 87       	std	Z+15, r27	; 0x0f
	settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    532a:	80 8b       	std	Z+16, r24	; 0x10
    532c:	91 8b       	std	Z+17, r25	; 0x11
    532e:	a2 8b       	std	Z+18, r26	; 0x12
    5330:	b3 8b       	std	Z+19, r27	; 0x13
	settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    5332:	84 8b       	std	Z+20, r24	; 0x14
    5334:	95 8b       	std	Z+21, r25	; 0x15
    5336:	a6 8b       	std	Z+22, r26	; 0x16
    5338:	b7 8b       	std	Z+23, r27	; 0x17
	settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    533a:	80 e0       	ldi	r24, 0x00	; 0
    533c:	90 ea       	ldi	r25, 0xA0	; 160
    533e:	ac e0       	ldi	r26, 0x0C	; 12
    5340:	b7 e4       	ldi	r27, 0x47	; 71
    5342:	80 8f       	std	Z+24, r24	; 0x18
    5344:	91 8f       	std	Z+25, r25	; 0x19
    5346:	a2 8f       	std	Z+26, r26	; 0x1a
    5348:	b3 8f       	std	Z+27, r27	; 0x1b
	settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    534a:	84 8f       	std	Z+28, r24	; 0x1c
    534c:	95 8f       	std	Z+29, r25	; 0x1d
    534e:	a6 8f       	std	Z+30, r26	; 0x1e
    5350:	b7 8f       	std	Z+31, r27	; 0x1f
	settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    5352:	80 a3       	std	Z+32, r24	; 0x20
    5354:	91 a3       	std	Z+33, r25	; 0x21
    5356:	a2 a3       	std	Z+34, r26	; 0x22
    5358:	b3 a3       	std	Z+35, r27	; 0x23
	settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    535a:	80 e0       	ldi	r24, 0x00	; 0
    535c:	90 e0       	ldi	r25, 0x00	; 0
    535e:	a8 e4       	ldi	r26, 0x48	; 72
    5360:	b3 ec       	ldi	r27, 0xC3	; 195
    5362:	84 a3       	std	Z+36, r24	; 0x24
    5364:	95 a3       	std	Z+37, r25	; 0x25
    5366:	a6 a3       	std	Z+38, r26	; 0x26
    5368:	b7 a3       	std	Z+39, r27	; 0x27
	settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    536a:	80 a7       	std	Z+40, r24	; 0x28
    536c:	91 a7       	std	Z+41, r25	; 0x29
    536e:	a2 a7       	std	Z+42, r26	; 0x2a
    5370:	b3 a7       	std	Z+43, r27	; 0x2b
	settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    5372:	84 a7       	std	Z+44, r24	; 0x2c
    5374:	95 a7       	std	Z+45, r25	; 0x2d
    5376:	a6 a7       	std	Z+46, r26	; 0x2e
    5378:	b7 a7       	std	Z+47, r27	; 0x2f

	write_global_settings();
    537a:	0e 94 1e 29 	call	0x523c	; 0x523c <write_global_settings>
  }
  
  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    537e:	01 ff       	sbrs	r16, 1
    5380:	11 c0       	rjmp	.+34     	; 0x53a4 <settings_restore+0x14c>
	uint8_t idx;
	float coord_data[N_AXIS];
	memset(&coord_data, 0, sizeof(coord_data));
    5382:	fe 01       	movw	r30, r28
    5384:	31 96       	adiw	r30, 0x01	; 1
    5386:	8c e0       	ldi	r24, 0x0C	; 12
    5388:	df 01       	movw	r26, r30
    538a:	1d 92       	st	X+, r1
    538c:	8a 95       	dec	r24
    538e:	e9 f7       	brne	.-6      	; 0x538a <settings_restore+0x132>
	for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    5390:	10 e0       	ldi	r17, 0x00	; 0
    5392:	be 01       	movw	r22, r28
    5394:	6f 5f       	subi	r22, 0xFF	; 255
    5396:	7f 4f       	sbci	r23, 0xFF	; 255
    5398:	81 2f       	mov	r24, r17
    539a:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_write_coord_data>
    539e:	1f 5f       	subi	r17, 0xFF	; 255
    53a0:	18 30       	cpi	r17, 0x08	; 8
    53a2:	b9 f7       	brne	.-18     	; 0x5392 <settings_restore+0x13a>
  }
  
  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    53a4:	02 ff       	sbrs	r16, 2
    53a6:	0a c0       	rjmp	.+20     	; 0x53bc <settings_restore+0x164>
	#if N_STARTUP_LINE > 0
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    53a8:	60 e0       	ldi	r22, 0x00	; 0
    53aa:	80 e0       	ldi	r24, 0x00	; 0
    53ac:	93 e0       	ldi	r25, 0x03	; 3
    53ae:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
	#endif
	#if N_STARTUP_LINE > 1
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    53b2:	60 e0       	ldi	r22, 0x00	; 0
    53b4:	81 e5       	ldi	r24, 0x51	; 81
    53b6:	93 e0       	ldi	r25, 0x03	; 3
    53b8:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
	#endif
  }
  
  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    53bc:	03 ff       	sbrs	r16, 3
    53be:	05 c0       	rjmp	.+10     	; 0x53ca <settings_restore+0x172>
    53c0:	60 e0       	ldi	r22, 0x00	; 0
    53c2:	8e ea       	ldi	r24, 0xAE	; 174
    53c4:	93 e0       	ldi	r25, 0x03	; 3
    53c6:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
}
    53ca:	2c 96       	adiw	r28, 0x0c	; 12
    53cc:	0f b6       	in	r0, 0x3f	; 63
    53ce:	f8 94       	cli
    53d0:	de bf       	out	0x3e, r29	; 62
    53d2:	0f be       	out	0x3f, r0	; 63
    53d4:	cd bf       	out	0x3d, r28	; 61
    53d6:	df 91       	pop	r29
    53d8:	cf 91       	pop	r28
    53da:	1f 91       	pop	r17
    53dc:	0f 91       	pop	r16
    53de:	08 95       	ret

000053e0 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    53e0:	1f 93       	push	r17
    53e2:	cf 93       	push	r28
    53e4:	df 93       	push	r29
    53e6:	18 2f       	mov	r17, r24
    53e8:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    53ea:	81 e5       	ldi	r24, 0x51	; 81
    53ec:	18 9f       	mul	r17, r24
    53ee:	b0 01       	movw	r22, r0
    53f0:	11 24       	eor	r1, r1
    53f2:	7d 5f       	subi	r23, 0xFD	; 253
    53f4:	40 e5       	ldi	r20, 0x50	; 80
    53f6:	50 e0       	ldi	r21, 0x00	; 0
    53f8:	ce 01       	movw	r24, r28
    53fa:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    53fe:	89 2b       	or	r24, r25
    5400:	39 f4       	brne	.+14     	; 0x5410 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    5402:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    5404:	be 01       	movw	r22, r28
    5406:	81 2f       	mov	r24, r17
    5408:	0e 94 02 29 	call	0x5204	; 0x5204 <settings_store_startup_line>
    return(false);
    540c:	80 e0       	ldi	r24, 0x00	; 0
    540e:	01 c0       	rjmp	.+2      	; 0x5412 <settings_read_startup_line+0x32>
  }
  return(true);
    5410:	81 e0       	ldi	r24, 0x01	; 1
}
    5412:	df 91       	pop	r29
    5414:	cf 91       	pop	r28
    5416:	1f 91       	pop	r17
    5418:	08 95       	ret

0000541a <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    541a:	cf 93       	push	r28
    541c:	df 93       	push	r29
    541e:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    5420:	40 e5       	ldi	r20, 0x50	; 80
    5422:	50 e0       	ldi	r21, 0x00	; 0
    5424:	6e ea       	ldi	r22, 0xAE	; 174
    5426:	73 e0       	ldi	r23, 0x03	; 3
    5428:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    542c:	89 2b       	or	r24, r25
    542e:	31 f4       	brne	.+12     	; 0x543c <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    5430:	18 82       	st	Y, r1
    settings_store_build_info(line);
    5432:	ce 01       	movw	r24, r28
    5434:	0e 94 0c 29 	call	0x5218	; 0x5218 <settings_store_build_info>
    return(false);
    5438:	80 e0       	ldi	r24, 0x00	; 0
    543a:	01 c0       	rjmp	.+2      	; 0x543e <settings_read_build_info+0x24>
  }
  return(true);
    543c:	81 e0       	ldi	r24, 0x01	; 1
}
    543e:	df 91       	pop	r29
    5440:	cf 91       	pop	r28
    5442:	08 95       	ret

00005444 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    5444:	1f 93       	push	r17
    5446:	cf 93       	push	r28
    5448:	df 93       	push	r29
    544a:	18 2f       	mov	r17, r24
    544c:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    544e:	8d e0       	ldi	r24, 0x0D	; 13
    5450:	18 9f       	mul	r17, r24
    5452:	b0 01       	movw	r22, r0
    5454:	11 24       	eor	r1, r1
    5456:	7e 5f       	subi	r23, 0xFE	; 254
    5458:	4c e0       	ldi	r20, 0x0C	; 12
    545a:	50 e0       	ldi	r21, 0x00	; 0
    545c:	ce 01       	movw	r24, r28
    545e:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    5462:	89 2b       	or	r24, r25
    5464:	59 f4       	brne	.+22     	; 0x547c <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    5466:	8c e0       	ldi	r24, 0x0C	; 12
    5468:	fe 01       	movw	r30, r28
    546a:	11 92       	st	Z+, r1
    546c:	8a 95       	dec	r24
    546e:	e9 f7       	brne	.-6      	; 0x546a <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    5470:	be 01       	movw	r22, r28
    5472:	81 2f       	mov	r24, r17
    5474:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_write_coord_data>
    return(false);
    5478:	80 e0       	ldi	r24, 0x00	; 0
    547a:	01 c0       	rjmp	.+2      	; 0x547e <settings_read_coord_data+0x3a>
  }
  return(true);
    547c:	81 e0       	ldi	r24, 0x01	; 1
}  
    547e:	df 91       	pop	r29
    5480:	cf 91       	pop	r28
    5482:	1f 91       	pop	r17
    5484:	08 95       	ret

00005486 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    5486:	80 e0       	ldi	r24, 0x00	; 0
    5488:	90 e0       	ldi	r25, 0x00	; 0
    548a:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    548e:	89 30       	cpi	r24, 0x09	; 9
    5490:	69 f4       	brne	.+26     	; 0x54ac <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    5492:	4d e4       	ldi	r20, 0x4D	; 77
    5494:	50 e0       	ldi	r21, 0x00	; 0
    5496:	61 e0       	ldi	r22, 0x01	; 1
    5498:	70 e0       	ldi	r23, 0x00	; 0
    549a:	85 e8       	ldi	r24, 0x85	; 133
    549c:	96 e0       	ldi	r25, 0x06	; 6
    549e:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
      return(false);
    54a2:	21 e0       	ldi	r18, 0x01	; 1
    54a4:	89 2b       	or	r24, r25
    54a6:	19 f4       	brne	.+6      	; 0x54ae <read_global_settings+0x28>
    54a8:	20 e0       	ldi	r18, 0x00	; 0
    54aa:	01 c0       	rjmp	.+2      	; 0x54ae <read_global_settings+0x28>
    }
  } else {
    return(false); 
    54ac:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    54ae:	82 2f       	mov	r24, r18
    54b0:	08 95       	ret

000054b2 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    54b2:	cf 92       	push	r12
    54b4:	df 92       	push	r13
    54b6:	ef 92       	push	r14
    54b8:	ff 92       	push	r15
    54ba:	cf 93       	push	r28
    54bc:	df 93       	push	r29
    54be:	c8 2f       	mov	r28, r24
    54c0:	6a 01       	movw	r12, r20
    54c2:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    54c4:	20 e0       	ldi	r18, 0x00	; 0
    54c6:	30 e0       	ldi	r19, 0x00	; 0
    54c8:	a9 01       	movw	r20, r18
    54ca:	c7 01       	movw	r24, r14
    54cc:	b6 01       	movw	r22, r12
    54ce:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    54d2:	88 23       	and	r24, r24
    54d4:	0c f4       	brge	.+2      	; 0x54d8 <settings_store_global_setting+0x26>
    54d6:	dd c0       	rjmp	.+442    	; 0x5692 <settings_store_global_setting+0x1e0>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    54d8:	c4 36       	cpi	r28, 0x64	; 100
    54da:	a0 f0       	brcs	.+40     	; 0x5504 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    54dc:	ec e9       	ldi	r30, 0x9C	; 156
    54de:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    54e0:	e3 30       	cpi	r30, 0x03	; 3
    54e2:	20 f0       	brcs	.+8      	; 0x54ec <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    54e4:	ea 30       	cpi	r30, 0x0A	; 10
    54e6:	08 f0       	brcs	.+2      	; 0x54ea <settings_store_global_setting+0x38>
    54e8:	e2 c0       	rjmp	.+452    	; 0x56ae <settings_store_global_setting+0x1fc>
    54ea:	d5 c0       	rjmp	.+426    	; 0x5696 <settings_store_global_setting+0x1e4>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    54ec:	f0 e0       	ldi	r31, 0x00	; 0
    54ee:	ee 0f       	add	r30, r30
    54f0:	ff 1f       	adc	r31, r31
    54f2:	ee 0f       	add	r30, r30
    54f4:	ff 1f       	adc	r31, r31
    54f6:	eb 57       	subi	r30, 0x7B	; 123
    54f8:	f9 4f       	sbci	r31, 0xF9	; 249
    54fa:	c0 82       	st	Z, r12
    54fc:	d1 82       	std	Z+1, r13	; 0x01
    54fe:	e2 82       	std	Z+2, r14	; 0x02
    5500:	f3 82       	std	Z+3, r15	; 0x03
            break;
    5502:	c3 c0       	rjmp	.+390    	; 0x568a <settings_store_global_setting+0x1d8>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    5504:	c7 01       	movw	r24, r14
    5506:	b6 01       	movw	r22, r12
    5508:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <trunc>
    550c:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    switch(parameter) {
    5510:	8c 2f       	mov	r24, r28
    5512:	90 e0       	ldi	r25, 0x00	; 0
    5514:	8c 31       	cpi	r24, 0x1C	; 28
    5516:	91 05       	cpc	r25, r1
    5518:	08 f0       	brcs	.+2      	; 0x551c <settings_store_global_setting+0x6a>
    551a:	bf c0       	rjmp	.+382    	; 0x569a <settings_store_global_setting+0x1e8>
    551c:	fc 01       	movw	r30, r24
    551e:	ea 5c       	subi	r30, 0xCA	; 202
    5520:	fe 4f       	sbci	r31, 0xFE	; 254
    5522:	0c 94 5b 3d 	jmp	0x7ab6	; 0x7ab6 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    5526:	63 30       	cpi	r22, 0x03	; 3
    5528:	08 f4       	brcc	.+2      	; 0x552c <settings_store_global_setting+0x7a>
    552a:	b9 c0       	rjmp	.+370    	; 0x569e <settings_store_global_setting+0x1ec>
        settings.pulse_microseconds = int_value; break;
    552c:	60 93 b5 06 	sts	0x06B5, r22	; 0x8006b5 <settings+0x30>
    5530:	ac c0       	rjmp	.+344    	; 0x568a <settings_store_global_setting+0x1d8>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    5532:	60 93 b8 06 	sts	0x06B8, r22	; 0x8006b8 <settings+0x33>
    5536:	a9 c0       	rjmp	.+338    	; 0x568a <settings_store_global_setting+0x1d8>
      case 2: 
        settings.step_invert_mask = int_value; 
    5538:	60 93 b6 06 	sts	0x06B6, r22	; 0x8006b6 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    553c:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <st_generate_step_dir_invert_masks>
        break;
    5540:	a4 c0       	rjmp	.+328    	; 0x568a <settings_store_global_setting+0x1d8>
      case 3: 
        settings.dir_invert_mask = int_value; 
    5542:	60 93 b7 06 	sts	0x06B7, r22	; 0x8006b7 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    5546:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <st_generate_step_dir_invert_masks>
        break;
    554a:	9f c0       	rjmp	.+318    	; 0x568a <settings_store_global_setting+0x1d8>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    554c:	66 23       	and	r22, r22
    554e:	31 f0       	breq	.+12     	; 0x555c <settings_store_global_setting+0xaa>
    5550:	e5 e8       	ldi	r30, 0x85	; 133
    5552:	f6 e0       	ldi	r31, 0x06	; 6
    5554:	85 ad       	ldd	r24, Z+61	; 0x3d
    5556:	84 60       	ori	r24, 0x04	; 4
    5558:	85 af       	std	Z+61, r24	; 0x3d
    555a:	97 c0       	rjmp	.+302    	; 0x568a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    555c:	e5 e8       	ldi	r30, 0x85	; 133
    555e:	f6 e0       	ldi	r31, 0x06	; 6
    5560:	85 ad       	ldd	r24, Z+61	; 0x3d
    5562:	8b 7f       	andi	r24, 0xFB	; 251
    5564:	85 af       	std	Z+61, r24	; 0x3d
    5566:	91 c0       	rjmp	.+290    	; 0x568a <settings_store_global_setting+0x1d8>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    5568:	66 23       	and	r22, r22
    556a:	31 f0       	breq	.+12     	; 0x5578 <settings_store_global_setting+0xc6>
    556c:	e5 e8       	ldi	r30, 0x85	; 133
    556e:	f6 e0       	ldi	r31, 0x06	; 6
    5570:	85 ad       	ldd	r24, Z+61	; 0x3d
    5572:	80 64       	ori	r24, 0x40	; 64
    5574:	85 af       	std	Z+61, r24	; 0x3d
    5576:	89 c0       	rjmp	.+274    	; 0x568a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    5578:	e5 e8       	ldi	r30, 0x85	; 133
    557a:	f6 e0       	ldi	r31, 0x06	; 6
    557c:	85 ad       	ldd	r24, Z+61	; 0x3d
    557e:	8f 7b       	andi	r24, 0xBF	; 191
    5580:	85 af       	std	Z+61, r24	; 0x3d
    5582:	83 c0       	rjmp	.+262    	; 0x568a <settings_store_global_setting+0x1d8>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    5584:	66 23       	and	r22, r22
    5586:	31 f0       	breq	.+12     	; 0x5594 <settings_store_global_setting+0xe2>
    5588:	e5 e8       	ldi	r30, 0x85	; 133
    558a:	f6 e0       	ldi	r31, 0x06	; 6
    558c:	85 ad       	ldd	r24, Z+61	; 0x3d
    558e:	80 68       	ori	r24, 0x80	; 128
    5590:	85 af       	std	Z+61, r24	; 0x3d
    5592:	7b c0       	rjmp	.+246    	; 0x568a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    5594:	e5 e8       	ldi	r30, 0x85	; 133
    5596:	f6 e0       	ldi	r31, 0x06	; 6
    5598:	85 ad       	ldd	r24, Z+61	; 0x3d
    559a:	8f 77       	andi	r24, 0x7F	; 127
    559c:	85 af       	std	Z+61, r24	; 0x3d
    559e:	75 c0       	rjmp	.+234    	; 0x568a <settings_store_global_setting+0x1d8>
        break;
      case 10: settings.status_report_mask = int_value; break;
    55a0:	60 93 b9 06 	sts	0x06B9, r22	; 0x8006b9 <settings+0x34>
    55a4:	72 c0       	rjmp	.+228    	; 0x568a <settings_store_global_setting+0x1d8>
      case 11: settings.junction_deviation = value; break;
    55a6:	c0 92 ba 06 	sts	0x06BA, r12	; 0x8006ba <settings+0x35>
    55aa:	d0 92 bb 06 	sts	0x06BB, r13	; 0x8006bb <settings+0x36>
    55ae:	e0 92 bc 06 	sts	0x06BC, r14	; 0x8006bc <settings+0x37>
    55b2:	f0 92 bd 06 	sts	0x06BD, r15	; 0x8006bd <settings+0x38>
    55b6:	69 c0       	rjmp	.+210    	; 0x568a <settings_store_global_setting+0x1d8>
      case 12: settings.arc_tolerance = value; break;
    55b8:	c0 92 be 06 	sts	0x06BE, r12	; 0x8006be <settings+0x39>
    55bc:	d0 92 bf 06 	sts	0x06BF, r13	; 0x8006bf <settings+0x3a>
    55c0:	e0 92 c0 06 	sts	0x06C0, r14	; 0x8006c0 <settings+0x3b>
    55c4:	f0 92 c1 06 	sts	0x06C1, r15	; 0x8006c1 <settings+0x3c>
    55c8:	60 c0       	rjmp	.+192    	; 0x568a <settings_store_global_setting+0x1d8>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    55ca:	66 23       	and	r22, r22
    55cc:	31 f0       	breq	.+12     	; 0x55da <settings_store_global_setting+0x128>
    55ce:	e5 e8       	ldi	r30, 0x85	; 133
    55d0:	f6 e0       	ldi	r31, 0x06	; 6
    55d2:	85 ad       	ldd	r24, Z+61	; 0x3d
    55d4:	81 60       	ori	r24, 0x01	; 1
    55d6:	85 af       	std	Z+61, r24	; 0x3d
    55d8:	58 c0       	rjmp	.+176    	; 0x568a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    55da:	e5 e8       	ldi	r30, 0x85	; 133
    55dc:	f6 e0       	ldi	r31, 0x06	; 6
    55de:	85 ad       	ldd	r24, Z+61	; 0x3d
    55e0:	8e 7f       	andi	r24, 0xFE	; 254
    55e2:	85 af       	std	Z+61, r24	; 0x3d
    55e4:	52 c0       	rjmp	.+164    	; 0x568a <settings_store_global_setting+0x1d8>
        break;
      case 20:
        if (int_value) { 
    55e6:	66 23       	and	r22, r22
    55e8:	41 f0       	breq	.+16     	; 0x55fa <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    55ea:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    55ee:	84 ff       	sbrs	r24, 4
    55f0:	58 c0       	rjmp	.+176    	; 0x56a2 <settings_store_global_setting+0x1f0>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    55f2:	80 62       	ori	r24, 0x20	; 32
    55f4:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <settings+0x3d>
    55f8:	48 c0       	rjmp	.+144    	; 0x568a <settings_store_global_setting+0x1d8>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    55fa:	e5 e8       	ldi	r30, 0x85	; 133
    55fc:	f6 e0       	ldi	r31, 0x06	; 6
    55fe:	85 ad       	ldd	r24, Z+61	; 0x3d
    5600:	8f 7d       	andi	r24, 0xDF	; 223
    5602:	85 af       	std	Z+61, r24	; 0x3d
    5604:	42 c0       	rjmp	.+132    	; 0x568a <settings_store_global_setting+0x1d8>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    5606:	66 23       	and	r22, r22
    5608:	31 f0       	breq	.+12     	; 0x5616 <settings_store_global_setting+0x164>
    560a:	e5 e8       	ldi	r30, 0x85	; 133
    560c:	f6 e0       	ldi	r31, 0x06	; 6
    560e:	85 ad       	ldd	r24, Z+61	; 0x3d
    5610:	88 60       	ori	r24, 0x08	; 8
    5612:	85 af       	std	Z+61, r24	; 0x3d
    5614:	05 c0       	rjmp	.+10     	; 0x5620 <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    5616:	e5 e8       	ldi	r30, 0x85	; 133
    5618:	f6 e0       	ldi	r31, 0x06	; 6
    561a:	85 ad       	ldd	r24, Z+61	; 0x3d
    561c:	87 7f       	andi	r24, 0xF7	; 247
    561e:	85 af       	std	Z+61, r24	; 0x3d
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    5620:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
        break;
    5624:	32 c0       	rjmp	.+100    	; 0x568a <settings_store_global_setting+0x1d8>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    5626:	66 23       	and	r22, r22
    5628:	31 f0       	breq	.+12     	; 0x5636 <settings_store_global_setting+0x184>
    562a:	e5 e8       	ldi	r30, 0x85	; 133
    562c:	f6 e0       	ldi	r31, 0x06	; 6
    562e:	85 ad       	ldd	r24, Z+61	; 0x3d
    5630:	80 61       	ori	r24, 0x10	; 16
    5632:	85 af       	std	Z+61, r24	; 0x3d
    5634:	2a c0       	rjmp	.+84     	; 0x568a <settings_store_global_setting+0x1d8>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5636:	e5 e8       	ldi	r30, 0x85	; 133
    5638:	f6 e0       	ldi	r31, 0x06	; 6
    563a:	85 ad       	ldd	r24, Z+61	; 0x3d
    563c:	8f 7c       	andi	r24, 0xCF	; 207
    563e:	85 af       	std	Z+61, r24	; 0x3d
    5640:	24 c0       	rjmp	.+72     	; 0x568a <settings_store_global_setting+0x1d8>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    5642:	60 93 c3 06 	sts	0x06C3, r22	; 0x8006c3 <settings+0x3e>
    5646:	21 c0       	rjmp	.+66     	; 0x568a <settings_store_global_setting+0x1d8>
      case 24: settings.homing_feed_rate = value; break;
    5648:	c0 92 c4 06 	sts	0x06C4, r12	; 0x8006c4 <settings+0x3f>
    564c:	d0 92 c5 06 	sts	0x06C5, r13	; 0x8006c5 <settings+0x40>
    5650:	e0 92 c6 06 	sts	0x06C6, r14	; 0x8006c6 <settings+0x41>
    5654:	f0 92 c7 06 	sts	0x06C7, r15	; 0x8006c7 <settings+0x42>
    5658:	18 c0       	rjmp	.+48     	; 0x568a <settings_store_global_setting+0x1d8>
      case 25: settings.homing_seek_rate = value; break;
    565a:	c0 92 c8 06 	sts	0x06C8, r12	; 0x8006c8 <settings+0x43>
    565e:	d0 92 c9 06 	sts	0x06C9, r13	; 0x8006c9 <settings+0x44>
    5662:	e0 92 ca 06 	sts	0x06CA, r14	; 0x8006ca <settings+0x45>
    5666:	f0 92 cb 06 	sts	0x06CB, r15	; 0x8006cb <settings+0x46>
    566a:	0f c0       	rjmp	.+30     	; 0x568a <settings_store_global_setting+0x1d8>
      case 26: settings.homing_debounce_delay = int_value; break;
    566c:	86 2f       	mov	r24, r22
    566e:	90 e0       	ldi	r25, 0x00	; 0
    5670:	90 93 cd 06 	sts	0x06CD, r25	; 0x8006cd <settings+0x48>
    5674:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <settings+0x47>
    5678:	08 c0       	rjmp	.+16     	; 0x568a <settings_store_global_setting+0x1d8>
      case 27: settings.homing_pulloff = value; break;
    567a:	c0 92 ce 06 	sts	0x06CE, r12	; 0x8006ce <settings+0x49>
    567e:	d0 92 cf 06 	sts	0x06CF, r13	; 0x8006cf <settings+0x4a>
    5682:	e0 92 d0 06 	sts	0x06D0, r14	; 0x8006d0 <settings+0x4b>
    5686:	f0 92 d1 06 	sts	0x06D1, r15	; 0x8006d1 <settings+0x4c>
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    568a:	0e 94 1e 29 	call	0x523c	; 0x523c <write_global_settings>
  return(STATUS_OK);
    568e:	80 e0       	ldi	r24, 0x00	; 0
    5690:	58 c0       	rjmp	.+176    	; 0x5742 <settings_store_global_setting+0x290>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    5692:	84 e0       	ldi	r24, 0x04	; 4
    5694:	56 c0       	rjmp	.+172    	; 0x5742 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5696:	83 e0       	ldi	r24, 0x03	; 3
    5698:	54 c0       	rjmp	.+168    	; 0x5742 <settings_store_global_setting+0x290>
      case 24: settings.homing_feed_rate = value; break;
      case 25: settings.homing_seek_rate = value; break;
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    569a:	83 e0       	ldi	r24, 0x03	; 3
    569c:	52 c0       	rjmp	.+164    	; 0x5742 <settings_store_global_setting+0x290>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    569e:	86 e0       	ldi	r24, 0x06	; 6
    56a0:	50 c0       	rjmp	.+160    	; 0x5742 <settings_store_global_setting+0x290>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    56a2:	8a e0       	ldi	r24, 0x0A	; 10
    56a4:	4e c0       	rjmp	.+156    	; 0x5742 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56a6:	83 e0       	ldi	r24, 0x03	; 3
    56a8:	4c c0       	rjmp	.+152    	; 0x5742 <settings_store_global_setting+0x290>
    56aa:	83 e0       	ldi	r24, 0x03	; 3
    56ac:	4a c0       	rjmp	.+148    	; 0x5742 <settings_store_global_setting+0x290>
        parameter -= AXIS_SETTINGS_INCREMENT;
    56ae:	e2 e9       	ldi	r30, 0x92	; 146
    56b0:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    56b2:	e3 30       	cpi	r30, 0x03	; 3
    56b4:	70 f0       	brcs	.+28     	; 0x56d2 <settings_store_global_setting+0x220>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56b6:	ea 30       	cpi	r30, 0x0A	; 10
    56b8:	b0 f3       	brcs	.-20     	; 0x56a6 <settings_store_global_setting+0x1f4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    56ba:	88 e8       	ldi	r24, 0x88	; 136
    56bc:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    56be:	83 30       	cpi	r24, 0x03	; 3
    56c0:	a0 f0       	brcs	.+40     	; 0x56ea <settings_store_global_setting+0x238>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56c2:	8a 30       	cpi	r24, 0x0A	; 10
    56c4:	90 f3       	brcs	.-28     	; 0x56aa <settings_store_global_setting+0x1f8>
        parameter -= AXIS_SETTINGS_INCREMENT;
    56c6:	8e e7       	ldi	r24, 0x7E	; 126
    56c8:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    56ca:	83 30       	cpi	r24, 0x03	; 3
    56cc:	48 f1       	brcs	.+82     	; 0x5720 <settings_store_global_setting+0x26e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56ce:	83 e0       	ldi	r24, 0x03	; 3
    56d0:	38 c0       	rjmp	.+112    	; 0x5742 <settings_store_global_setting+0x290>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    56d2:	f0 e0       	ldi	r31, 0x00	; 0
    56d4:	ee 0f       	add	r30, r30
    56d6:	ff 1f       	adc	r31, r31
    56d8:	ee 0f       	add	r30, r30
    56da:	ff 1f       	adc	r31, r31
    56dc:	ef 56       	subi	r30, 0x6F	; 111
    56de:	f9 4f       	sbci	r31, 0xF9	; 249
    56e0:	c0 82       	st	Z, r12
    56e2:	d1 82       	std	Z+1, r13	; 0x01
    56e4:	e2 82       	std	Z+2, r14	; 0x02
    56e6:	f3 82       	std	Z+3, r15	; 0x03
            break;
    56e8:	d0 cf       	rjmp	.-96     	; 0x568a <settings_store_global_setting+0x1d8>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    56ea:	c8 2f       	mov	r28, r24
    56ec:	d0 e0       	ldi	r29, 0x00	; 0
    56ee:	cc 0f       	add	r28, r28
    56f0:	dd 1f       	adc	r29, r29
    56f2:	cc 0f       	add	r28, r28
    56f4:	dd 1f       	adc	r29, r29
    56f6:	c3 56       	subi	r28, 0x63	; 99
    56f8:	d9 4f       	sbci	r29, 0xF9	; 249
    56fa:	20 e0       	ldi	r18, 0x00	; 0
    56fc:	30 e0       	ldi	r19, 0x00	; 0
    56fe:	40 e7       	ldi	r20, 0x70	; 112
    5700:	52 e4       	ldi	r21, 0x42	; 66
    5702:	c7 01       	movw	r24, r14
    5704:	b6 01       	movw	r22, r12
    5706:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    570a:	20 e0       	ldi	r18, 0x00	; 0
    570c:	30 e0       	ldi	r19, 0x00	; 0
    570e:	40 e7       	ldi	r20, 0x70	; 112
    5710:	52 e4       	ldi	r21, 0x42	; 66
    5712:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    5716:	68 83       	st	Y, r22
    5718:	79 83       	std	Y+1, r23	; 0x01
    571a:	8a 83       	std	Y+2, r24	; 0x02
    571c:	9b 83       	std	Y+3, r25	; 0x03
    571e:	b5 cf       	rjmp	.-150    	; 0x568a <settings_store_global_setting+0x1d8>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    5720:	e8 2f       	mov	r30, r24
    5722:	f0 e0       	ldi	r31, 0x00	; 0
    5724:	ee 0f       	add	r30, r30
    5726:	ff 1f       	adc	r31, r31
    5728:	ee 0f       	add	r30, r30
    572a:	ff 1f       	adc	r31, r31
    572c:	e7 55       	subi	r30, 0x57	; 87
    572e:	f9 4f       	sbci	r31, 0xF9	; 249
    5730:	f7 fa       	bst	r15, 7
    5732:	f0 94       	com	r15
    5734:	f7 f8       	bld	r15, 7
    5736:	f0 94       	com	r15
    5738:	c0 82       	st	Z, r12
    573a:	d1 82       	std	Z+1, r13	; 0x01
    573c:	e2 82       	std	Z+2, r14	; 0x02
    573e:	f3 82       	std	Z+3, r15	; 0x03
    5740:	a4 cf       	rjmp	.-184    	; 0x568a <settings_store_global_setting+0x1d8>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    5742:	df 91       	pop	r29
    5744:	cf 91       	pop	r28
    5746:	ff 90       	pop	r15
    5748:	ef 90       	pop	r14
    574a:	df 90       	pop	r13
    574c:	cf 90       	pop	r12
    574e:	08 95       	ret

00005750 <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    5750:	0e 94 43 2a 	call	0x5486	; 0x5486 <read_global_settings>
    5754:	81 11       	cpse	r24, r1
    5756:	08 c0       	rjmp	.+16     	; 0x5768 <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
    5758:	87 e0       	ldi	r24, 0x07	; 7
    575a:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    575e:	8f ef       	ldi	r24, 0xFF	; 255
    5760:	0e 94 2c 29 	call	0x5258	; 0x5258 <settings_restore>
    report_grbl_settings();
    5764:	0e 94 2f 23 	call	0x465e	; 0x465e <report_grbl_settings>
    5768:	08 95       	ret

0000576a <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    576a:	88 23       	and	r24, r24
    576c:	21 f0       	breq	.+8      	; 0x5776 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    576e:	81 30       	cpi	r24, 0x01	; 1
    5770:	21 f0       	breq	.+8      	; 0x577a <get_step_pin_mask+0x10>
  return((1<<Z_STEP_BIT));
    5772:	80 e1       	ldi	r24, 0x10	; 16
    5774:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    5776:	84 e0       	ldi	r24, 0x04	; 4
    5778:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    577a:	88 e0       	ldi	r24, 0x08	; 8
  return((1<<Z_STEP_BIT));
}
    577c:	08 95       	ret

0000577e <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    577e:	88 23       	and	r24, r24
    5780:	21 f0       	breq	.+8      	; 0x578a <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5782:	81 30       	cpi	r24, 0x01	; 1
    5784:	21 f0       	breq	.+8      	; 0x578e <get_direction_pin_mask+0x10>
  return((1<<Z_DIRECTION_BIT));
    5786:	80 e8       	ldi	r24, 0x80	; 128
    5788:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    578a:	80 e2       	ldi	r24, 0x20	; 32
    578c:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    578e:	80 e4       	ldi	r24, 0x40	; 64
  return((1<<Z_DIRECTION_BIT));
}
    5790:	08 95       	ret

00005792 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5792:	88 23       	and	r24, r24
    5794:	21 f0       	breq	.+8      	; 0x579e <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5796:	81 30       	cpi	r24, 0x01	; 1
    5798:	21 f0       	breq	.+8      	; 0x57a2 <get_limit_pin_mask+0x10>
  return((1<<Z_LIMIT_BIT));
    579a:	80 e1       	ldi	r24, 0x10	; 16
    579c:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    579e:	82 e0       	ldi	r24, 0x02	; 2
    57a0:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    57a2:	84 e0       	ldi	r24, 0x04	; 4
  return((1<<Z_LIMIT_BIT));
}
    57a4:	08 95       	ret

000057a6 <spindle_stop>:
  #endif
  
  #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
    SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
  #endif
  spindle_stop();
    57a6:	e0 eb       	ldi	r30, 0xB0	; 176
    57a8:	f0 e0       	ldi	r31, 0x00	; 0
    57aa:	80 81       	ld	r24, Z
    57ac:	8f 77       	andi	r24, 0x7F	; 127
    57ae:	80 83       	st	Z, r24
    57b0:	08 95       	ret

000057b2 <spindle_set_state>:
  #endif  
}


void spindle_set_state(uint8_t state, float rpm)
{
    57b2:	cf 92       	push	r12
    57b4:	df 92       	push	r13
    57b6:	ef 92       	push	r14
    57b8:	ff 92       	push	r15
    57ba:	6a 01       	movw	r12, r20
    57bc:	7b 01       	movw	r14, r22
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    57be:	81 11       	cpse	r24, r1
    57c0:	03 c0       	rjmp	.+6      	; 0x57c8 <spindle_set_state+0x16>

    spindle_stop();
    57c2:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <spindle_stop>
    57c6:	4d c0       	rjmp	.+154    	; 0x5862 <spindle_set_state+0xb0>

  } else {

    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
    57c8:	81 30       	cpi	r24, 0x01	; 1
    57ca:	11 f4       	brne	.+4      	; 0x57d0 <spindle_set_state+0x1e>
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    57cc:	2d 98       	cbi	0x05, 5	; 5
    57ce:	01 c0       	rjmp	.+2      	; 0x57d2 <spindle_set_state+0x20>
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    57d0:	2d 9a       	sbi	0x05, 5	; 5
      	TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02 | (1<<WAVE2_REGISTER) | (1<<WAVE3_REGISTER); // set to 1/8 Prescaler
        OCR4A = 0xFFFF; // set the top 16bit value
        uint16_t current_pwm;
      #else
        TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
    57d2:	83 e8       	ldi	r24, 0x83	; 131
    57d4:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02; // set to 1/8 Prescaler
    57d8:	e1 eb       	ldi	r30, 0xB1	; 177
    57da:	f0 e0       	ldi	r31, 0x00	; 0
    57dc:	80 81       	ld	r24, Z
    57de:	88 7f       	andi	r24, 0xF8	; 248
    57e0:	82 60       	ori	r24, 0x02	; 2
    57e2:	80 83       	st	Z, r24
        uint8_t current_pwm;
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
    57e4:	20 e0       	ldi	r18, 0x00	; 0
    57e6:	30 e0       	ldi	r19, 0x00	; 0
    57e8:	a9 01       	movw	r20, r18
    57ea:	c7 01       	movw	r24, r14
    57ec:	b6 01       	movw	r22, r12
    57ee:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    57f2:	18 16       	cp	r1, r24
    57f4:	1c f0       	brlt	.+6      	; 0x57fc <spindle_set_state+0x4a>
    57f6:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <spindle_stop>
    57fa:	33 c0       	rjmp	.+102    	; 0x5862 <spindle_set_state+0xb0>
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    57fc:	20 e0       	ldi	r18, 0x00	; 0
    57fe:	30 e0       	ldi	r19, 0x00	; 0
    5800:	a9 01       	movw	r20, r18
    5802:	c7 01       	movw	r24, r14
    5804:	b6 01       	movw	r22, r12
    5806:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    580a:	88 23       	and	r24, r24
    580c:	9c f0       	brlt	.+38     	; 0x5834 <spindle_set_state+0x82>
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
    580e:	20 e0       	ldi	r18, 0x00	; 0
    5810:	30 e0       	ldi	r19, 0x00	; 0
    5812:	4a e7       	ldi	r20, 0x7A	; 122
    5814:	54 e4       	ldi	r21, 0x44	; 68
    5816:	c7 01       	movw	r24, r14
    5818:	b6 01       	movw	r22, r12
    581a:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    581e:	18 16       	cp	r1, r24
    5820:	64 f4       	brge	.+24     	; 0x583a <spindle_set_state+0x88>
    5822:	0f 2e       	mov	r0, r31
    5824:	c1 2c       	mov	r12, r1
    5826:	d1 2c       	mov	r13, r1
    5828:	fa e7       	ldi	r31, 0x7A	; 122
    582a:	ef 2e       	mov	r14, r31
    582c:	f4 e4       	ldi	r31, 0x44	; 68
    582e:	ff 2e       	mov	r15, r31
    5830:	f0 2d       	mov	r31, r0
    5832:	03 c0       	rjmp	.+6      	; 0x583a <spindle_set_state+0x88>
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    5834:	c1 2c       	mov	r12, r1
    5836:	d1 2c       	mov	r13, r1
    5838:	76 01       	movw	r14, r12
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
        }
        current_pwm = floor( rpm*(PWM_MAX_VALUE/SPINDLE_RPM_RANGE) + 0.5);
    583a:	2c e5       	ldi	r18, 0x5C	; 92
    583c:	3f e8       	ldi	r19, 0x8F	; 143
    583e:	42 e8       	ldi	r20, 0x82	; 130
    5840:	5e e3       	ldi	r21, 0x3E	; 62
    5842:	c7 01       	movw	r24, r14
    5844:	b6 01       	movw	r22, r12
    5846:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    584a:	20 e0       	ldi	r18, 0x00	; 0
    584c:	30 e0       	ldi	r19, 0x00	; 0
    584e:	40 e0       	ldi	r20, 0x00	; 0
    5850:	5f e3       	ldi	r21, 0x3F	; 63
    5852:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    5856:	0e 94 b1 3a 	call	0x7562	; 0x7562 <floor>
    585a:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
        #ifdef MINIMUM_SPINDLE_PWM
          if (current_pwm < MINIMUM_SPINDLE_PWM) { current_pwm = MINIMUM_SPINDLE_PWM; }
        #endif
        OCR_REGISTER = current_pwm; // Set PWM pin output
    585e:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #endif

  }
}
    5862:	ff 90       	pop	r15
    5864:	ef 90       	pop	r14
    5866:	df 90       	pop	r13
    5868:	cf 90       	pop	r12
    586a:	08 95       	ret

0000586c <spindle_run>:


void spindle_run(uint8_t state, float rpm)
{
    586c:	cf 92       	push	r12
    586e:	df 92       	push	r13
    5870:	ef 92       	push	r14
    5872:	ff 92       	push	r15
    5874:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    5876:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <sys+0x1>
    587a:	92 30       	cpi	r25, 0x02	; 2
    587c:	51 f0       	breq	.+20     	; 0x5892 <spindle_run+0x26>
    587e:	6a 01       	movw	r12, r20
    5880:	7b 01       	movw	r14, r22
    5882:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    5884:	0e 94 31 22 	call	0x4462	; 0x4462 <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    5888:	b7 01       	movw	r22, r14
    588a:	a6 01       	movw	r20, r12
    588c:	8c 2f       	mov	r24, r28
    588e:	0e 94 d9 2b 	call	0x57b2	; 0x57b2 <spindle_set_state>
}
    5892:	cf 91       	pop	r28
    5894:	ff 90       	pop	r15
    5896:	ef 90       	pop	r14
    5898:	df 90       	pop	r13
    589a:	cf 90       	pop	r12
    589c:	08 95       	ret

0000589e <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    589e:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    58a2:	82 ff       	sbrs	r24, 2
    58a4:	02 c0       	rjmp	.+4      	; 0x58aa <st_wake_up+0xc>
    58a6:	28 9a       	sbi	0x05, 0	; 5
    58a8:	01 c0       	rjmp	.+2      	; 0x58ac <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    58aa:	28 98       	cbi	0x05, 0	; 5

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    58ac:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    58b0:	8c 70       	andi	r24, 0x0C	; 12
    58b2:	99 f0       	breq	.+38     	; 0x58da <st_wake_up+0x3c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    58b4:	ef e8       	ldi	r30, 0x8F	; 143
    58b6:	f4 e0       	ldi	r31, 0x04	; 4
    58b8:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <dir_port_invert_mask>
    58bc:	87 87       	std	Z+15, r24	; 0x0f
    st.step_outbits = step_port_invert_mask;
    58be:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <step_port_invert_mask>
    58c2:	86 87       	std	Z+14, r24	; 0x0e
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    58c4:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <settings+0x30>
    58c8:	88 0f       	add	r24, r24
    58ca:	84 50       	subi	r24, 0x04	; 4
    58cc:	81 95       	neg	r24
    58ce:	85 87       	std	Z+13, r24	; 0x0d
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    58d0:	ef e6       	ldi	r30, 0x6F	; 111
    58d2:	f0 e0       	ldi	r31, 0x00	; 0
    58d4:	80 81       	ld	r24, Z
    58d6:	82 60       	ori	r24, 0x02	; 2
    58d8:	80 83       	st	Z, r24
    58da:	08 95       	ret

000058dc <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    58dc:	ef e6       	ldi	r30, 0x6F	; 111
    58de:	f0 e0       	ldi	r31, 0x00	; 0
    58e0:	80 81       	ld	r24, Z
    58e2:	8d 7f       	andi	r24, 0xFD	; 253
    58e4:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    58e6:	e1 e8       	ldi	r30, 0x81	; 129
    58e8:	f0 e0       	ldi	r31, 0x00	; 0
    58ea:	80 81       	ld	r24, Z
    58ec:	88 7f       	andi	r24, 0xF8	; 248
    58ee:	81 60       	ori	r24, 0x01	; 1
    58f0:	80 83       	st	Z, r24
  busy = false;
    58f2:	10 92 89 04 	sts	0x0489, r1	; 0x800489 <busy>
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm) && sys.state != STATE_HOMING) {
    58f6:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <settings+0x33>
    58fa:	8f 3f       	cpi	r24, 0xFF	; 255
    58fc:	21 f4       	brne	.+8      	; 0x5906 <st_go_idle+0x2a>
    58fe:	90 91 2d 05 	lds	r25, 0x052D	; 0x80052d <sys_rt_exec_alarm>
    5902:	99 23       	and	r25, r25
    5904:	79 f0       	breq	.+30     	; 0x5924 <st_go_idle+0x48>
    5906:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <sys+0x1>
    590a:	94 30       	cpi	r25, 0x04	; 4
    590c:	59 f0       	breq	.+22     	; 0x5924 <st_go_idle+0x48>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    590e:	90 e0       	ldi	r25, 0x00	; 0
    5910:	0e 94 32 19 	call	0x3264	; 0x3264 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    5914:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    5918:	82 fd       	sbrc	r24, 2
    591a:	02 c0       	rjmp	.+4      	; 0x5920 <st_go_idle+0x44>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    591c:	28 9a       	sbi	0x05, 0	; 5
    591e:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    5920:	28 98       	cbi	0x05, 0	; 5
}
    5922:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    5924:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    5928:	82 ff       	sbrs	r24, 2
    592a:	fa cf       	rjmp	.-12     	; 0x5920 <st_go_idle+0x44>
    592c:	f7 cf       	rjmp	.-18     	; 0x591c <st_go_idle+0x40>

0000592e <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    592e:	1f 92       	push	r1
    5930:	0f 92       	push	r0
    5932:	0f b6       	in	r0, 0x3f	; 63
    5934:	0f 92       	push	r0
    5936:	11 24       	eor	r1, r1
    5938:	0f 93       	push	r16
    593a:	1f 93       	push	r17
    593c:	2f 93       	push	r18
    593e:	3f 93       	push	r19
    5940:	4f 93       	push	r20
    5942:	5f 93       	push	r21
    5944:	6f 93       	push	r22
    5946:	7f 93       	push	r23
    5948:	8f 93       	push	r24
    594a:	9f 93       	push	r25
    594c:	af 93       	push	r26
    594e:	bf 93       	push	r27
    5950:	cf 93       	push	r28
    5952:	df 93       	push	r29
    5954:	ef 93       	push	r30
    5956:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    5958:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <busy>
    595c:	81 11       	cpse	r24, r1
    595e:	b5 c1       	rjmp	.+874    	; 0x5cca <__vector_11+0x39c>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    5960:	8b b1       	in	r24, 0x0b	; 11
    5962:	ef e8       	ldi	r30, 0x8F	; 143
    5964:	f4 e0       	ldi	r31, 0x04	; 4
    5966:	97 85       	ldd	r25, Z+15	; 0x0f
    5968:	90 7e       	andi	r25, 0xE0	; 224
    596a:	8f 71       	andi	r24, 0x1F	; 31
    596c:	89 2b       	or	r24, r25
    596e:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    5970:	8b b1       	in	r24, 0x0b	; 11
    5972:	83 7e       	andi	r24, 0xE3	; 227
    5974:	96 85       	ldd	r25, Z+14	; 0x0e
    5976:	89 2b       	or	r24, r25
    5978:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    597a:	85 85       	ldd	r24, Z+13	; 0x0d
    597c:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    597e:	82 e0       	ldi	r24, 0x02	; 2
    5980:	85 bd       	out	0x25, r24	; 37

  busy = true;
    5982:	81 e0       	ldi	r24, 0x01	; 1
    5984:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    5988:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    598a:	81 a1       	ldd	r24, Z+33	; 0x21
    598c:	92 a1       	ldd	r25, Z+34	; 0x22
    598e:	89 2b       	or	r24, r25
    5990:	09 f0       	breq	.+2      	; 0x5994 <__vector_11+0x66>
    5992:	92 c0       	rjmp	.+292    	; 0x5ab8 <__vector_11+0x18a>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    5994:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <segment_buffer_tail>
    5998:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <segment_buffer_head>
    599c:	98 17       	cp	r25, r24
    599e:	09 f4       	brne	.+2      	; 0x59a2 <__vector_11+0x74>
    59a0:	80 c0       	rjmp	.+256    	; 0x5aa2 <__vector_11+0x174>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    59a2:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <segment_buffer_tail>
    59a6:	90 e0       	ldi	r25, 0x00	; 0
    59a8:	ef 01       	movw	r28, r30
    59aa:	fc 01       	movw	r30, r24
    59ac:	ee 0f       	add	r30, r30
    59ae:	ff 1f       	adc	r31, r31
    59b0:	df 01       	movw	r26, r30
    59b2:	a8 0f       	add	r26, r24
    59b4:	b9 1f       	adc	r27, r25
    59b6:	aa 0f       	add	r26, r26
    59b8:	bb 1f       	adc	r27, r27
    59ba:	ae 54       	subi	r26, 0x4E	; 78
    59bc:	bb 4f       	sbci	r27, 0xFB	; 251
    59be:	ba a3       	std	Y+34, r27	; 0x22
    59c0:	a9 a3       	std	Y+33, r26	; 0x21
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    59c2:	fd 01       	movw	r30, r26
    59c4:	83 81       	ldd	r24, Z+3	; 0x03
    59c6:	94 81       	ldd	r25, Z+4	; 0x04
    59c8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    59cc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    59d0:	8d 91       	ld	r24, X+
    59d2:	9c 91       	ld	r25, X
    59d4:	11 97       	sbiw	r26, 0x01	; 1
    59d6:	9d 8f       	std	Y+29, r25	; 0x1d
    59d8:	8c 8f       	std	Y+28, r24	; 0x1c
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    59da:	12 96       	adiw	r26, 0x02	; 2
    59dc:	ec 91       	ld	r30, X
    59de:	12 97       	sbiw	r26, 0x02	; 2
    59e0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    59e2:	8e 17       	cp	r24, r30
    59e4:	e9 f0       	breq	.+58     	; 0x5a20 <__vector_11+0xf2>
        st.exec_block_index = st.exec_segment->st_block_index;
    59e6:	ee 8f       	std	Y+30, r30	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    59e8:	01 e1       	ldi	r16, 0x11	; 17
    59ea:	e0 9f       	mul	r30, r16
    59ec:	f0 01       	movw	r30, r0
    59ee:	11 24       	eor	r1, r1
    59f0:	ea 52       	subi	r30, 0x2A	; 42
    59f2:	fb 4f       	sbci	r31, 0xFB	; 251
    59f4:	f8 a3       	std	Y+32, r31	; 0x20
    59f6:	ef 8f       	std	Y+31, r30	; 0x1f
        
        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    59f8:	45 85       	ldd	r20, Z+13	; 0x0d
    59fa:	56 85       	ldd	r21, Z+14	; 0x0e
    59fc:	67 85       	ldd	r22, Z+15	; 0x0f
    59fe:	70 89       	ldd	r23, Z+16	; 0x10
    5a00:	76 95       	lsr	r23
    5a02:	67 95       	ror	r22
    5a04:	57 95       	ror	r21
    5a06:	47 95       	ror	r20
    5a08:	48 87       	std	Y+8, r20	; 0x08
    5a0a:	59 87       	std	Y+9, r21	; 0x09
    5a0c:	6a 87       	std	Y+10, r22	; 0x0a
    5a0e:	7b 87       	std	Y+11, r23	; 0x0b
    5a10:	4c 83       	std	Y+4, r20	; 0x04
    5a12:	5d 83       	std	Y+5, r21	; 0x05
    5a14:	6e 83       	std	Y+6, r22	; 0x06
    5a16:	7f 83       	std	Y+7, r23	; 0x07
    5a18:	48 83       	st	Y, r20
    5a1a:	59 83       	std	Y+1, r21	; 0x01
    5a1c:	6a 83       	std	Y+2, r22	; 0x02
    5a1e:	7b 83       	std	Y+3, r23	; 0x03
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    5a20:	ef e8       	ldi	r30, 0x8F	; 143
    5a22:	f4 e0       	ldi	r31, 0x04	; 4
    5a24:	c7 8d       	ldd	r28, Z+31	; 0x1f
    5a26:	d0 a1       	ldd	r29, Z+32	; 0x20
    5a28:	98 81       	ld	r25, Y
    5a2a:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <dir_port_invert_mask>
    5a2e:	89 27       	eor	r24, r25
    5a30:	87 87       	std	Z+15, r24	; 0x0f

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    5a32:	49 81       	ldd	r20, Y+1	; 0x01
    5a34:	5a 81       	ldd	r21, Y+2	; 0x02
    5a36:	6b 81       	ldd	r22, Y+3	; 0x03
    5a38:	7c 81       	ldd	r23, Y+4	; 0x04
    5a3a:	15 96       	adiw	r26, 0x05	; 5
    5a3c:	0c 90       	ld	r0, X
    5a3e:	15 97       	sbiw	r26, 0x05	; 5
    5a40:	04 c0       	rjmp	.+8      	; 0x5a4a <__vector_11+0x11c>
    5a42:	76 95       	lsr	r23
    5a44:	67 95       	ror	r22
    5a46:	57 95       	ror	r21
    5a48:	47 95       	ror	r20
    5a4a:	0a 94       	dec	r0
    5a4c:	d2 f7       	brpl	.-12     	; 0x5a42 <__vector_11+0x114>
    5a4e:	40 8b       	std	Z+16, r20	; 0x10
    5a50:	51 8b       	std	Z+17, r21	; 0x11
    5a52:	62 8b       	std	Z+18, r22	; 0x12
    5a54:	73 8b       	std	Z+19, r23	; 0x13
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    5a56:	4d 81       	ldd	r20, Y+5	; 0x05
    5a58:	5e 81       	ldd	r21, Y+6	; 0x06
    5a5a:	6f 81       	ldd	r22, Y+7	; 0x07
    5a5c:	78 85       	ldd	r23, Y+8	; 0x08
    5a5e:	15 96       	adiw	r26, 0x05	; 5
    5a60:	0c 90       	ld	r0, X
    5a62:	15 97       	sbiw	r26, 0x05	; 5
    5a64:	04 c0       	rjmp	.+8      	; 0x5a6e <__vector_11+0x140>
    5a66:	76 95       	lsr	r23
    5a68:	67 95       	ror	r22
    5a6a:	57 95       	ror	r21
    5a6c:	47 95       	ror	r20
    5a6e:	0a 94       	dec	r0
    5a70:	d2 f7       	brpl	.-12     	; 0x5a66 <__vector_11+0x138>
    5a72:	44 8b       	std	Z+20, r20	; 0x14
    5a74:	55 8b       	std	Z+21, r21	; 0x15
    5a76:	66 8b       	std	Z+22, r22	; 0x16
    5a78:	77 8b       	std	Z+23, r23	; 0x17
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    5a7a:	49 85       	ldd	r20, Y+9	; 0x09
    5a7c:	5a 85       	ldd	r21, Y+10	; 0x0a
    5a7e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5a80:	7c 85       	ldd	r23, Y+12	; 0x0c
    5a82:	8a 01       	movw	r16, r20
    5a84:	9b 01       	movw	r18, r22
    5a86:	15 96       	adiw	r26, 0x05	; 5
    5a88:	0c 90       	ld	r0, X
    5a8a:	04 c0       	rjmp	.+8      	; 0x5a94 <__vector_11+0x166>
    5a8c:	36 95       	lsr	r19
    5a8e:	27 95       	ror	r18
    5a90:	17 95       	ror	r17
    5a92:	07 95       	ror	r16
    5a94:	0a 94       	dec	r0
    5a96:	d2 f7       	brpl	.-12     	; 0x5a8c <__vector_11+0x15e>
    5a98:	00 8f       	std	Z+24, r16	; 0x18
    5a9a:	11 8f       	std	Z+25, r17	; 0x19
    5a9c:	22 8f       	std	Z+26, r18	; 0x1a
    5a9e:	33 8f       	std	Z+27, r19	; 0x1b
    5aa0:	0b c0       	rjmp	.+22     	; 0x5ab8 <__vector_11+0x18a>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    5aa2:	0e 94 6e 2c 	call	0x58dc	; 0x58dc <st_go_idle>
      bit_true_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    5aa6:	9f b7       	in	r25, 0x3f	; 63
    5aa8:	f8 94       	cli
    5aaa:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    5aae:	84 60       	ori	r24, 0x04	; 4
    5ab0:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    5ab4:	9f bf       	out	0x3f, r25	; 63
      return; // Nothing to do but exit.
    5ab6:	09 c1       	rjmp	.+530    	; 0x5cca <__vector_11+0x39c>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    5ab8:	0e 94 34 20 	call	0x4068	; 0x4068 <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    5abc:	ef e8       	ldi	r30, 0x8F	; 143
    5abe:	f4 e0       	ldi	r31, 0x04	; 4
    5ac0:	16 86       	std	Z+14, r1	; 0x0e

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    5ac2:	40 81       	ld	r20, Z
    5ac4:	51 81       	ldd	r21, Z+1	; 0x01
    5ac6:	62 81       	ldd	r22, Z+2	; 0x02
    5ac8:	73 81       	ldd	r23, Z+3	; 0x03
    5aca:	80 89       	ldd	r24, Z+16	; 0x10
    5acc:	91 89       	ldd	r25, Z+17	; 0x11
    5ace:	a2 89       	ldd	r26, Z+18	; 0x12
    5ad0:	b3 89       	ldd	r27, Z+19	; 0x13
    5ad2:	84 0f       	add	r24, r20
    5ad4:	95 1f       	adc	r25, r21
    5ad6:	a6 1f       	adc	r26, r22
    5ad8:	b7 1f       	adc	r27, r23
    5ada:	80 83       	st	Z, r24
    5adc:	91 83       	std	Z+1, r25	; 0x01
    5ade:	a2 83       	std	Z+2, r26	; 0x02
    5ae0:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    5ae2:	07 8c       	ldd	r0, Z+31	; 0x1f
    5ae4:	f0 a1       	ldd	r31, Z+32	; 0x20
    5ae6:	e0 2d       	mov	r30, r0
    5ae8:	45 85       	ldd	r20, Z+13	; 0x0d
    5aea:	56 85       	ldd	r21, Z+14	; 0x0e
    5aec:	67 85       	ldd	r22, Z+15	; 0x0f
    5aee:	70 89       	ldd	r23, Z+16	; 0x10
    5af0:	48 17       	cp	r20, r24
    5af2:	59 07       	cpc	r21, r25
    5af4:	6a 07       	cpc	r22, r26
    5af6:	7b 07       	cpc	r23, r27
    5af8:	70 f5       	brcc	.+92     	; 0x5b56 <__vector_11+0x228>
    st.step_outbits |= (1<<X_STEP_BIT);
    5afa:	cf e8       	ldi	r28, 0x8F	; 143
    5afc:	d4 e0       	ldi	r29, 0x04	; 4
    5afe:	24 e0       	ldi	r18, 0x04	; 4
    5b00:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_x -= st.exec_block->step_event_count;
    5b02:	45 85       	ldd	r20, Z+13	; 0x0d
    5b04:	56 85       	ldd	r21, Z+14	; 0x0e
    5b06:	67 85       	ldd	r22, Z+15	; 0x0f
    5b08:	70 89       	ldd	r23, Z+16	; 0x10
    5b0a:	84 1b       	sub	r24, r20
    5b0c:	95 0b       	sbc	r25, r21
    5b0e:	a6 0b       	sbc	r26, r22
    5b10:	b7 0b       	sbc	r27, r23
    5b12:	88 83       	st	Y, r24
    5b14:	99 83       	std	Y+1, r25	; 0x01
    5b16:	aa 83       	std	Y+2, r26	; 0x02
    5b18:	bb 83       	std	Y+3, r27	; 0x03
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    5b1a:	80 81       	ld	r24, Z
    5b1c:	85 ff       	sbrs	r24, 5
    5b1e:	0e c0       	rjmp	.+28     	; 0x5b3c <__vector_11+0x20e>
    5b20:	c6 ea       	ldi	r28, 0xA6	; 166
    5b22:	d5 e0       	ldi	r29, 0x05	; 5
    5b24:	8c 81       	ldd	r24, Y+4	; 0x04
    5b26:	9d 81       	ldd	r25, Y+5	; 0x05
    5b28:	ae 81       	ldd	r26, Y+6	; 0x06
    5b2a:	bf 81       	ldd	r27, Y+7	; 0x07
    5b2c:	01 97       	sbiw	r24, 0x01	; 1
    5b2e:	a1 09       	sbc	r26, r1
    5b30:	b1 09       	sbc	r27, r1
    5b32:	8c 83       	std	Y+4, r24	; 0x04
    5b34:	9d 83       	std	Y+5, r25	; 0x05
    5b36:	ae 83       	std	Y+6, r26	; 0x06
    5b38:	bf 83       	std	Y+7, r27	; 0x07
    5b3a:	0d c0       	rjmp	.+26     	; 0x5b56 <__vector_11+0x228>
    else { sys.position[X_AXIS]++; }
    5b3c:	c6 ea       	ldi	r28, 0xA6	; 166
    5b3e:	d5 e0       	ldi	r29, 0x05	; 5
    5b40:	8c 81       	ldd	r24, Y+4	; 0x04
    5b42:	9d 81       	ldd	r25, Y+5	; 0x05
    5b44:	ae 81       	ldd	r26, Y+6	; 0x06
    5b46:	bf 81       	ldd	r27, Y+7	; 0x07
    5b48:	01 96       	adiw	r24, 0x01	; 1
    5b4a:	a1 1d       	adc	r26, r1
    5b4c:	b1 1d       	adc	r27, r1
    5b4e:	8c 83       	std	Y+4, r24	; 0x04
    5b50:	9d 83       	std	Y+5, r25	; 0x05
    5b52:	ae 83       	std	Y+6, r26	; 0x06
    5b54:	bf 83       	std	Y+7, r27	; 0x07
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    5b56:	cf e8       	ldi	r28, 0x8F	; 143
    5b58:	d4 e0       	ldi	r29, 0x04	; 4
    5b5a:	4c 81       	ldd	r20, Y+4	; 0x04
    5b5c:	5d 81       	ldd	r21, Y+5	; 0x05
    5b5e:	6e 81       	ldd	r22, Y+6	; 0x06
    5b60:	7f 81       	ldd	r23, Y+7	; 0x07
    5b62:	8c 89       	ldd	r24, Y+20	; 0x14
    5b64:	9d 89       	ldd	r25, Y+21	; 0x15
    5b66:	ae 89       	ldd	r26, Y+22	; 0x16
    5b68:	bf 89       	ldd	r27, Y+23	; 0x17
    5b6a:	84 0f       	add	r24, r20
    5b6c:	95 1f       	adc	r25, r21
    5b6e:	a6 1f       	adc	r26, r22
    5b70:	b7 1f       	adc	r27, r23
    5b72:	8c 83       	std	Y+4, r24	; 0x04
    5b74:	9d 83       	std	Y+5, r25	; 0x05
    5b76:	ae 83       	std	Y+6, r26	; 0x06
    5b78:	bf 83       	std	Y+7, r27	; 0x07
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    5b7a:	45 85       	ldd	r20, Z+13	; 0x0d
    5b7c:	56 85       	ldd	r21, Z+14	; 0x0e
    5b7e:	67 85       	ldd	r22, Z+15	; 0x0f
    5b80:	70 89       	ldd	r23, Z+16	; 0x10
    5b82:	48 17       	cp	r20, r24
    5b84:	59 07       	cpc	r21, r25
    5b86:	6a 07       	cpc	r22, r26
    5b88:	7b 07       	cpc	r23, r27
    5b8a:	68 f5       	brcc	.+90     	; 0x5be6 <__vector_11+0x2b8>
    st.step_outbits |= (1<<Y_STEP_BIT);
    5b8c:	2e 85       	ldd	r18, Y+14	; 0x0e
    5b8e:	28 60       	ori	r18, 0x08	; 8
    5b90:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_y -= st.exec_block->step_event_count;
    5b92:	45 85       	ldd	r20, Z+13	; 0x0d
    5b94:	56 85       	ldd	r21, Z+14	; 0x0e
    5b96:	67 85       	ldd	r22, Z+15	; 0x0f
    5b98:	70 89       	ldd	r23, Z+16	; 0x10
    5b9a:	84 1b       	sub	r24, r20
    5b9c:	95 0b       	sbc	r25, r21
    5b9e:	a6 0b       	sbc	r26, r22
    5ba0:	b7 0b       	sbc	r27, r23
    5ba2:	8c 83       	std	Y+4, r24	; 0x04
    5ba4:	9d 83       	std	Y+5, r25	; 0x05
    5ba6:	ae 83       	std	Y+6, r26	; 0x06
    5ba8:	bf 83       	std	Y+7, r27	; 0x07
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    5baa:	80 81       	ld	r24, Z
    5bac:	86 ff       	sbrs	r24, 6
    5bae:	0e c0       	rjmp	.+28     	; 0x5bcc <__vector_11+0x29e>
    5bb0:	c6 ea       	ldi	r28, 0xA6	; 166
    5bb2:	d5 e0       	ldi	r29, 0x05	; 5
    5bb4:	88 85       	ldd	r24, Y+8	; 0x08
    5bb6:	99 85       	ldd	r25, Y+9	; 0x09
    5bb8:	aa 85       	ldd	r26, Y+10	; 0x0a
    5bba:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bbc:	01 97       	sbiw	r24, 0x01	; 1
    5bbe:	a1 09       	sbc	r26, r1
    5bc0:	b1 09       	sbc	r27, r1
    5bc2:	88 87       	std	Y+8, r24	; 0x08
    5bc4:	99 87       	std	Y+9, r25	; 0x09
    5bc6:	aa 87       	std	Y+10, r26	; 0x0a
    5bc8:	bb 87       	std	Y+11, r27	; 0x0b
    5bca:	0d c0       	rjmp	.+26     	; 0x5be6 <__vector_11+0x2b8>
    else { sys.position[Y_AXIS]++; }
    5bcc:	c6 ea       	ldi	r28, 0xA6	; 166
    5bce:	d5 e0       	ldi	r29, 0x05	; 5
    5bd0:	88 85       	ldd	r24, Y+8	; 0x08
    5bd2:	99 85       	ldd	r25, Y+9	; 0x09
    5bd4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5bd6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bd8:	01 96       	adiw	r24, 0x01	; 1
    5bda:	a1 1d       	adc	r26, r1
    5bdc:	b1 1d       	adc	r27, r1
    5bde:	88 87       	std	Y+8, r24	; 0x08
    5be0:	99 87       	std	Y+9, r25	; 0x09
    5be2:	aa 87       	std	Y+10, r26	; 0x0a
    5be4:	bb 87       	std	Y+11, r27	; 0x0b
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    5be6:	cf e8       	ldi	r28, 0x8F	; 143
    5be8:	d4 e0       	ldi	r29, 0x04	; 4
    5bea:	48 85       	ldd	r20, Y+8	; 0x08
    5bec:	59 85       	ldd	r21, Y+9	; 0x09
    5bee:	6a 85       	ldd	r22, Y+10	; 0x0a
    5bf0:	7b 85       	ldd	r23, Y+11	; 0x0b
    5bf2:	88 8d       	ldd	r24, Y+24	; 0x18
    5bf4:	99 8d       	ldd	r25, Y+25	; 0x19
    5bf6:	aa 8d       	ldd	r26, Y+26	; 0x1a
    5bf8:	bb 8d       	ldd	r27, Y+27	; 0x1b
    5bfa:	84 0f       	add	r24, r20
    5bfc:	95 1f       	adc	r25, r21
    5bfe:	a6 1f       	adc	r26, r22
    5c00:	b7 1f       	adc	r27, r23
    5c02:	88 87       	std	Y+8, r24	; 0x08
    5c04:	99 87       	std	Y+9, r25	; 0x09
    5c06:	aa 87       	std	Y+10, r26	; 0x0a
    5c08:	bb 87       	std	Y+11, r27	; 0x0b
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    5c0a:	45 85       	ldd	r20, Z+13	; 0x0d
    5c0c:	56 85       	ldd	r21, Z+14	; 0x0e
    5c0e:	67 85       	ldd	r22, Z+15	; 0x0f
    5c10:	70 89       	ldd	r23, Z+16	; 0x10
    5c12:	48 17       	cp	r20, r24
    5c14:	59 07       	cpc	r21, r25
    5c16:	6a 07       	cpc	r22, r26
    5c18:	7b 07       	cpc	r23, r27
    5c1a:	68 f5       	brcc	.+90     	; 0x5c76 <__vector_11+0x348>
    st.step_outbits |= (1<<Z_STEP_BIT);
    5c1c:	2e 85       	ldd	r18, Y+14	; 0x0e
    5c1e:	20 61       	ori	r18, 0x10	; 16
    5c20:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_z -= st.exec_block->step_event_count;
    5c22:	45 85       	ldd	r20, Z+13	; 0x0d
    5c24:	56 85       	ldd	r21, Z+14	; 0x0e
    5c26:	67 85       	ldd	r22, Z+15	; 0x0f
    5c28:	70 89       	ldd	r23, Z+16	; 0x10
    5c2a:	84 1b       	sub	r24, r20
    5c2c:	95 0b       	sbc	r25, r21
    5c2e:	a6 0b       	sbc	r26, r22
    5c30:	b7 0b       	sbc	r27, r23
    5c32:	88 87       	std	Y+8, r24	; 0x08
    5c34:	99 87       	std	Y+9, r25	; 0x09
    5c36:	aa 87       	std	Y+10, r26	; 0x0a
    5c38:	bb 87       	std	Y+11, r27	; 0x0b
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    5c3a:	80 81       	ld	r24, Z
    5c3c:	88 23       	and	r24, r24
    5c3e:	74 f4       	brge	.+28     	; 0x5c5c <__vector_11+0x32e>
    5c40:	e6 ea       	ldi	r30, 0xA6	; 166
    5c42:	f5 e0       	ldi	r31, 0x05	; 5
    5c44:	84 85       	ldd	r24, Z+12	; 0x0c
    5c46:	95 85       	ldd	r25, Z+13	; 0x0d
    5c48:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c4a:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c4c:	01 97       	sbiw	r24, 0x01	; 1
    5c4e:	a1 09       	sbc	r26, r1
    5c50:	b1 09       	sbc	r27, r1
    5c52:	84 87       	std	Z+12, r24	; 0x0c
    5c54:	95 87       	std	Z+13, r25	; 0x0d
    5c56:	a6 87       	std	Z+14, r26	; 0x0e
    5c58:	b7 87       	std	Z+15, r27	; 0x0f
    5c5a:	0d c0       	rjmp	.+26     	; 0x5c76 <__vector_11+0x348>
    else { sys.position[Z_AXIS]++; }
    5c5c:	e6 ea       	ldi	r30, 0xA6	; 166
    5c5e:	f5 e0       	ldi	r31, 0x05	; 5
    5c60:	84 85       	ldd	r24, Z+12	; 0x0c
    5c62:	95 85       	ldd	r25, Z+13	; 0x0d
    5c64:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c66:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c68:	01 96       	adiw	r24, 0x01	; 1
    5c6a:	a1 1d       	adc	r26, r1
    5c6c:	b1 1d       	adc	r27, r1
    5c6e:	84 87       	std	Z+12, r24	; 0x0c
    5c70:	95 87       	std	Z+13, r25	; 0x0d
    5c72:	a6 87       	std	Z+14, r26	; 0x0e
    5c74:	b7 87       	std	Z+15, r27	; 0x0f
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    5c76:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    5c7a:	84 30       	cpi	r24, 0x04	; 4
    5c7c:	39 f4       	brne	.+14     	; 0x5c8c <__vector_11+0x35e>
    5c7e:	ef e8       	ldi	r30, 0x8F	; 143
    5c80:	f4 e0       	ldi	r31, 0x04	; 4
    5c82:	96 85       	ldd	r25, Z+14	; 0x0e
    5c84:	80 91 c3 05 	lds	r24, 0x05C3	; 0x8005c3 <sys+0x1d>
    5c88:	89 23       	and	r24, r25
    5c8a:	86 87       	std	Z+14, r24	; 0x0e

  st.step_count--; // Decrement step events count 
    5c8c:	ef e8       	ldi	r30, 0x8F	; 143
    5c8e:	f4 e0       	ldi	r31, 0x04	; 4
    5c90:	84 8d       	ldd	r24, Z+28	; 0x1c
    5c92:	95 8d       	ldd	r25, Z+29	; 0x1d
    5c94:	01 97       	sbiw	r24, 0x01	; 1
    5c96:	95 8f       	std	Z+29, r25	; 0x1d
    5c98:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    5c9a:	89 2b       	or	r24, r25
    5c9c:	69 f4       	brne	.+26     	; 0x5cb8 <__vector_11+0x38a>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    5c9e:	10 92 b1 04 	sts	0x04B1, r1	; 0x8004b1 <st+0x22>
    5ca2:	10 92 b0 04 	sts	0x04B0, r1	; 0x8004b0 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    5ca6:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <segment_buffer_tail>
    5caa:	8f 5f       	subi	r24, 0xFF	; 255
    5cac:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <segment_buffer_tail>
    5cb0:	86 30       	cpi	r24, 0x06	; 6
    5cb2:	11 f4       	brne	.+4      	; 0x5cb8 <__vector_11+0x38a>
    5cb4:	10 92 8e 04 	sts	0x048E, r1	; 0x80048e <segment_buffer_tail>
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    5cb8:	ef e8       	ldi	r30, 0x8F	; 143
    5cba:	f4 e0       	ldi	r31, 0x04	; 4
    5cbc:	96 85       	ldd	r25, Z+14	; 0x0e
    5cbe:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <step_port_invert_mask>
    5cc2:	89 27       	eor	r24, r25
    5cc4:	86 87       	std	Z+14, r24	; 0x0e
  busy = false;
    5cc6:	10 92 89 04 	sts	0x0489, r1	; 0x800489 <busy>
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    5cca:	ff 91       	pop	r31
    5ccc:	ef 91       	pop	r30
    5cce:	df 91       	pop	r29
    5cd0:	cf 91       	pop	r28
    5cd2:	bf 91       	pop	r27
    5cd4:	af 91       	pop	r26
    5cd6:	9f 91       	pop	r25
    5cd8:	8f 91       	pop	r24
    5cda:	7f 91       	pop	r23
    5cdc:	6f 91       	pop	r22
    5cde:	5f 91       	pop	r21
    5ce0:	4f 91       	pop	r20
    5ce2:	3f 91       	pop	r19
    5ce4:	2f 91       	pop	r18
    5ce6:	1f 91       	pop	r17
    5ce8:	0f 91       	pop	r16
    5cea:	0f 90       	pop	r0
    5cec:	0f be       	out	0x3f, r0	; 63
    5cee:	0f 90       	pop	r0
    5cf0:	1f 90       	pop	r1
    5cf2:	18 95       	reti

00005cf4 <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    5cf4:	1f 92       	push	r1
    5cf6:	0f 92       	push	r0
    5cf8:	0f b6       	in	r0, 0x3f	; 63
    5cfa:	0f 92       	push	r0
    5cfc:	11 24       	eor	r1, r1
    5cfe:	8f 93       	push	r24
    5d00:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    5d02:	8b b1       	in	r24, 0x0b	; 11
    5d04:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <step_port_invert_mask>
    5d08:	9c 71       	andi	r25, 0x1C	; 28
    5d0a:	83 7e       	andi	r24, 0xE3	; 227
    5d0c:	89 2b       	or	r24, r25
    5d0e:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    5d10:	15 bc       	out	0x25, r1	; 37
}
    5d12:	9f 91       	pop	r25
    5d14:	8f 91       	pop	r24
    5d16:	0f 90       	pop	r0
    5d18:	0f be       	out	0x3f, r0	; 63
    5d1a:	0f 90       	pop	r0
    5d1c:	1f 90       	pop	r1
    5d1e:	18 95       	reti

00005d20 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    5d20:	ef 92       	push	r14
    5d22:	ff 92       	push	r15
    5d24:	0f 93       	push	r16
    5d26:	1f 93       	push	r17
    5d28:	cf 93       	push	r28
    5d2a:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    5d2c:	10 92 8b 04 	sts	0x048B, r1	; 0x80048b <step_port_invert_mask>
  dir_port_invert_mask = 0;
    5d30:	10 92 8a 04 	sts	0x048A, r1	; 0x80048a <dir_port_invert_mask>
    5d34:	c0 e0       	ldi	r28, 0x00	; 0
    5d36:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    5d38:	05 e8       	ldi	r16, 0x85	; 133
    5d3a:	16 e0       	ldi	r17, 0x06	; 6
    5d3c:	ec 2e       	mov	r14, r28
    5d3e:	fc 2e       	mov	r15, r28
    5d40:	f8 01       	movw	r30, r16
    5d42:	81 a9       	ldd	r24, Z+49	; 0x31
    5d44:	90 e0       	ldi	r25, 0x00	; 0
    5d46:	0c 2e       	mov	r0, r28
    5d48:	02 c0       	rjmp	.+4      	; 0x5d4e <st_generate_step_dir_invert_masks+0x2e>
    5d4a:	95 95       	asr	r25
    5d4c:	87 95       	ror	r24
    5d4e:	0a 94       	dec	r0
    5d50:	e2 f7       	brpl	.-8      	; 0x5d4a <st_generate_step_dir_invert_masks+0x2a>
    5d52:	80 ff       	sbrs	r24, 0
    5d54:	08 c0       	rjmp	.+16     	; 0x5d66 <st_generate_step_dir_invert_masks+0x46>
    5d56:	8c 2f       	mov	r24, r28
    5d58:	0e 94 b5 2b 	call	0x576a	; 0x576a <get_step_pin_mask>
    5d5c:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <step_port_invert_mask>
    5d60:	89 2b       	or	r24, r25
    5d62:	80 93 8b 04 	sts	0x048B, r24	; 0x80048b <step_port_invert_mask>
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    5d66:	f8 01       	movw	r30, r16
    5d68:	82 a9       	ldd	r24, Z+50	; 0x32
    5d6a:	90 e0       	ldi	r25, 0x00	; 0
    5d6c:	02 c0       	rjmp	.+4      	; 0x5d72 <st_generate_step_dir_invert_masks+0x52>
    5d6e:	95 95       	asr	r25
    5d70:	87 95       	ror	r24
    5d72:	fa 94       	dec	r15
    5d74:	e2 f7       	brpl	.-8      	; 0x5d6e <st_generate_step_dir_invert_masks+0x4e>
    5d76:	80 ff       	sbrs	r24, 0
    5d78:	08 c0       	rjmp	.+16     	; 0x5d8a <st_generate_step_dir_invert_masks+0x6a>
    5d7a:	8e 2d       	mov	r24, r14
    5d7c:	0e 94 bf 2b 	call	0x577e	; 0x577e <get_direction_pin_mask>
    5d80:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <dir_port_invert_mask>
    5d84:	89 2b       	or	r24, r25
    5d86:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <dir_port_invert_mask>
    5d8a:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    5d8c:	c3 30       	cpi	r28, 0x03	; 3
    5d8e:	d1 05       	cpc	r29, r1
    5d90:	a9 f6       	brne	.-86     	; 0x5d3c <st_generate_step_dir_invert_masks+0x1c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    5d92:	df 91       	pop	r29
    5d94:	cf 91       	pop	r28
    5d96:	1f 91       	pop	r17
    5d98:	0f 91       	pop	r16
    5d9a:	ff 90       	pop	r15
    5d9c:	ef 90       	pop	r14
    5d9e:	08 95       	ret

00005da0 <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    5da0:	0e 94 6e 2c 	call	0x58dc	; 0x58dc <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    5da4:	8b e2       	ldi	r24, 0x2B	; 43
    5da6:	ec e5       	ldi	r30, 0x5C	; 92
    5da8:	f4 e0       	ldi	r31, 0x04	; 4
    5daa:	df 01       	movw	r26, r30
    5dac:	1d 92       	st	X+, r1
    5dae:	8a 95       	dec	r24
    5db0:	e9 f7       	brne	.-6      	; 0x5dac <st_reset+0xc>
  memset(&st, 0, sizeof(stepper_t));
    5db2:	83 e2       	ldi	r24, 0x23	; 35
    5db4:	ef e8       	ldi	r30, 0x8F	; 143
    5db6:	f4 e0       	ldi	r31, 0x04	; 4
    5db8:	df 01       	movw	r26, r30
    5dba:	1d 92       	st	X+, r1
    5dbc:	8a 95       	dec	r24
    5dbe:	e9 f7       	brne	.-6      	; 0x5dba <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    5dc0:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <pl_block+0x1>
    5dc4:	10 92 87 04 	sts	0x0487, r1	; 0x800487 <pl_block>
  segment_buffer_tail = 0;
    5dc8:	10 92 8e 04 	sts	0x048E, r1	; 0x80048e <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    5dcc:	10 92 8d 04 	sts	0x048D, r1	; 0x80048d <segment_buffer_head>
  segment_next_head = 1;
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <segment_next_head>
  busy = false;
    5dd6:	10 92 89 04 	sts	0x0489, r1	; 0x800489 <busy>
  
  st_generate_step_dir_invert_masks();
    5dda:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    5dde:	8b b1       	in	r24, 0x0b	; 11
    5de0:	83 7e       	andi	r24, 0xE3	; 227
    5de2:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <step_port_invert_mask>
    5de6:	89 2b       	or	r24, r25
    5de8:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    5dea:	8b b1       	in	r24, 0x0b	; 11
    5dec:	8f 71       	andi	r24, 0x1F	; 31
    5dee:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <dir_port_invert_mask>
    5df2:	89 2b       	or	r24, r25
    5df4:	8b b9       	out	0x0b, r24	; 11
    5df6:	08 95       	ret

00005df8 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    5df8:	8a b1       	in	r24, 0x0a	; 10
    5dfa:	8c 61       	ori	r24, 0x1C	; 28
    5dfc:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    5dfe:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    5e00:	8a b1       	in	r24, 0x0a	; 10
    5e02:	80 6e       	ori	r24, 0xE0	; 224
    5e04:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    5e06:	e1 e8       	ldi	r30, 0x81	; 129
    5e08:	f0 e0       	ldi	r31, 0x00	; 0
    5e0a:	80 81       	ld	r24, Z
    5e0c:	8f 7e       	andi	r24, 0xEF	; 239
    5e0e:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    5e10:	80 81       	ld	r24, Z
    5e12:	88 60       	ori	r24, 0x08	; 8
    5e14:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    5e16:	e0 e8       	ldi	r30, 0x80	; 128
    5e18:	f0 e0       	ldi	r31, 0x00	; 0
    5e1a:	80 81       	ld	r24, Z
    5e1c:	8c 7f       	andi	r24, 0xFC	; 252
    5e1e:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    5e20:	80 81       	ld	r24, Z
    5e22:	8f 70       	andi	r24, 0x0F	; 15
    5e24:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    5e26:	ee e6       	ldi	r30, 0x6E	; 110
    5e28:	f0 e0       	ldi	r31, 0x00	; 0
    5e2a:	80 81       	ld	r24, Z
    5e2c:	88 7f       	andi	r24, 0xF8	; 248
    5e2e:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    5e30:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    5e32:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    5e34:	80 81       	ld	r24, Z
    5e36:	81 60       	ori	r24, 0x01	; 1
    5e38:	80 83       	st	Z, r24
    5e3a:	08 95       	ret

00005e3c <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    5e3c:	cf 93       	push	r28
    5e3e:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    5e40:	c0 91 87 04 	lds	r28, 0x0487	; 0x800487 <pl_block>
    5e44:	d0 91 88 04 	lds	r29, 0x0488	; 0x800488 <pl_block+0x1>
    5e48:	20 97       	sbiw	r28, 0x00	; 0
    5e4a:	a1 f0       	breq	.+40     	; 0x5e74 <st_update_plan_block_parameters+0x38>
    prep.flag_partial_block = true;
    5e4c:	ec e5       	ldi	r30, 0x5C	; 92
    5e4e:	f4 e0       	ldi	r31, 0x04	; 4
    5e50:	81 e0       	ldi	r24, 0x01	; 1
    5e52:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    5e54:	67 89       	ldd	r22, Z+23	; 0x17
    5e56:	70 8d       	ldd	r23, Z+24	; 0x18
    5e58:	81 8d       	ldd	r24, Z+25	; 0x19
    5e5a:	92 8d       	ldd	r25, Z+26	; 0x1a
    5e5c:	9b 01       	movw	r18, r22
    5e5e:	ac 01       	movw	r20, r24
    5e60:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    5e64:	69 8b       	std	Y+17, r22	; 0x11
    5e66:	7a 8b       	std	Y+18, r23	; 0x12
    5e68:	8b 8b       	std	Y+19, r24	; 0x13
    5e6a:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    5e6c:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <pl_block+0x1>
    5e70:	10 92 87 04 	sts	0x0487, r1	; 0x800487 <pl_block>
  }
}
    5e74:	df 91       	pop	r29
    5e76:	cf 91       	pop	r28
    5e78:	08 95       	ret

00005e7a <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    5e7a:	2f 92       	push	r2
    5e7c:	3f 92       	push	r3
    5e7e:	4f 92       	push	r4
    5e80:	5f 92       	push	r5
    5e82:	6f 92       	push	r6
    5e84:	7f 92       	push	r7
    5e86:	8f 92       	push	r8
    5e88:	9f 92       	push	r9
    5e8a:	af 92       	push	r10
    5e8c:	bf 92       	push	r11
    5e8e:	cf 92       	push	r12
    5e90:	df 92       	push	r13
    5e92:	ef 92       	push	r14
    5e94:	ff 92       	push	r15
    5e96:	0f 93       	push	r16
    5e98:	1f 93       	push	r17
    5e9a:	cf 93       	push	r28
    5e9c:	df 93       	push	r29
    5e9e:	cd b7       	in	r28, 0x3d	; 61
    5ea0:	de b7       	in	r29, 0x3e	; 62
    5ea2:	ed 97       	sbiw	r28, 0x3d	; 61
    5ea4:	0f b6       	in	r0, 0x3f	; 63
    5ea6:	f8 94       	cli
    5ea8:	de bf       	out	0x3e, r29	; 62
    5eaa:	0f be       	out	0x3f, r0	; 63
    5eac:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    5eae:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    5eb2:	80 77       	andi	r24, 0x70	; 112
    5eb4:	09 f4       	brne	.+2      	; 0x5eb8 <st_prep_buffer+0x3e>
    5eb6:	b2 c6       	rjmp	.+3428   	; 0x6c1c <st_prep_buffer+0xda2>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    5eb8:	20 e0       	ldi	r18, 0x00	; 0
    5eba:	30 e0       	ldi	r19, 0x00	; 0
    5ebc:	a9 01       	movw	r20, r18
    5ebe:	60 91 73 04 	lds	r22, 0x0473	; 0x800473 <prep+0x17>
    5ec2:	70 91 74 04 	lds	r23, 0x0474	; 0x800474 <prep+0x18>
    5ec6:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <prep+0x19>
    5eca:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <prep+0x1a>
    5ece:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    5ed2:	81 11       	cpse	r24, r1
    5ed4:	a3 c6       	rjmp	.+3398   	; 0x6c1c <st_prep_buffer+0xda2>
    5ed6:	b0 c6       	rjmp	.+3424   	; 0x6c38 <st_prep_buffer+0xdbe>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    5ed8:	80 91 87 04 	lds	r24, 0x0487	; 0x800487 <pl_block>
    5edc:	90 91 88 04 	lds	r25, 0x0488	; 0x800488 <pl_block+0x1>
    5ee0:	89 2b       	or	r24, r25
    5ee2:	09 f0       	breq	.+2      	; 0x5ee6 <st_prep_buffer+0x6c>
    5ee4:	61 c2       	rjmp	.+1218   	; 0x63a8 <st_prep_buffer+0x52e>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    5ee6:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <plan_get_current_block>
    5eea:	8c 01       	movw	r16, r24
    5eec:	90 93 88 04 	sts	0x0488, r25	; 0x800488 <pl_block+0x1>
    5ef0:	80 93 87 04 	sts	0x0487, r24	; 0x800487 <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    5ef4:	00 97       	sbiw	r24, 0x00	; 0
    5ef6:	09 f4       	brne	.+2      	; 0x5efa <st_prep_buffer+0x80>
    5ef8:	9f c6       	rjmp	.+3390   	; 0x6c38 <st_prep_buffer+0xdbe>
		  
	  if( pl_block->steps[Y_AXIS] != 0 )
    5efa:	fc 01       	movw	r30, r24
    5efc:	85 81       	ldd	r24, Z+5	; 0x05
    5efe:	96 81       	ldd	r25, Z+6	; 0x06
    5f00:	a7 81       	ldd	r26, Z+7	; 0x07
    5f02:	b0 85       	ldd	r27, Z+8	; 0x08
    5f04:	89 2b       	or	r24, r25
    5f06:	8a 2b       	or	r24, r26
    5f08:	8b 2b       	or	r24, r27
    5f0a:	29 f0       	breq	.+10     	; 0x5f16 <st_prep_buffer+0x9c>
	  {
		printPgmString("Dale");
    5f0c:	80 e0       	ldi	r24, 0x00	; 0
    5f0e:	91 e0       	ldi	r25, 0x01	; 1
    5f10:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <printPgmString>
		return;  
    5f14:	91 c6       	rjmp	.+3362   	; 0x6c38 <st_prep_buffer+0xdbe>
	  }
                      
      //printString("Segment");
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    5f16:	d3 01       	movw	r26, r6
    5f18:	11 96       	adiw	r26, 0x01	; 1
    5f1a:	8c 91       	ld	r24, X
    5f1c:	11 97       	sbiw	r26, 0x01	; 1
    5f1e:	88 23       	and	r24, r24
    5f20:	19 f0       	breq	.+6      	; 0x5f28 <st_prep_buffer+0xae>
        prep.flag_partial_block = false; // Reset flag
    5f22:	11 96       	adiw	r26, 0x01	; 1
    5f24:	1c 92       	st	X, r1
    5f26:	ca c0       	rjmp	.+404    	; 0x60bc <st_prep_buffer+0x242>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    5f28:	f3 01       	movw	r30, r6
    5f2a:	80 81       	ld	r24, Z
    5f2c:	8f 5f       	subi	r24, 0xFF	; 255
    5f2e:	85 30       	cpi	r24, 0x05	; 5
    5f30:	11 f0       	breq	.+4      	; 0x5f36 <st_prep_buffer+0xbc>
    5f32:	80 83       	st	Z, r24
    5f34:	01 c0       	rjmp	.+2      	; 0x5f38 <st_prep_buffer+0xbe>
    5f36:	10 82       	st	Z, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    5f38:	d3 01       	movw	r26, r6
    5f3a:	ec 91       	ld	r30, X
        st_prep_block->direction_bits = pl_block->direction_bits;
    5f3c:	d8 01       	movw	r26, r16
    5f3e:	8c 91       	ld	r24, X
    5f40:	b1 e1       	ldi	r27, 0x11	; 17
    5f42:	be 9f       	mul	r27, r30
    5f44:	f0 01       	movw	r30, r0
    5f46:	11 24       	eor	r1, r1
    5f48:	ea 52       	subi	r30, 0x2A	; 42
    5f4a:	fb 4f       	sbci	r31, 0xFB	; 251
    5f4c:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    5f4e:	d8 01       	movw	r26, r16
    5f50:	11 96       	adiw	r26, 0x01	; 1
    5f52:	4d 91       	ld	r20, X+
    5f54:	5d 91       	ld	r21, X+
    5f56:	6d 91       	ld	r22, X+
    5f58:	7c 91       	ld	r23, X
    5f5a:	14 97       	sbiw	r26, 0x04	; 4
    5f5c:	db 01       	movw	r26, r22
    5f5e:	ca 01       	movw	r24, r20
    5f60:	88 0f       	add	r24, r24
    5f62:	99 1f       	adc	r25, r25
    5f64:	aa 1f       	adc	r26, r26
    5f66:	bb 1f       	adc	r27, r27
    5f68:	88 0f       	add	r24, r24
    5f6a:	99 1f       	adc	r25, r25
    5f6c:	aa 1f       	adc	r26, r26
    5f6e:	bb 1f       	adc	r27, r27
    5f70:	88 0f       	add	r24, r24
    5f72:	99 1f       	adc	r25, r25
    5f74:	aa 1f       	adc	r26, r26
    5f76:	bb 1f       	adc	r27, r27
    5f78:	81 83       	std	Z+1, r24	; 0x01
    5f7a:	92 83       	std	Z+2, r25	; 0x02
    5f7c:	a3 83       	std	Z+3, r26	; 0x03
    5f7e:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    5f80:	d8 01       	movw	r26, r16
    5f82:	15 96       	adiw	r26, 0x05	; 5
    5f84:	4d 91       	ld	r20, X+
    5f86:	5d 91       	ld	r21, X+
    5f88:	6d 91       	ld	r22, X+
    5f8a:	7c 91       	ld	r23, X
    5f8c:	18 97       	sbiw	r26, 0x08	; 8
    5f8e:	db 01       	movw	r26, r22
    5f90:	ca 01       	movw	r24, r20
    5f92:	88 0f       	add	r24, r24
    5f94:	99 1f       	adc	r25, r25
    5f96:	aa 1f       	adc	r26, r26
    5f98:	bb 1f       	adc	r27, r27
    5f9a:	88 0f       	add	r24, r24
    5f9c:	99 1f       	adc	r25, r25
    5f9e:	aa 1f       	adc	r26, r26
    5fa0:	bb 1f       	adc	r27, r27
    5fa2:	88 0f       	add	r24, r24
    5fa4:	99 1f       	adc	r25, r25
    5fa6:	aa 1f       	adc	r26, r26
    5fa8:	bb 1f       	adc	r27, r27
    5faa:	85 83       	std	Z+5, r24	; 0x05
    5fac:	96 83       	std	Z+6, r25	; 0x06
    5fae:	a7 83       	std	Z+7, r26	; 0x07
    5fb0:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    5fb2:	d8 01       	movw	r26, r16
    5fb4:	19 96       	adiw	r26, 0x09	; 9
    5fb6:	4d 91       	ld	r20, X+
    5fb8:	5d 91       	ld	r21, X+
    5fba:	6d 91       	ld	r22, X+
    5fbc:	7c 91       	ld	r23, X
    5fbe:	1c 97       	sbiw	r26, 0x0c	; 12
    5fc0:	db 01       	movw	r26, r22
    5fc2:	ca 01       	movw	r24, r20
    5fc4:	88 0f       	add	r24, r24
    5fc6:	99 1f       	adc	r25, r25
    5fc8:	aa 1f       	adc	r26, r26
    5fca:	bb 1f       	adc	r27, r27
    5fcc:	88 0f       	add	r24, r24
    5fce:	99 1f       	adc	r25, r25
    5fd0:	aa 1f       	adc	r26, r26
    5fd2:	bb 1f       	adc	r27, r27
    5fd4:	88 0f       	add	r24, r24
    5fd6:	99 1f       	adc	r25, r25
    5fd8:	aa 1f       	adc	r26, r26
    5fda:	bb 1f       	adc	r27, r27
    5fdc:	81 87       	std	Z+9, r24	; 0x09
    5fde:	92 87       	std	Z+10, r25	; 0x0a
    5fe0:	a3 87       	std	Z+11, r26	; 0x0b
    5fe2:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    5fe4:	d8 01       	movw	r26, r16
    5fe6:	1d 96       	adiw	r26, 0x0d	; 13
    5fe8:	4d 91       	ld	r20, X+
    5fea:	5d 91       	ld	r21, X+
    5fec:	6d 91       	ld	r22, X+
    5fee:	7c 91       	ld	r23, X
    5ff0:	50 97       	sbiw	r26, 0x10	; 16
    5ff2:	db 01       	movw	r26, r22
    5ff4:	ca 01       	movw	r24, r20
    5ff6:	88 0f       	add	r24, r24
    5ff8:	99 1f       	adc	r25, r25
    5ffa:	aa 1f       	adc	r26, r26
    5ffc:	bb 1f       	adc	r27, r27
    5ffe:	88 0f       	add	r24, r24
    6000:	99 1f       	adc	r25, r25
    6002:	aa 1f       	adc	r26, r26
    6004:	bb 1f       	adc	r27, r27
    6006:	88 0f       	add	r24, r24
    6008:	99 1f       	adc	r25, r25
    600a:	aa 1f       	adc	r26, r26
    600c:	bb 1f       	adc	r27, r27
    600e:	85 87       	std	Z+13, r24	; 0x0d
    6010:	96 87       	std	Z+14, r25	; 0x0e
    6012:	a7 87       	std	Z+15, r26	; 0x0f
    6014:	b0 8b       	std	Z+16, r27	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    6016:	f8 01       	movw	r30, r16
    6018:	65 85       	ldd	r22, Z+13	; 0x0d
    601a:	76 85       	ldd	r23, Z+14	; 0x0e
    601c:	87 85       	ldd	r24, Z+15	; 0x0f
    601e:	90 89       	ldd	r25, Z+16	; 0x10
    6020:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__floatunsisf>
    6024:	d3 01       	movw	r26, r6
    6026:	12 96       	adiw	r26, 0x02	; 2
    6028:	6d 93       	st	X+, r22
    602a:	7d 93       	st	X+, r23
    602c:	8d 93       	st	X+, r24
    602e:	9c 93       	st	X, r25
    6030:	15 97       	sbiw	r26, 0x05	; 5
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    6032:	f8 01       	movw	r30, r16
    6034:	25 a1       	ldd	r18, Z+37	; 0x25
    6036:	36 a1       	ldd	r19, Z+38	; 0x26
    6038:	47 a1       	ldd	r20, Z+39	; 0x27
    603a:	50 a5       	ldd	r21, Z+40	; 0x28
    603c:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    6040:	9b 01       	movw	r18, r22
    6042:	ac 01       	movw	r20, r24
    6044:	d3 01       	movw	r26, r6
    6046:	16 96       	adiw	r26, 0x06	; 6
    6048:	6d 93       	st	X+, r22
    604a:	7d 93       	st	X+, r23
    604c:	8d 93       	st	X+, r24
    604e:	9c 93       	st	X, r25
    6050:	19 97       	sbiw	r26, 0x09	; 9
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    6052:	60 e0       	ldi	r22, 0x00	; 0
    6054:	70 e0       	ldi	r23, 0x00	; 0
    6056:	80 ea       	ldi	r24, 0xA0	; 160
    6058:	9f e3       	ldi	r25, 0x3F	; 63
    605a:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    605e:	f3 01       	movw	r30, r6
    6060:	62 87       	std	Z+10, r22	; 0x0a
    6062:	73 87       	std	Z+11, r23	; 0x0b
    6064:	84 87       	std	Z+12, r24	; 0x0c
    6066:	95 87       	std	Z+13, r25	; 0x0d
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    6068:	16 86       	std	Z+14, r1	; 0x0e
    606a:	17 86       	std	Z+15, r1	; 0x0f
    606c:	10 8a       	std	Z+16, r1	; 0x10
    606e:	11 8a       	std	Z+17, r1	; 0x11

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    6070:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    6074:	80 77       	andi	r24, 0x70	; 112
    6076:	a1 f0       	breq	.+40     	; 0x60a0 <st_prep_buffer+0x226>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    6078:	67 8d       	ldd	r22, Z+31	; 0x1f
    607a:	70 a1       	ldd	r23, Z+32	; 0x20
    607c:	81 a1       	ldd	r24, Z+33	; 0x21
    607e:	92 a1       	ldd	r25, Z+34	; 0x22
    6080:	67 8b       	std	Z+23, r22	; 0x17
    6082:	70 8f       	std	Z+24, r23	; 0x18
    6084:	81 8f       	std	Z+25, r24	; 0x19
    6086:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    6088:	9b 01       	movw	r18, r22
    608a:	ac 01       	movw	r20, r24
    608c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6090:	d8 01       	movw	r26, r16
    6092:	51 96       	adiw	r26, 0x11	; 17
    6094:	6d 93       	st	X+, r22
    6096:	7d 93       	st	X+, r23
    6098:	8d 93       	st	X+, r24
    609a:	9c 93       	st	X, r25
    609c:	54 97       	sbiw	r26, 0x14	; 20
    609e:	0e c0       	rjmp	.+28     	; 0x60bc <st_prep_buffer+0x242>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    60a0:	f8 01       	movw	r30, r16
    60a2:	61 89       	ldd	r22, Z+17	; 0x11
    60a4:	72 89       	ldd	r23, Z+18	; 0x12
    60a6:	83 89       	ldd	r24, Z+19	; 0x13
    60a8:	94 89       	ldd	r25, Z+20	; 0x14
    60aa:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    60ae:	d3 01       	movw	r26, r6
    60b0:	57 96       	adiw	r26, 0x17	; 23
    60b2:	6d 93       	st	X+, r22
    60b4:	7d 93       	st	X+, r23
    60b6:	8d 93       	st	X+, r24
    60b8:	9c 93       	st	X, r25
    60ba:	5a 97       	sbiw	r26, 0x1a	; 26
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    60bc:	f3 01       	movw	r30, r6
    60be:	13 8a       	std	Z+19, r1	; 0x13
    60c0:	14 8a       	std	Z+20, r1	; 0x14
    60c2:	15 8a       	std	Z+21, r1	; 0x15
    60c4:	16 8a       	std	Z+22, r1	; 0x16
      float inv_2_accel = 0.5/pl_block->acceleration;
    60c6:	20 91 87 04 	lds	r18, 0x0487	; 0x800487 <pl_block>
    60ca:	30 91 88 04 	lds	r19, 0x0488	; 0x800488 <pl_block+0x1>
    60ce:	3a 83       	std	Y+2, r19	; 0x02
    60d0:	29 83       	std	Y+1, r18	; 0x01
    60d2:	d9 01       	movw	r26, r18
    60d4:	91 96       	adiw	r26, 0x21	; 33
    60d6:	cd 90       	ld	r12, X+
    60d8:	dd 90       	ld	r13, X+
    60da:	ed 90       	ld	r14, X+
    60dc:	fc 90       	ld	r15, X
    60de:	94 97       	sbiw	r26, 0x24	; 36
    60e0:	a7 01       	movw	r20, r14
    60e2:	96 01       	movw	r18, r12
    60e4:	60 e0       	ldi	r22, 0x00	; 0
    60e6:	70 e0       	ldi	r23, 0x00	; 0
    60e8:	80 e0       	ldi	r24, 0x00	; 0
    60ea:	9f e3       	ldi	r25, 0x3F	; 63
    60ec:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    60f0:	4b 01       	movw	r8, r22
    60f2:	5c 01       	movw	r10, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    60f4:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    60f8:	80 77       	andi	r24, 0x70	; 112
    60fa:	09 f4       	brne	.+2      	; 0x60fe <st_prep_buffer+0x284>
    60fc:	4f c0       	rjmp	.+158    	; 0x619c <st_prep_buffer+0x322>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    60fe:	22 e0       	ldi	r18, 0x02	; 2
    6100:	f3 01       	movw	r30, r6
    6102:	22 8b       	std	Z+18, r18	; 0x12
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    6104:	a9 81       	ldd	r26, Y+1	; 0x01
    6106:	ba 81       	ldd	r27, Y+2	; 0x02
    6108:	95 96       	adiw	r26, 0x25	; 37
    610a:	2d 90       	ld	r2, X+
    610c:	3d 90       	ld	r3, X+
    610e:	4d 90       	ld	r4, X+
    6110:	5c 90       	ld	r5, X
    6112:	98 97       	sbiw	r26, 0x28	; 40
    6114:	51 96       	adiw	r26, 0x11	; 17
    6116:	2d 91       	ld	r18, X+
    6118:	3d 91       	ld	r19, X+
    611a:	4d 91       	ld	r20, X+
    611c:	5c 91       	ld	r21, X
    611e:	54 97       	sbiw	r26, 0x14	; 20
    6120:	29 83       	std	Y+1, r18	; 0x01
    6122:	3a 83       	std	Y+2, r19	; 0x02
    6124:	4b 83       	std	Y+3, r20	; 0x03
    6126:	5c 83       	std	Y+4, r21	; 0x04
    6128:	c5 01       	movw	r24, r10
    612a:	b4 01       	movw	r22, r8
    612c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6130:	9b 01       	movw	r18, r22
    6132:	ac 01       	movw	r20, r24
    6134:	c2 01       	movw	r24, r4
    6136:	b1 01       	movw	r22, r2
    6138:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    613c:	4b 01       	movw	r8, r22
    613e:	5c 01       	movw	r10, r24
        if (decel_dist < 0.0) {
    6140:	20 e0       	ldi	r18, 0x00	; 0
    6142:	30 e0       	ldi	r19, 0x00	; 0
    6144:	a9 01       	movw	r20, r18
    6146:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    614a:	88 23       	and	r24, r24
    614c:	d4 f4       	brge	.+52     	; 0x6182 <st_prep_buffer+0x308>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    614e:	a7 01       	movw	r20, r14
    6150:	96 01       	movw	r18, r12
    6152:	c7 01       	movw	r24, r14
    6154:	b6 01       	movw	r22, r12
    6156:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    615a:	a2 01       	movw	r20, r4
    615c:	91 01       	movw	r18, r2
    615e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6162:	9b 01       	movw	r18, r22
    6164:	ac 01       	movw	r20, r24
    6166:	69 81       	ldd	r22, Y+1	; 0x01
    6168:	7a 81       	ldd	r23, Y+2	; 0x02
    616a:	8b 81       	ldd	r24, Y+3	; 0x03
    616c:	9c 81       	ldd	r25, Y+4	; 0x04
    616e:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6172:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    6176:	f3 01       	movw	r30, r6
    6178:	67 8f       	std	Z+31, r22	; 0x1f
    617a:	70 a3       	std	Z+32, r23	; 0x20
    617c:	81 a3       	std	Z+33, r24	; 0x21
    617e:	92 a3       	std	Z+34, r25	; 0x22
    6180:	13 c1       	rjmp	.+550    	; 0x63a8 <st_prep_buffer+0x52e>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    6182:	d3 01       	movw	r26, r6
    6184:	53 96       	adiw	r26, 0x13	; 19
    6186:	8d 92       	st	X+, r8
    6188:	9d 92       	st	X+, r9
    618a:	ad 92       	st	X+, r10
    618c:	bc 92       	st	X, r11
    618e:	56 97       	sbiw	r26, 0x16	; 22
          prep.exit_speed = 0.0;
    6190:	f3 01       	movw	r30, r6
    6192:	17 8e       	std	Z+31, r1	; 0x1f
    6194:	10 a2       	std	Z+32, r1	; 0x20
    6196:	11 a2       	std	Z+33, r1	; 0x21
    6198:	12 a2       	std	Z+34, r1	; 0x22
    619a:	06 c1       	rjmp	.+524    	; 0x63a8 <st_prep_buffer+0x52e>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    619c:	d3 01       	movw	r26, r6
    619e:	52 96       	adiw	r26, 0x12	; 18
    61a0:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    61a2:	e9 81       	ldd	r30, Y+1	; 0x01
    61a4:	fa 81       	ldd	r31, Y+2	; 0x02
    61a6:	85 a1       	ldd	r24, Z+37	; 0x25
    61a8:	96 a1       	ldd	r25, Z+38	; 0x26
    61aa:	a7 a1       	ldd	r26, Z+39	; 0x27
    61ac:	b0 a5       	ldd	r27, Z+40	; 0x28
    61ae:	f3 01       	movw	r30, r6
    61b0:	83 a3       	std	Z+35, r24	; 0x23
    61b2:	94 a3       	std	Z+36, r25	; 0x24
    61b4:	a5 a3       	std	Z+37, r26	; 0x25
    61b6:	b6 a3       	std	Z+38, r27	; 0x26
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    61b8:	0e 94 0b 1b 	call	0x3616	; 0x3616 <plan_get_exec_block_exit_speed>
    61bc:	1b 01       	movw	r2, r22
    61be:	2c 01       	movw	r4, r24
    61c0:	d3 01       	movw	r26, r6
    61c2:	5f 96       	adiw	r26, 0x1f	; 31
    61c4:	6d 93       	st	X+, r22
    61c6:	7d 93       	st	X+, r23
    61c8:	8d 93       	st	X+, r24
    61ca:	9c 93       	st	X, r25
    61cc:	92 97       	sbiw	r26, 0x22	; 34
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    61ce:	9b 01       	movw	r18, r22
    61d0:	ac 01       	movw	r20, r24
    61d2:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    61d6:	69 83       	std	Y+1, r22	; 0x01
    61d8:	7a 83       	std	Y+2, r23	; 0x02
    61da:	8b 83       	std	Y+3, r24	; 0x03
    61dc:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    61de:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <pl_block>
    61e2:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <pl_block+0x1>
    61e6:	fe 83       	std	Y+6, r31	; 0x06
    61e8:	ed 83       	std	Y+5, r30	; 0x05
    61ea:	25 a1       	ldd	r18, Z+37	; 0x25
    61ec:	36 a1       	ldd	r19, Z+38	; 0x26
    61ee:	47 a1       	ldd	r20, Z+39	; 0x27
    61f0:	50 a5       	ldd	r21, Z+40	; 0x28
    61f2:	29 87       	std	Y+9, r18	; 0x09
    61f4:	3a 87       	std	Y+10, r19	; 0x0a
    61f6:	4b 87       	std	Y+11, r20	; 0x0b
    61f8:	5c 87       	std	Y+12, r21	; 0x0c
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    61fa:	9b 01       	movw	r18, r22
    61fc:	ac 01       	movw	r20, r24
    61fe:	61 89       	ldd	r22, Z+17	; 0x11
    6200:	72 89       	ldd	r23, Z+18	; 0x12
    6202:	83 89       	ldd	r24, Z+19	; 0x13
    6204:	94 89       	ldd	r25, Z+20	; 0x14
    6206:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    620a:	a5 01       	movw	r20, r10
    620c:	94 01       	movw	r18, r8
    620e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6212:	29 85       	ldd	r18, Y+9	; 0x09
    6214:	3a 85       	ldd	r19, Y+10	; 0x0a
    6216:	4b 85       	ldd	r20, Y+11	; 0x0b
    6218:	5c 85       	ldd	r21, Y+12	; 0x0c
    621a:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    621e:	20 e0       	ldi	r18, 0x00	; 0
    6220:	30 e0       	ldi	r19, 0x00	; 0
    6222:	40 e0       	ldi	r20, 0x00	; 0
    6224:	5f e3       	ldi	r21, 0x3F	; 63
    6226:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    622a:	6b 01       	movw	r12, r22
    622c:	7c 01       	movw	r14, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    622e:	20 e0       	ldi	r18, 0x00	; 0
    6230:	30 e0       	ldi	r19, 0x00	; 0
    6232:	a9 01       	movw	r20, r18
    6234:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    6238:	18 16       	cp	r1, r24
    623a:	0c f0       	brlt	.+2      	; 0x623e <st_prep_buffer+0x3c4>
    623c:	a9 c0       	rjmp	.+338    	; 0x6390 <st_prep_buffer+0x516>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    623e:	a7 01       	movw	r20, r14
    6240:	96 01       	movw	r18, r12
    6242:	69 85       	ldd	r22, Y+9	; 0x09
    6244:	7a 85       	ldd	r23, Y+10	; 0x0a
    6246:	8b 85       	ldd	r24, Y+11	; 0x0b
    6248:	9c 85       	ldd	r25, Y+12	; 0x0c
    624a:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    624e:	18 16       	cp	r1, r24
    6250:	0c f0       	brlt	.+2      	; 0x6254 <st_prep_buffer+0x3da>
    6252:	8d c0       	rjmp	.+282    	; 0x636e <st_prep_buffer+0x4f4>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    6254:	29 81       	ldd	r18, Y+1	; 0x01
    6256:	3a 81       	ldd	r19, Y+2	; 0x02
    6258:	4b 81       	ldd	r20, Y+3	; 0x03
    625a:	5c 81       	ldd	r21, Y+4	; 0x04
    625c:	ed 81       	ldd	r30, Y+5	; 0x05
    625e:	fe 81       	ldd	r31, Y+6	; 0x06
    6260:	65 8d       	ldd	r22, Z+29	; 0x1d
    6262:	76 8d       	ldd	r23, Z+30	; 0x1e
    6264:	87 8d       	ldd	r24, Z+31	; 0x1f
    6266:	90 a1       	ldd	r25, Z+32	; 0x20
    6268:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    626c:	a5 01       	movw	r20, r10
    626e:	94 01       	movw	r18, r8
    6270:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6274:	9b 01       	movw	r18, r22
    6276:	ac 01       	movw	r20, r24
    6278:	d3 01       	movw	r26, r6
    627a:	97 96       	adiw	r26, 0x27	; 39
    627c:	6d 93       	st	X+, r22
    627e:	7d 93       	st	X+, r23
    6280:	8d 93       	st	X+, r24
    6282:	9c 93       	st	X, r25
    6284:	9a 97       	sbiw	r26, 0x2a	; 42
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    6286:	c7 01       	movw	r24, r14
    6288:	b6 01       	movw	r22, r12
    628a:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    628e:	18 16       	cp	r1, r24
    6290:	0c f0       	brlt	.+2      	; 0x6294 <st_prep_buffer+0x41a>
    6292:	41 c0       	rjmp	.+130    	; 0x6316 <st_prep_buffer+0x49c>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    6294:	ed 81       	ldd	r30, Y+5	; 0x05
    6296:	fe 81       	ldd	r31, Y+6	; 0x06
    6298:	65 8d       	ldd	r22, Z+29	; 0x1d
    629a:	76 8d       	ldd	r23, Z+30	; 0x1e
    629c:	87 8d       	ldd	r24, Z+31	; 0x1f
    629e:	90 a1       	ldd	r25, Z+32	; 0x20
    62a0:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    62a4:	d3 01       	movw	r26, r6
    62a6:	5b 96       	adiw	r26, 0x1b	; 27
    62a8:	6d 93       	st	X+, r22
    62aa:	7d 93       	st	X+, r23
    62ac:	8d 93       	st	X+, r24
    62ae:	9c 93       	st	X, r25
    62b0:	5e 97       	sbiw	r26, 0x1e	; 30
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    62b2:	ed 81       	ldd	r30, Y+5	; 0x05
    62b4:	fe 81       	ldd	r31, Y+6	; 0x06
    62b6:	c1 88       	ldd	r12, Z+17	; 0x11
    62b8:	d2 88       	ldd	r13, Z+18	; 0x12
    62ba:	e3 88       	ldd	r14, Z+19	; 0x13
    62bc:	f4 88       	ldd	r15, Z+20	; 0x14
    62be:	25 8c       	ldd	r2, Z+29	; 0x1d
    62c0:	36 8c       	ldd	r3, Z+30	; 0x1e
    62c2:	47 8c       	ldd	r4, Z+31	; 0x1f
    62c4:	50 a0       	ldd	r5, Z+32	; 0x20
    62c6:	a2 01       	movw	r20, r4
    62c8:	91 01       	movw	r18, r2
    62ca:	c7 01       	movw	r24, r14
    62cc:	b6 01       	movw	r22, r12
    62ce:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    62d2:	81 11       	cpse	r24, r1
    62d4:	05 c0       	rjmp	.+10     	; 0x62e0 <st_prep_buffer+0x466>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    62d6:	e1 e0       	ldi	r30, 0x01	; 1
    62d8:	d3 01       	movw	r26, r6
    62da:	52 96       	adiw	r26, 0x12	; 18
    62dc:	ec 93       	st	X, r30
    62de:	64 c0       	rjmp	.+200    	; 0x63a8 <st_prep_buffer+0x52e>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    62e0:	a7 01       	movw	r20, r14
    62e2:	96 01       	movw	r18, r12
    62e4:	c2 01       	movw	r24, r4
    62e6:	b1 01       	movw	r22, r2
    62e8:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    62ec:	a5 01       	movw	r20, r10
    62ee:	94 01       	movw	r18, r8
    62f0:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    62f4:	9b 01       	movw	r18, r22
    62f6:	ac 01       	movw	r20, r24
    62f8:	d3 01       	movw	r26, r6
    62fa:	93 96       	adiw	r26, 0x23	; 35
    62fc:	6d 91       	ld	r22, X+
    62fe:	7d 91       	ld	r23, X+
    6300:	8d 91       	ld	r24, X+
    6302:	9c 91       	ld	r25, X
    6304:	96 97       	sbiw	r26, 0x26	; 38
    6306:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    630a:	f3 01       	movw	r30, r6
    630c:	63 a3       	std	Z+35, r22	; 0x23
    630e:	74 a3       	std	Z+36, r23	; 0x24
    6310:	85 a3       	std	Z+37, r24	; 0x25
    6312:	96 a3       	std	Z+38, r25	; 0x26
    6314:	49 c0       	rjmp	.+146    	; 0x63a8 <st_prep_buffer+0x52e>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    6316:	d3 01       	movw	r26, r6
    6318:	93 96       	adiw	r26, 0x23	; 35
    631a:	cd 92       	st	X+, r12
    631c:	dd 92       	st	X+, r13
    631e:	ed 92       	st	X+, r14
    6320:	fc 92       	st	X, r15
    6322:	96 97       	sbiw	r26, 0x26	; 38
              prep.decelerate_after = intersect_distance;
    6324:	f3 01       	movw	r30, r6
    6326:	c7 a2       	std	Z+39, r12	; 0x27
    6328:	d0 a6       	std	Z+40, r13	; 0x28
    632a:	e1 a6       	std	Z+41, r14	; 0x29
    632c:	f2 a6       	std	Z+42, r15	; 0x2a
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    632e:	ad 81       	ldd	r26, Y+5	; 0x05
    6330:	be 81       	ldd	r27, Y+6	; 0x06
    6332:	91 96       	adiw	r26, 0x21	; 33
    6334:	8d 90       	ld	r8, X+
    6336:	9d 90       	ld	r9, X+
    6338:	ad 90       	ld	r10, X+
    633a:	bc 90       	ld	r11, X
    633c:	94 97       	sbiw	r26, 0x24	; 36
    633e:	a5 01       	movw	r20, r10
    6340:	94 01       	movw	r18, r8
    6342:	c5 01       	movw	r24, r10
    6344:	b4 01       	movw	r22, r8
    6346:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    634a:	a7 01       	movw	r20, r14
    634c:	96 01       	movw	r18, r12
    634e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6352:	29 81       	ldd	r18, Y+1	; 0x01
    6354:	3a 81       	ldd	r19, Y+2	; 0x02
    6356:	4b 81       	ldd	r20, Y+3	; 0x03
    6358:	5c 81       	ldd	r21, Y+4	; 0x04
    635a:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    635e:	0e 94 c3 3c 	call	0x7986	; 0x7986 <sqrt>
    6362:	f3 01       	movw	r30, r6
    6364:	63 8f       	std	Z+27, r22	; 0x1b
    6366:	74 8f       	std	Z+28, r23	; 0x1c
    6368:	85 8f       	std	Z+29, r24	; 0x1d
    636a:	96 8f       	std	Z+30, r25	; 0x1e
    636c:	1d c0       	rjmp	.+58     	; 0x63a8 <st_prep_buffer+0x52e>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    636e:	e2 e0       	ldi	r30, 0x02	; 2
    6370:	d3 01       	movw	r26, r6
    6372:	52 96       	adiw	r26, 0x12	; 18
    6374:	ec 93       	st	X, r30
    6376:	52 97       	sbiw	r26, 0x12	; 18
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    6378:	57 96       	adiw	r26, 0x17	; 23
    637a:	8d 91       	ld	r24, X+
    637c:	9d 91       	ld	r25, X+
    637e:	0d 90       	ld	r0, X+
    6380:	bc 91       	ld	r27, X
    6382:	a0 2d       	mov	r26, r0
    6384:	f3 01       	movw	r30, r6
    6386:	83 8f       	std	Z+27, r24	; 0x1b
    6388:	94 8f       	std	Z+28, r25	; 0x1c
    638a:	a5 8f       	std	Z+29, r26	; 0x1d
    638c:	b6 8f       	std	Z+30, r27	; 0x1e
    638e:	0c c0       	rjmp	.+24     	; 0x63a8 <st_prep_buffer+0x52e>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    6390:	d3 01       	movw	r26, r6
    6392:	93 96       	adiw	r26, 0x23	; 35
    6394:	1d 92       	st	X+, r1
    6396:	1d 92       	st	X+, r1
    6398:	1d 92       	st	X+, r1
    639a:	1c 92       	st	X, r1
    639c:	96 97       	sbiw	r26, 0x26	; 38
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    639e:	f3 01       	movw	r30, r6
    63a0:	23 8e       	std	Z+27, r2	; 0x1b
    63a2:	34 8e       	std	Z+28, r3	; 0x1c
    63a4:	45 8e       	std	Z+29, r4	; 0x1d
    63a6:	56 8e       	std	Z+30, r5	; 0x1e
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    63a8:	e0 91 8d 04 	lds	r30, 0x048D	; 0x80048d <segment_buffer_head>
    63ac:	2e 2f       	mov	r18, r30
    63ae:	30 e0       	ldi	r19, 0x00	; 0
    63b0:	3a a7       	std	Y+42, r19	; 0x2a
    63b2:	29 a7       	std	Y+41, r18	; 0x29

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    63b4:	f9 01       	movw	r30, r18
    63b6:	ee 0f       	add	r30, r30
    63b8:	ff 1f       	adc	r31, r31
    63ba:	e2 0f       	add	r30, r18
    63bc:	f3 1f       	adc	r31, r19
    63be:	ee 0f       	add	r30, r30
    63c0:	ff 1f       	adc	r31, r31
    63c2:	ee 54       	subi	r30, 0x4E	; 78
    63c4:	fb 4f       	sbci	r31, 0xFB	; 251
    63c6:	d3 01       	movw	r26, r6
    63c8:	8c 91       	ld	r24, X
    63ca:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    63cc:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <pl_block>
    63d0:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <pl_block+0x1>
    63d4:	f8 a3       	std	Y+32, r31	; 0x20
    63d6:	ef 8f       	std	Y+31, r30	; 0x1f
    63d8:	f5 a1       	ldd	r31, Z+37	; 0x25
    63da:	f8 ab       	std	Y+48, r31	; 0x30
    63dc:	af 8d       	ldd	r26, Y+31	; 0x1f
    63de:	b8 a1       	ldd	r27, Y+32	; 0x20
    63e0:	96 96       	adiw	r26, 0x26	; 38
    63e2:	bc 91       	ld	r27, X
    63e4:	b9 ab       	std	Y+49, r27	; 0x31
    63e6:	ef 8d       	ldd	r30, Y+31	; 0x1f
    63e8:	f8 a1       	ldd	r31, Y+32	; 0x20
    63ea:	f7 a1       	ldd	r31, Z+39	; 0x27
    63ec:	fa ab       	std	Y+50, r31	; 0x32
    63ee:	af 8d       	ldd	r26, Y+31	; 0x1f
    63f0:	b8 a1       	ldd	r27, Y+32	; 0x20
    63f2:	98 96       	adiw	r26, 0x28	; 40
    63f4:	bc 91       	ld	r27, X
    63f6:	bb ab       	std	Y+51, r27	; 0x33
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    63f8:	f3 01       	movw	r30, r6
    63fa:	22 85       	ldd	r18, Z+10	; 0x0a
    63fc:	33 85       	ldd	r19, Z+11	; 0x0b
    63fe:	44 85       	ldd	r20, Z+12	; 0x0c
    6400:	55 85       	ldd	r21, Z+13	; 0x0d
    6402:	68 a9       	ldd	r22, Y+48	; 0x30
    6404:	79 a9       	ldd	r23, Y+49	; 0x31
    6406:	8a a9       	ldd	r24, Y+50	; 0x32
    6408:	9b 2f       	mov	r25, r27
    640a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    640e:	6b a7       	std	Y+43, r22	; 0x2b
    6410:	7c a7       	std	Y+44, r23	; 0x2c
    6412:	8d a7       	std	Y+45, r24	; 0x2d
    6414:	9e a7       	std	Y+46, r25	; 0x2e
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    6416:	20 e0       	ldi	r18, 0x00	; 0
    6418:	30 e0       	ldi	r19, 0x00	; 0
    641a:	a9 01       	movw	r20, r18
    641c:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    6420:	88 23       	and	r24, r24
    6422:	24 f4       	brge	.+8      	; 0x642c <st_prep_buffer+0x5b2>
    6424:	1b a6       	std	Y+43, r1	; 0x2b
    6426:	1c a6       	std	Y+44, r1	; 0x2c
    6428:	1d a6       	std	Y+45, r1	; 0x2d
    642a:	1e a6       	std	Y+46, r1	; 0x2e
    642c:	d3 01       	movw	r26, r6
    642e:	57 96       	adiw	r26, 0x17	; 23
    6430:	bc 91       	ld	r27, X
    6432:	b9 87       	std	Y+9, r27	; 0x09
    6434:	f3 01       	movw	r30, r6
    6436:	f0 8d       	ldd	r31, Z+24	; 0x18
    6438:	fd 87       	std	Y+13, r31	; 0x0d
    643a:	d3 01       	movw	r26, r6
    643c:	59 96       	adiw	r26, 0x19	; 25
    643e:	bc 91       	ld	r27, X
    6440:	b9 8b       	std	Y+17, r27	; 0x11
    6442:	f3 01       	movw	r30, r6
    6444:	f2 8d       	ldd	r31, Z+26	; 0x1a
    6446:	fd 8b       	std	Y+21, r31	; 0x15
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    6448:	d3 01       	movw	r26, r6
    644a:	93 96       	adiw	r26, 0x23	; 35
    644c:	bc 91       	ld	r27, X
    644e:	b9 a3       	std	Y+33, r27	; 0x21
    6450:	f3 01       	movw	r30, r6
    6452:	f4 a1       	ldd	r31, Z+36	; 0x24
    6454:	fa a3       	std	Y+34, r31	; 0x22
    6456:	d3 01       	movw	r26, r6
    6458:	95 96       	adiw	r26, 0x25	; 37
    645a:	bc 91       	ld	r27, X
    645c:	bb a3       	std	Y+35, r27	; 0x23
    645e:	f3 01       	movw	r30, r6
    6460:	f6 a1       	ldd	r31, Z+38	; 0x26
    6462:	fc a3       	std	Y+36, r31	; 0x24
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    6464:	d3 01       	movw	r26, r6
    6466:	5b 96       	adiw	r26, 0x1b	; 27
    6468:	bc 91       	ld	r27, X
    646a:	bb 8f       	std	Y+27, r27	; 0x1b
    646c:	f3 01       	movw	r30, r6
    646e:	f4 8d       	ldd	r31, Z+28	; 0x1c
    6470:	fc 8f       	std	Y+28, r31	; 0x1c
    6472:	d3 01       	movw	r26, r6
    6474:	5d 96       	adiw	r26, 0x1d	; 29
    6476:	bc 91       	ld	r27, X
    6478:	bd 8f       	std	Y+29, r27	; 0x1d
    647a:	f3 01       	movw	r30, r6
    647c:	f6 8d       	ldd	r31, Z+30	; 0x1e
    647e:	fe 8f       	std	Y+30, r31	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    6480:	d3 01       	movw	r26, r6
    6482:	97 96       	adiw	r26, 0x27	; 39
    6484:	bc 91       	ld	r27, X
    6486:	bd a3       	std	Y+37, r27	; 0x25
    6488:	f3 01       	movw	r30, r6
    648a:	f0 a5       	ldd	r31, Z+40	; 0x28
    648c:	fe a3       	std	Y+38, r31	; 0x26
    648e:	d3 01       	movw	r26, r6
    6490:	99 96       	adiw	r26, 0x29	; 41
    6492:	bc 91       	ld	r27, X
    6494:	bf a3       	std	Y+39, r27	; 0x27
    6496:	f3 01       	movw	r30, r6
    6498:	f2 a5       	ldd	r31, Z+42	; 0x2a
    649a:	f8 a7       	std	Y+40, r31	; 0x28
    649c:	d3 01       	movw	r26, r6
    649e:	52 96       	adiw	r26, 0x12	; 18
    64a0:	bc 91       	ld	r27, X
    64a2:	bd 83       	std	Y+5, r27	; 0x05
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    64a4:	f3 01       	movw	r30, r6
    64a6:	f3 89       	ldd	r31, Z+19	; 0x13
    64a8:	fe 8b       	std	Y+22, r31	; 0x16
    64aa:	d3 01       	movw	r26, r6
    64ac:	54 96       	adiw	r26, 0x14	; 20
    64ae:	bc 91       	ld	r27, X
    64b0:	bf 8b       	std	Y+23, r27	; 0x17
    64b2:	f3 01       	movw	r30, r6
    64b4:	f5 89       	ldd	r31, Z+21	; 0x15
    64b6:	f8 8f       	std	Y+24, r31	; 0x18
    64b8:	d3 01       	movw	r26, r6
    64ba:	56 96       	adiw	r26, 0x16	; 22
    64bc:	bc 91       	ld	r27, X
    64be:	b9 8f       	std	Y+25, r27	; 0x19
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    64c0:	d3 01       	movw	r26, r6
    64c2:	5f 96       	adiw	r26, 0x1f	; 31
    64c4:	2d 91       	ld	r18, X+
    64c6:	3d 91       	ld	r19, X+
    64c8:	4d 91       	ld	r20, X+
    64ca:	5c 91       	ld	r21, X
    64cc:	92 97       	sbiw	r26, 0x22	; 34
    64ce:	2c ab       	std	Y+52, r18	; 0x34
    64d0:	3d ab       	std	Y+53, r19	; 0x35
    64d2:	4e ab       	std	Y+54, r20	; 0x36
    64d4:	5f ab       	std	Y+55, r21	; 0x37
    64d6:	2d a1       	ldd	r18, Y+37	; 0x25
    64d8:	3e a1       	ldd	r19, Y+38	; 0x26
    64da:	4f a1       	ldd	r20, Y+39	; 0x27
    64dc:	58 a5       	ldd	r21, Y+40	; 0x28
    64de:	69 a1       	ldd	r22, Y+33	; 0x21
    64e0:	7a a1       	ldd	r23, Y+34	; 0x22
    64e2:	8b a1       	ldd	r24, Y+35	; 0x23
    64e4:	9c a1       	ldd	r25, Y+36	; 0x24
    64e6:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    64ea:	81 11       	cpse	r24, r1
    64ec:	02 c0       	rjmp	.+4      	; 0x64f2 <st_prep_buffer+0x678>
    64ee:	82 e0       	ldi	r24, 0x02	; 2
    64f0:	01 c0       	rjmp	.+2      	; 0x64f4 <st_prep_buffer+0x67a>
    64f2:	81 e0       	ldi	r24, 0x01	; 1
    64f4:	e8 a8       	ldd	r14, Y+48	; 0x30
    64f6:	f9 a8       	ldd	r15, Y+49	; 0x31
    64f8:	0a a9       	ldd	r16, Y+50	; 0x32
    64fa:	1b a9       	ldd	r17, Y+51	; 0x33
    64fc:	0f 2e       	mov	r0, r31
    64fe:	fe e3       	ldi	r31, 0x3E	; 62
    6500:	5f 2e       	mov	r5, r31
    6502:	f0 2d       	mov	r31, r0
    6504:	0f 2e       	mov	r0, r31
    6506:	f3 ec       	ldi	r31, 0xC3	; 195
    6508:	4f 2e       	mov	r4, r31
    650a:	f0 2d       	mov	r31, r0
    650c:	0f 2e       	mov	r0, r31
    650e:	fe e2       	ldi	r31, 0x2E	; 46
    6510:	3f 2e       	mov	r3, r31
    6512:	f0 2d       	mov	r31, r0
    6514:	0f 2e       	mov	r0, r31
    6516:	f9 e3       	ldi	r31, 0x39	; 57
    6518:	2f 2e       	mov	r2, r31
    651a:	f0 2d       	mov	r31, r0
    651c:	81 2c       	mov	r8, r1
    651e:	91 2c       	mov	r9, r1
    6520:	54 01       	movw	r10, r8
    6522:	be e3       	ldi	r27, 0x3E	; 62
    6524:	ba 8f       	std	Y+26, r27	; 0x1a
    6526:	e3 ec       	ldi	r30, 0xC3	; 195
    6528:	e9 83       	std	Y+1, r30	; 0x01
    652a:	0f 2e       	mov	r0, r31
    652c:	fe e2       	ldi	r31, 0x2E	; 46
    652e:	cf 2e       	mov	r12, r31
    6530:	f0 2d       	mov	r31, r0
    6532:	0f 2e       	mov	r0, r31
    6534:	f9 e3       	ldi	r31, 0x39	; 57
    6536:	df 2e       	mov	r13, r31
    6538:	f0 2d       	mov	r31, r0
    653a:	88 af       	std	Y+56, r24	; 0x38
    653c:	7b ae       	std	Y+59, r7	; 0x3b
    653e:	6a ae       	std	Y+58, r6	; 0x3a
    6540:	0f 2e       	mov	r0, r31
    6542:	fe e3       	ldi	r31, 0x3E	; 62
    6544:	7f 2e       	mov	r7, r31
    6546:	f0 2d       	mov	r31, r0
    6548:	8d 2d       	mov	r24, r13
    654a:	dc 2c       	mov	r13, r12
    654c:	9f 2d       	mov	r25, r15
    654e:	fe 2c       	mov	r15, r14
    6550:	0d af       	std	Y+61, r16	; 0x3d
    6552:	01 2f       	mov	r16, r17
    6554:	1d 81       	ldd	r17, Y+5	; 0x05
    6556:	e9 2e       	mov	r14, r25
    6558:	c8 2e       	mov	r12, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    655a:	11 23       	and	r17, r17
    655c:	21 f0       	breq	.+8      	; 0x6566 <st_prep_buffer+0x6ec>
    655e:	11 30       	cpi	r17, 0x01	; 1
    6560:	09 f4       	brne	.+2      	; 0x6564 <st_prep_buffer+0x6ea>
    6562:	7b c0       	rjmp	.+246    	; 0x665a <st_prep_buffer+0x7e0>
    6564:	b8 c0       	rjmp	.+368    	; 0x66d6 <st_prep_buffer+0x85c>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    6566:	af 8d       	ldd	r26, Y+31	; 0x1f
    6568:	b8 a1       	ldd	r27, Y+32	; 0x20
    656a:	91 96       	adiw	r26, 0x21	; 33
    656c:	2d 91       	ld	r18, X+
    656e:	3d 91       	ld	r19, X+
    6570:	4d 91       	ld	r20, X+
    6572:	5c 91       	ld	r21, X
    6574:	94 97       	sbiw	r26, 0x24	; 36
    6576:	65 2d       	mov	r22, r5
    6578:	74 2d       	mov	r23, r4
    657a:	83 2d       	mov	r24, r3
    657c:	92 2d       	mov	r25, r2
    657e:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6582:	6d 83       	std	Y+5, r22	; 0x05
    6584:	7e 83       	std	Y+6, r23	; 0x06
    6586:	8f 83       	std	Y+7, r24	; 0x07
    6588:	98 87       	std	Y+8, r25	; 0x08
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    658a:	20 e0       	ldi	r18, 0x00	; 0
    658c:	30 e0       	ldi	r19, 0x00	; 0
    658e:	40 e0       	ldi	r20, 0x00	; 0
    6590:	5f e3       	ldi	r21, 0x3F	; 63
    6592:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6596:	29 85       	ldd	r18, Y+9	; 0x09
    6598:	3d 85       	ldd	r19, Y+13	; 0x0d
    659a:	49 89       	ldd	r20, Y+17	; 0x11
    659c:	5d 89       	ldd	r21, Y+21	; 0x15
    659e:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    65a2:	25 2d       	mov	r18, r5
    65a4:	34 2d       	mov	r19, r4
    65a6:	43 2d       	mov	r20, r3
    65a8:	52 2d       	mov	r21, r2
    65aa:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    65ae:	9b 01       	movw	r18, r22
    65b0:	ac 01       	movw	r20, r24
    65b2:	6f 2d       	mov	r22, r15
    65b4:	7e 2d       	mov	r23, r14
    65b6:	8d ad       	ldd	r24, Y+61	; 0x3d
    65b8:	90 2f       	mov	r25, r16
    65ba:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    65be:	f6 2e       	mov	r15, r22
    65c0:	e7 2e       	mov	r14, r23
    65c2:	8d af       	std	Y+61, r24	; 0x3d
    65c4:	09 2f       	mov	r16, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    65c6:	29 a1       	ldd	r18, Y+33	; 0x21
    65c8:	3a a1       	ldd	r19, Y+34	; 0x22
    65ca:	4b a1       	ldd	r20, Y+35	; 0x23
    65cc:	5c a1       	ldd	r21, Y+36	; 0x24
    65ce:	0e 94 c2 39 	call	0x7384	; 0x7384 <__cmpsf2>
    65d2:	88 23       	and	r24, r24
    65d4:	9c f5       	brge	.+102    	; 0x663c <st_prep_buffer+0x7c2>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    65d6:	29 a1       	ldd	r18, Y+33	; 0x21
    65d8:	3a a1       	ldd	r19, Y+34	; 0x22
    65da:	4b a1       	ldd	r20, Y+35	; 0x23
    65dc:	5c a1       	ldd	r21, Y+36	; 0x24
    65de:	68 a9       	ldd	r22, Y+48	; 0x30
    65e0:	79 a9       	ldd	r23, Y+49	; 0x31
    65e2:	8a a9       	ldd	r24, Y+50	; 0x32
    65e4:	9b a9       	ldd	r25, Y+51	; 0x33
    65e6:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    65ea:	9b 01       	movw	r18, r22
    65ec:	ac 01       	movw	r20, r24
    65ee:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    65f2:	1b 01       	movw	r2, r22
    65f4:	2c 01       	movw	r4, r24
    65f6:	29 85       	ldd	r18, Y+9	; 0x09
    65f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    65fa:	49 89       	ldd	r20, Y+17	; 0x11
    65fc:	5d 89       	ldd	r21, Y+21	; 0x15
    65fe:	6b 8d       	ldd	r22, Y+27	; 0x1b
    6600:	7c 8d       	ldd	r23, Y+28	; 0x1c
    6602:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6604:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6606:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    660a:	9b 01       	movw	r18, r22
    660c:	ac 01       	movw	r20, r24
    660e:	c2 01       	movw	r24, r4
    6610:	b1 01       	movw	r22, r2
    6612:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    6616:	56 2e       	mov	r5, r22
    6618:	47 2e       	mov	r4, r23
    661a:	38 2e       	mov	r3, r24
    661c:	29 2e       	mov	r2, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    661e:	bb 8d       	ldd	r27, Y+27	; 0x1b
    6620:	b9 87       	std	Y+9, r27	; 0x09
    6622:	ec 8d       	ldd	r30, Y+28	; 0x1c
    6624:	ed 87       	std	Y+13, r30	; 0x0d
    6626:	fd 8d       	ldd	r31, Y+29	; 0x1d
    6628:	f9 8b       	std	Y+17, r31	; 0x11
    662a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    662c:	2d 8b       	std	Y+21, r18	; 0x15
    662e:	18 ad       	ldd	r17, Y+56	; 0x38
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    6630:	f9 a0       	ldd	r15, Y+33	; 0x21
    6632:	ea a0       	ldd	r14, Y+34	; 0x22
    6634:	3b a1       	ldd	r19, Y+35	; 0x23
    6636:	3d af       	std	Y+61, r19	; 0x3d
    6638:	0c a1       	ldd	r16, Y+36	; 0x24
    663a:	d7 c0       	rjmp	.+430    	; 0x67ea <st_prep_buffer+0x970>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    663c:	2d 81       	ldd	r18, Y+5	; 0x05
    663e:	3e 81       	ldd	r19, Y+6	; 0x06
    6640:	4f 81       	ldd	r20, Y+7	; 0x07
    6642:	58 85       	ldd	r21, Y+8	; 0x08
    6644:	69 85       	ldd	r22, Y+9	; 0x09
    6646:	7d 85       	ldd	r23, Y+13	; 0x0d
    6648:	89 89       	ldd	r24, Y+17	; 0x11
    664a:	9d 89       	ldd	r25, Y+21	; 0x15
    664c:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    6650:	69 87       	std	Y+9, r22	; 0x09
    6652:	7d 87       	std	Y+13, r23	; 0x0d
    6654:	89 8b       	std	Y+17, r24	; 0x11
    6656:	9d 8b       	std	Y+21, r25	; 0x15
    6658:	c8 c0       	rjmp	.+400    	; 0x67ea <st_prep_buffer+0x970>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    665a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    665c:	3c 8d       	ldd	r19, Y+28	; 0x1c
    665e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    6660:	5e 8d       	ldd	r21, Y+30	; 0x1e
    6662:	65 2d       	mov	r22, r5
    6664:	74 2d       	mov	r23, r4
    6666:	83 2d       	mov	r24, r3
    6668:	92 2d       	mov	r25, r2
    666a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    666e:	9b 01       	movw	r18, r22
    6670:	ac 01       	movw	r20, r24
    6672:	6f 2d       	mov	r22, r15
    6674:	7e 2d       	mov	r23, r14
    6676:	8d ad       	ldd	r24, Y+61	; 0x3d
    6678:	90 2f       	mov	r25, r16
    667a:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    667e:	6d 83       	std	Y+5, r22	; 0x05
    6680:	7a 8f       	std	Y+26, r23	; 0x1a
    6682:	68 2e       	mov	r6, r24
    6684:	9f a7       	std	Y+47, r25	; 0x2f
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    6686:	26 2f       	mov	r18, r22
    6688:	37 2f       	mov	r19, r23
    668a:	48 2f       	mov	r20, r24
    668c:	59 2f       	mov	r21, r25
    668e:	6d a1       	ldd	r22, Y+37	; 0x25
    6690:	7e a1       	ldd	r23, Y+38	; 0x26
    6692:	8f a1       	ldd	r24, Y+39	; 0x27
    6694:	98 a5       	ldd	r25, Y+40	; 0x28
    6696:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    669a:	18 16       	cp	r1, r24
    669c:	0c f0       	brlt	.+2      	; 0x66a0 <st_prep_buffer+0x826>
    669e:	a1 c0       	rjmp	.+322    	; 0x67e2 <st_prep_buffer+0x968>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    66a0:	2d a1       	ldd	r18, Y+37	; 0x25
    66a2:	3e a1       	ldd	r19, Y+38	; 0x26
    66a4:	4f a1       	ldd	r20, Y+39	; 0x27
    66a6:	58 a5       	ldd	r21, Y+40	; 0x28
    66a8:	6f 2d       	mov	r22, r15
    66aa:	7e 2d       	mov	r23, r14
    66ac:	8d ad       	ldd	r24, Y+61	; 0x3d
    66ae:	90 2f       	mov	r25, r16
    66b0:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    66b4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    66b6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    66b8:	4d 8d       	ldd	r20, Y+29	; 0x1d
    66ba:	5e 8d       	ldd	r21, Y+30	; 0x1e
    66bc:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    66c0:	56 2e       	mov	r5, r22
    66c2:	47 2e       	mov	r4, r23
    66c4:	38 2e       	mov	r3, r24
    66c6:	29 2e       	mov	r2, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    66c8:	fd a0       	ldd	r15, Y+37	; 0x25
    66ca:	ee a0       	ldd	r14, Y+38	; 0x26
    66cc:	4f a1       	ldd	r20, Y+39	; 0x27
    66ce:	4d af       	std	Y+61, r20	; 0x3d
    66d0:	08 a5       	ldd	r16, Y+40	; 0x28
            prep.ramp_type = RAMP_DECEL;
    66d2:	19 ad       	ldd	r17, Y+57	; 0x39
    66d4:	8a c0       	rjmp	.+276    	; 0x67ea <st_prep_buffer+0x970>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    66d6:	af 8d       	ldd	r26, Y+31	; 0x1f
    66d8:	b8 a1       	ldd	r27, Y+32	; 0x20
    66da:	91 96       	adiw	r26, 0x21	; 33
    66dc:	2d 91       	ld	r18, X+
    66de:	3d 91       	ld	r19, X+
    66e0:	4d 91       	ld	r20, X+
    66e2:	5c 91       	ld	r21, X
    66e4:	94 97       	sbiw	r26, 0x24	; 36
    66e6:	65 2d       	mov	r22, r5
    66e8:	74 2d       	mov	r23, r4
    66ea:	83 2d       	mov	r24, r3
    66ec:	92 2d       	mov	r25, r2
    66ee:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    66f2:	6d 83       	std	Y+5, r22	; 0x05
    66f4:	7e 83       	std	Y+6, r23	; 0x06
    66f6:	8f 83       	std	Y+7, r24	; 0x07
    66f8:	98 87       	std	Y+8, r25	; 0x08
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    66fa:	9b 01       	movw	r18, r22
    66fc:	ac 01       	movw	r20, r24
    66fe:	69 85       	ldd	r22, Y+9	; 0x09
    6700:	7d 85       	ldd	r23, Y+13	; 0x0d
    6702:	89 89       	ldd	r24, Y+17	; 0x11
    6704:	9d 89       	ldd	r25, Y+21	; 0x15
    6706:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    670a:	18 16       	cp	r1, r24
    670c:	0c f0       	brlt	.+2      	; 0x6710 <st_prep_buffer+0x896>
    670e:	3f c0       	rjmp	.+126    	; 0x678e <st_prep_buffer+0x914>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    6710:	20 e0       	ldi	r18, 0x00	; 0
    6712:	30 e0       	ldi	r19, 0x00	; 0
    6714:	40 e0       	ldi	r20, 0x00	; 0
    6716:	5f e3       	ldi	r21, 0x3F	; 63
    6718:	6d 81       	ldd	r22, Y+5	; 0x05
    671a:	7e 81       	ldd	r23, Y+6	; 0x06
    671c:	8f 81       	ldd	r24, Y+7	; 0x07
    671e:	98 85       	ldd	r25, Y+8	; 0x08
    6720:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6724:	9b 01       	movw	r18, r22
    6726:	ac 01       	movw	r20, r24
    6728:	69 85       	ldd	r22, Y+9	; 0x09
    672a:	7d 85       	ldd	r23, Y+13	; 0x0d
    672c:	89 89       	ldd	r24, Y+17	; 0x11
    672e:	9d 89       	ldd	r25, Y+21	; 0x15
    6730:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6734:	25 2d       	mov	r18, r5
    6736:	34 2d       	mov	r19, r4
    6738:	43 2d       	mov	r20, r3
    673a:	52 2d       	mov	r21, r2
    673c:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6740:	9b 01       	movw	r18, r22
    6742:	ac 01       	movw	r20, r24
    6744:	6f 2d       	mov	r22, r15
    6746:	7e 2d       	mov	r23, r14
    6748:	8d ad       	ldd	r24, Y+61	; 0x3d
    674a:	90 2f       	mov	r25, r16
    674c:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6750:	6a 8f       	std	Y+26, r22	; 0x1a
    6752:	7f a7       	std	Y+47, r23	; 0x2f
    6754:	68 2e       	mov	r6, r24
    6756:	9c af       	std	Y+60, r25	; 0x3c
            if (mm_var > prep.mm_complete) { // Deceleration only.
    6758:	2e 89       	ldd	r18, Y+22	; 0x16
    675a:	3f 89       	ldd	r19, Y+23	; 0x17
    675c:	48 8d       	ldd	r20, Y+24	; 0x18
    675e:	59 8d       	ldd	r21, Y+25	; 0x19
    6760:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    6764:	18 16       	cp	r1, r24
    6766:	9c f4       	brge	.+38     	; 0x678e <st_prep_buffer+0x914>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    6768:	2d 81       	ldd	r18, Y+5	; 0x05
    676a:	3e 81       	ldd	r19, Y+6	; 0x06
    676c:	4f 81       	ldd	r20, Y+7	; 0x07
    676e:	58 85       	ldd	r21, Y+8	; 0x08
    6770:	69 85       	ldd	r22, Y+9	; 0x09
    6772:	7d 85       	ldd	r23, Y+13	; 0x0d
    6774:	89 89       	ldd	r24, Y+17	; 0x11
    6776:	9d 89       	ldd	r25, Y+21	; 0x15
    6778:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    677c:	69 87       	std	Y+9, r22	; 0x09
    677e:	7d 87       	std	Y+13, r23	; 0x0d
    6780:	89 8b       	std	Y+17, r24	; 0x11
    6782:	9d 8b       	std	Y+21, r25	; 0x15
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    6784:	fa 8c       	ldd	r15, Y+26	; 0x1a
    6786:	ef a4       	ldd	r14, Y+47	; 0x2f
    6788:	6d ae       	std	Y+61, r6	; 0x3d
    678a:	0c ad       	ldd	r16, Y+60	; 0x3c
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    678c:	2e c0       	rjmp	.+92     	; 0x67ea <st_prep_buffer+0x970>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    678e:	2e 89       	ldd	r18, Y+22	; 0x16
    6790:	3f 89       	ldd	r19, Y+23	; 0x17
    6792:	48 8d       	ldd	r20, Y+24	; 0x18
    6794:	59 8d       	ldd	r21, Y+25	; 0x19
    6796:	6f 2d       	mov	r22, r15
    6798:	7e 2d       	mov	r23, r14
    679a:	8d ad       	ldd	r24, Y+61	; 0x3d
    679c:	90 2f       	mov	r25, r16
    679e:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    67a2:	9b 01       	movw	r18, r22
    67a4:	ac 01       	movw	r20, r24
    67a6:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    67aa:	1b 01       	movw	r2, r22
    67ac:	2c 01       	movw	r4, r24
    67ae:	2c a9       	ldd	r18, Y+52	; 0x34
    67b0:	3d a9       	ldd	r19, Y+53	; 0x35
    67b2:	4e a9       	ldd	r20, Y+54	; 0x36
    67b4:	5f a9       	ldd	r21, Y+55	; 0x37
    67b6:	69 85       	ldd	r22, Y+9	; 0x09
    67b8:	7d 85       	ldd	r23, Y+13	; 0x0d
    67ba:	89 89       	ldd	r24, Y+17	; 0x11
    67bc:	9d 89       	ldd	r25, Y+21	; 0x15
    67be:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    67c2:	9b 01       	movw	r18, r22
    67c4:	ac 01       	movw	r20, r24
    67c6:	c2 01       	movw	r24, r4
    67c8:	b1 01       	movw	r22, r2
    67ca:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    67ce:	56 2e       	mov	r5, r22
    67d0:	47 2e       	mov	r4, r23
    67d2:	38 2e       	mov	r3, r24
    67d4:	29 2e       	mov	r2, r25
          mm_remaining = prep.mm_complete; 
    67d6:	fe 88       	ldd	r15, Y+22	; 0x16
    67d8:	ef 88       	ldd	r14, Y+23	; 0x17
    67da:	b8 8d       	ldd	r27, Y+24	; 0x18
    67dc:	bd af       	std	Y+61, r27	; 0x3d
    67de:	09 8d       	ldd	r16, Y+25	; 0x19
    67e0:	04 c0       	rjmp	.+8      	; 0x67ea <st_prep_buffer+0x970>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    67e2:	fd 80       	ldd	r15, Y+5	; 0x05
    67e4:	ea 8c       	ldd	r14, Y+26	; 0x1a
    67e6:	6d ae       	std	Y+61, r6	; 0x3d
    67e8:	0f a5       	ldd	r16, Y+47	; 0x2f
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    67ea:	25 2d       	mov	r18, r5
    67ec:	34 2d       	mov	r19, r4
    67ee:	43 2d       	mov	r20, r3
    67f0:	52 2d       	mov	r21, r2
    67f2:	c5 01       	movw	r24, r10
    67f4:	b4 01       	movw	r22, r8
    67f6:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    67fa:	4b 01       	movw	r8, r22
    67fc:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    67fe:	9b 01       	movw	r18, r22
    6800:	ac 01       	movw	r20, r24
    6802:	67 2d       	mov	r22, r7
    6804:	79 81       	ldd	r23, Y+1	; 0x01
    6806:	8d 2d       	mov	r24, r13
    6808:	9c 2d       	mov	r25, r12
    680a:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    680e:	18 16       	cp	r1, r24
    6810:	6c f4       	brge	.+26     	; 0x682c <st_prep_buffer+0x9b2>
    6812:	a5 01       	movw	r20, r10
    6814:	94 01       	movw	r18, r8
    6816:	67 2d       	mov	r22, r7
    6818:	79 81       	ldd	r23, Y+1	; 0x01
    681a:	8d 2d       	mov	r24, r13
    681c:	9c 2d       	mov	r25, r12
    681e:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6822:	56 2e       	mov	r5, r22
    6824:	47 2e       	mov	r4, r23
    6826:	38 2e       	mov	r3, r24
    6828:	29 2e       	mov	r2, r25
    682a:	38 c0       	rjmp	.+112    	; 0x689c <st_prep_buffer+0xa22>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    682c:	2b a5       	ldd	r18, Y+43	; 0x2b
    682e:	3c a5       	ldd	r19, Y+44	; 0x2c
    6830:	4d a5       	ldd	r20, Y+45	; 0x2d
    6832:	5e a5       	ldd	r21, Y+46	; 0x2e
    6834:	6f 2d       	mov	r22, r15
    6836:	7e 2d       	mov	r23, r14
    6838:	8d ad       	ldd	r24, Y+61	; 0x3d
    683a:	90 2f       	mov	r25, r16
    683c:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    6840:	18 16       	cp	r1, r24
    6842:	b4 f0       	brlt	.+44     	; 0x6870 <st_prep_buffer+0x9f6>
    6844:	1d 83       	std	Y+5, r17	; 0x05
    6846:	6a ac       	ldd	r6, Y+58	; 0x3a
    6848:	7b ac       	ldd	r7, Y+59	; 0x3b
    684a:	8e 2d       	mov	r24, r14
    684c:	ef 2c       	mov	r14, r15
    684e:	10 2f       	mov	r17, r16
    6850:	0d ad       	ldd	r16, Y+61	; 0x3d
    6852:	f8 2e       	mov	r15, r24
    6854:	ed 81       	ldd	r30, Y+5	; 0x05
    6856:	d3 01       	movw	r26, r6
    6858:	52 96       	adiw	r26, 0x12	; 18
    685a:	ec 93       	st	X, r30
    685c:	89 85       	ldd	r24, Y+9	; 0x09
    685e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6860:	a9 89       	ldd	r26, Y+17	; 0x11
    6862:	bd 89       	ldd	r27, Y+21	; 0x15
    6864:	f3 01       	movw	r30, r6
    6866:	87 8b       	std	Z+23, r24	; 0x17
    6868:	90 8f       	std	Z+24, r25	; 0x18
    686a:	a1 8f       	std	Z+25, r26	; 0x19
    686c:	b2 8f       	std	Z+26, r27	; 0x1a
    686e:	38 c0       	rjmp	.+112    	; 0x68e0 <st_prep_buffer+0xa66>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    6870:	2e e3       	ldi	r18, 0x3E	; 62
    6872:	33 ec       	ldi	r19, 0xC3	; 195
    6874:	4e e2       	ldi	r20, 0x2E	; 46
    6876:	59 e3       	ldi	r21, 0x39	; 57
    6878:	67 2d       	mov	r22, r7
    687a:	79 81       	ldd	r23, Y+1	; 0x01
    687c:	8d 2d       	mov	r24, r13
    687e:	9c 2d       	mov	r25, r12
    6880:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    6884:	76 2e       	mov	r7, r22
    6886:	79 83       	std	Y+1, r23	; 0x01
    6888:	d8 2e       	mov	r13, r24
    688a:	c9 2e       	mov	r12, r25
          time_var = dt_max - dt;
    688c:	a5 01       	movw	r20, r10
    688e:	94 01       	movw	r18, r8
    6890:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6894:	56 2e       	mov	r5, r22
    6896:	47 2e       	mov	r4, r23
    6898:	38 2e       	mov	r3, r24
    689a:	29 2e       	mov	r2, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    689c:	2e 89       	ldd	r18, Y+22	; 0x16
    689e:	3f 89       	ldd	r19, Y+23	; 0x17
    68a0:	48 8d       	ldd	r20, Y+24	; 0x18
    68a2:	59 8d       	ldd	r21, Y+25	; 0x19
    68a4:	6f 2d       	mov	r22, r15
    68a6:	7e 2d       	mov	r23, r14
    68a8:	8d ad       	ldd	r24, Y+61	; 0x3d
    68aa:	90 2f       	mov	r25, r16
    68ac:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    68b0:	18 16       	cp	r1, r24
    68b2:	0c f4       	brge	.+2      	; 0x68b6 <st_prep_buffer+0xa3c>
    68b4:	52 ce       	rjmp	.-860    	; 0x655a <st_prep_buffer+0x6e0>
    68b6:	1d 83       	std	Y+5, r17	; 0x05
    68b8:	6a ac       	ldd	r6, Y+58	; 0x3a
    68ba:	7b ac       	ldd	r7, Y+59	; 0x3b
    68bc:	8e 2d       	mov	r24, r14
    68be:	ef 2c       	mov	r14, r15
    68c0:	10 2f       	mov	r17, r16
    68c2:	0d ad       	ldd	r16, Y+61	; 0x3d
    68c4:	f8 2e       	mov	r15, r24
    68c6:	ed 81       	ldd	r30, Y+5	; 0x05
    68c8:	d3 01       	movw	r26, r6
    68ca:	52 96       	adiw	r26, 0x12	; 18
    68cc:	ec 93       	st	X, r30
    68ce:	89 85       	ldd	r24, Y+9	; 0x09
    68d0:	9d 85       	ldd	r25, Y+13	; 0x0d
    68d2:	a9 89       	ldd	r26, Y+17	; 0x11
    68d4:	bd 89       	ldd	r27, Y+21	; 0x15
    68d6:	f3 01       	movw	r30, r6
    68d8:	87 8b       	std	Z+23, r24	; 0x17
    68da:	90 8f       	std	Z+24, r25	; 0x18
    68dc:	a1 8f       	std	Z+25, r26	; 0x19
    68de:	b2 8f       	std	Z+26, r27	; 0x1a
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    68e0:	d3 01       	movw	r26, r6
    68e2:	16 96       	adiw	r26, 0x06	; 6
    68e4:	2d 91       	ld	r18, X+
    68e6:	3d 91       	ld	r19, X+
    68e8:	4d 91       	ld	r20, X+
    68ea:	5c 91       	ld	r21, X
    68ec:	19 97       	sbiw	r26, 0x09	; 9
    68ee:	29 8b       	std	Y+17, r18	; 0x11
    68f0:	3a 8b       	std	Y+18, r19	; 0x12
    68f2:	4b 8b       	std	Y+19, r20	; 0x13
    68f4:	5c 8b       	std	Y+20, r21	; 0x14
    68f6:	6e 2d       	mov	r22, r14
    68f8:	7f 2d       	mov	r23, r15
    68fa:	80 2f       	mov	r24, r16
    68fc:	91 2f       	mov	r25, r17
    68fe:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6902:	69 83       	std	Y+1, r22	; 0x01
    6904:	7a 83       	std	Y+2, r23	; 0x02
    6906:	8b 83       	std	Y+3, r24	; 0x03
    6908:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    690a:	0e 94 ab 39 	call	0x7356	; 0x7356 <ceil>
    690e:	1b 01       	movw	r2, r22
    6910:	2c 01       	movw	r4, r24
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    6912:	f3 01       	movw	r30, r6
    6914:	62 81       	ldd	r22, Z+2	; 0x02
    6916:	73 81       	ldd	r23, Z+3	; 0x03
    6918:	84 81       	ldd	r24, Z+4	; 0x04
    691a:	95 81       	ldd	r25, Z+5	; 0x05
    691c:	0e 94 ab 39 	call	0x7356	; 0x7356 <ceil>
    6920:	6d 87       	std	Y+13, r22	; 0x0d
    6922:	7e 87       	std	Y+14, r23	; 0x0e
    6924:	8f 87       	std	Y+15, r24	; 0x0f
    6926:	98 8b       	std	Y+16, r25	; 0x10
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    6928:	a2 01       	movw	r20, r4
    692a:	91 01       	movw	r18, r2
    692c:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    6930:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    6934:	69 87       	std	Y+9, r22	; 0x09
    6936:	7a 87       	std	Y+10, r23	; 0x0a
    6938:	8b 87       	std	Y+11, r24	; 0x0b
    693a:	9c 87       	std	Y+12, r25	; 0x0c
    693c:	e9 a5       	ldd	r30, Y+41	; 0x29
    693e:	fa a5       	ldd	r31, Y+42	; 0x2a
    6940:	ee 0f       	add	r30, r30
    6942:	ff 1f       	adc	r31, r31
    6944:	29 a5       	ldd	r18, Y+41	; 0x29
    6946:	3a a5       	ldd	r19, Y+42	; 0x2a
    6948:	e2 0f       	add	r30, r18
    694a:	f3 1f       	adc	r31, r19
    694c:	ee 0f       	add	r30, r30
    694e:	ff 1f       	adc	r31, r31
    6950:	ee 54       	subi	r30, 0x4E	; 78
    6952:	fb 4f       	sbci	r31, 0xFB	; 251
    6954:	49 85       	ldd	r20, Y+9	; 0x09
    6956:	5a 85       	ldd	r21, Y+10	; 0x0a
    6958:	51 83       	std	Z+1, r21	; 0x01
    695a:	40 83       	st	Z, r20
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    695c:	ca 01       	movw	r24, r20
    695e:	89 2b       	or	r24, r25
    6960:	31 f5       	brne	.+76     	; 0x69ae <st_prep_buffer+0xb34>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    6962:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    6966:	80 77       	andi	r24, 0x70	; 112
    6968:	11 f1       	breq	.+68     	; 0x69ae <st_prep_buffer+0xb34>
    696a:	0f 8d       	ldd	r16, Y+31	; 0x1f
    696c:	18 a1       	ldd	r17, Y+32	; 0x20
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    696e:	ec e5       	ldi	r30, 0x5C	; 92
    6970:	f4 e0       	ldi	r31, 0x04	; 4
    6972:	17 8a       	std	Z+23, r1	; 0x17
    6974:	10 8e       	std	Z+24, r1	; 0x18
    6976:	11 8e       	std	Z+25, r1	; 0x19
    6978:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    697a:	16 86       	std	Z+14, r1	; 0x0e
    697c:	17 86       	std	Z+15, r1	; 0x0f
    697e:	10 8a       	std	Z+16, r1	; 0x10
    6980:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = n_steps_remaining;
    6982:	22 82       	std	Z+2, r2	; 0x02
    6984:	33 82       	std	Z+3, r3	; 0x03
    6986:	44 82       	std	Z+4, r4	; 0x04
    6988:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    698a:	29 89       	ldd	r18, Y+17	; 0x11
    698c:	3a 89       	ldd	r19, Y+18	; 0x12
    698e:	4b 89       	ldd	r20, Y+19	; 0x13
    6990:	5c 89       	ldd	r21, Y+20	; 0x14
    6992:	c2 01       	movw	r24, r4
    6994:	b1 01       	movw	r22, r2
    6996:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    699a:	d8 01       	movw	r26, r16
    699c:	95 96       	adiw	r26, 0x25	; 37
    699e:	6d 93       	st	X+, r22
    69a0:	7d 93       	st	X+, r23
    69a2:	8d 93       	st	X+, r24
    69a4:	9c 93       	st	X, r25
    69a6:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize();         
    69a8:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    69ac:	45 c1       	rjmp	.+650    	; 0x6c38 <st_prep_buffer+0xdbe>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    69ae:	f3 01       	movw	r30, r6
    69b0:	26 85       	ldd	r18, Z+14	; 0x0e
    69b2:	37 85       	ldd	r19, Z+15	; 0x0f
    69b4:	40 89       	ldd	r20, Z+16	; 0x10
    69b6:	51 89       	ldd	r21, Z+17	; 0x11
    69b8:	c5 01       	movw	r24, r10
    69ba:	b4 01       	movw	r22, r8
    69bc:	0e 94 cd 38 	call	0x719a	; 0x719a <__addsf3>
    69c0:	4b 01       	movw	r8, r22
    69c2:	5c 01       	movw	r10, r24
    69c4:	29 81       	ldd	r18, Y+1	; 0x01
    69c6:	3a 81       	ldd	r19, Y+2	; 0x02
    69c8:	4b 81       	ldd	r20, Y+3	; 0x03
    69ca:	5c 81       	ldd	r21, Y+4	; 0x04
    69cc:	6d 85       	ldd	r22, Y+13	; 0x0d
    69ce:	7e 85       	ldd	r23, Y+14	; 0x0e
    69d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    69d2:	98 89       	ldd	r25, Y+16	; 0x10
    69d4:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    69d8:	9b 01       	movw	r18, r22
    69da:	ac 01       	movw	r20, r24
    69dc:	c5 01       	movw	r24, r10
    69de:	b4 01       	movw	r22, r8
    69e0:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    69e4:	4b 01       	movw	r8, r22
    69e6:	5c 01       	movw	r10, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    69e8:	29 81       	ldd	r18, Y+1	; 0x01
    69ea:	3a 81       	ldd	r19, Y+2	; 0x02
    69ec:	4b 81       	ldd	r20, Y+3	; 0x03
    69ee:	5c 81       	ldd	r21, Y+4	; 0x04
    69f0:	c2 01       	movw	r24, r4
    69f2:	b1 01       	movw	r22, r2
    69f4:	0e 94 cc 38 	call	0x7198	; 0x7198 <__subsf3>
    69f8:	a5 01       	movw	r20, r10
    69fa:	94 01       	movw	r18, r8
    69fc:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6a00:	d3 01       	movw	r26, r6
    6a02:	1e 96       	adiw	r26, 0x0e	; 14
    6a04:	6d 93       	st	X+, r22
    6a06:	7d 93       	st	X+, r23
    6a08:	8d 93       	st	X+, r24
    6a0a:	9c 93       	st	X, r25
    6a0c:	51 97       	sbiw	r26, 0x11	; 17

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    6a0e:	20 ec       	ldi	r18, 0xC0	; 192
    6a10:	31 ee       	ldi	r19, 0xE1	; 225
    6a12:	44 e6       	ldi	r20, 0x64	; 100
    6a14:	5e e4       	ldi	r21, 0x4E	; 78
    6a16:	c5 01       	movw	r24, r10
    6a18:	b4 01       	movw	r22, r8
    6a1a:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    6a1e:	0e 94 ab 39 	call	0x7356	; 0x7356 <ceil>
    6a22:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    6a26:	60 3d       	cpi	r22, 0xD0	; 208
    6a28:	b7 e0       	ldi	r27, 0x07	; 7
    6a2a:	7b 07       	cpc	r23, r27
    6a2c:	81 05       	cpc	r24, r1
    6a2e:	91 05       	cpc	r25, r1
    6a30:	70 f4       	brcc	.+28     	; 0x6a4e <st_prep_buffer+0xbd4>
    6a32:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a34:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a36:	ee 0f       	add	r30, r30
    6a38:	ff 1f       	adc	r31, r31
    6a3a:	29 a5       	ldd	r18, Y+41	; 0x29
    6a3c:	3a a5       	ldd	r19, Y+42	; 0x2a
    6a3e:	e2 0f       	add	r30, r18
    6a40:	f3 1f       	adc	r31, r19
    6a42:	ee 0f       	add	r30, r30
    6a44:	ff 1f       	adc	r31, r31
    6a46:	ee 54       	subi	r30, 0x4E	; 78
    6a48:	fb 4f       	sbci	r31, 0xFB	; 251
    6a4a:	15 82       	std	Z+5, r1	; 0x05
    6a4c:	56 c0       	rjmp	.+172    	; 0x6afa <st_prep_buffer+0xc80>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    6a4e:	60 3a       	cpi	r22, 0xA0	; 160
    6a50:	3f e0       	ldi	r19, 0x0F	; 15
    6a52:	73 07       	cpc	r23, r19
    6a54:	81 05       	cpc	r24, r1
    6a56:	91 05       	cpc	r25, r1
    6a58:	78 f4       	brcc	.+30     	; 0x6a78 <st_prep_buffer+0xbfe>
    6a5a:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a5c:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a5e:	ee 0f       	add	r30, r30
    6a60:	ff 1f       	adc	r31, r31
    6a62:	49 a5       	ldd	r20, Y+41	; 0x29
    6a64:	5a a5       	ldd	r21, Y+42	; 0x2a
    6a66:	e4 0f       	add	r30, r20
    6a68:	f5 1f       	adc	r31, r21
    6a6a:	ee 0f       	add	r30, r30
    6a6c:	ff 1f       	adc	r31, r31
    6a6e:	ee 54       	subi	r30, 0x4E	; 78
    6a70:	fb 4f       	sbci	r31, 0xFB	; 251
    6a72:	51 e0       	ldi	r21, 0x01	; 1
    6a74:	55 83       	std	Z+5, r21	; 0x05
    6a76:	23 c0       	rjmp	.+70     	; 0x6abe <st_prep_buffer+0xc44>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    6a78:	60 34       	cpi	r22, 0x40	; 64
    6a7a:	af e1       	ldi	r26, 0x1F	; 31
    6a7c:	7a 07       	cpc	r23, r26
    6a7e:	81 05       	cpc	r24, r1
    6a80:	91 05       	cpc	r25, r1
    6a82:	78 f4       	brcc	.+30     	; 0x6aa2 <st_prep_buffer+0xc28>
    6a84:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a86:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a88:	ee 0f       	add	r30, r30
    6a8a:	ff 1f       	adc	r31, r31
    6a8c:	29 a5       	ldd	r18, Y+41	; 0x29
    6a8e:	3a a5       	ldd	r19, Y+42	; 0x2a
    6a90:	e2 0f       	add	r30, r18
    6a92:	f3 1f       	adc	r31, r19
    6a94:	ee 0f       	add	r30, r30
    6a96:	ff 1f       	adc	r31, r31
    6a98:	ee 54       	subi	r30, 0x4E	; 78
    6a9a:	fb 4f       	sbci	r31, 0xFB	; 251
    6a9c:	32 e0       	ldi	r19, 0x02	; 2
    6a9e:	35 83       	std	Z+5, r19	; 0x05
    6aa0:	0e c0       	rjmp	.+28     	; 0x6abe <st_prep_buffer+0xc44>
        else { prep_segment->amass_level = 3; }    
    6aa2:	e9 a5       	ldd	r30, Y+41	; 0x29
    6aa4:	fa a5       	ldd	r31, Y+42	; 0x2a
    6aa6:	ee 0f       	add	r30, r30
    6aa8:	ff 1f       	adc	r31, r31
    6aaa:	49 a5       	ldd	r20, Y+41	; 0x29
    6aac:	5a a5       	ldd	r21, Y+42	; 0x2a
    6aae:	e4 0f       	add	r30, r20
    6ab0:	f5 1f       	adc	r31, r21
    6ab2:	ee 0f       	add	r30, r30
    6ab4:	ff 1f       	adc	r31, r31
    6ab6:	ee 54       	subi	r30, 0x4E	; 78
    6ab8:	fb 4f       	sbci	r31, 0xFB	; 251
    6aba:	53 e0       	ldi	r21, 0x03	; 3
    6abc:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level; 
    6abe:	e9 a5       	ldd	r30, Y+41	; 0x29
    6ac0:	fa a5       	ldd	r31, Y+42	; 0x2a
    6ac2:	ee 0f       	add	r30, r30
    6ac4:	ff 1f       	adc	r31, r31
    6ac6:	a9 a5       	ldd	r26, Y+41	; 0x29
    6ac8:	ba a5       	ldd	r27, Y+42	; 0x2a
    6aca:	ea 0f       	add	r30, r26
    6acc:	fb 1f       	adc	r31, r27
    6ace:	ee 0f       	add	r30, r30
    6ad0:	ff 1f       	adc	r31, r31
    6ad2:	ee 54       	subi	r30, 0x4E	; 78
    6ad4:	fb 4f       	sbci	r31, 0xFB	; 251
    6ad6:	25 81       	ldd	r18, Z+5	; 0x05
    6ad8:	02 2e       	mov	r0, r18
    6ada:	04 c0       	rjmp	.+8      	; 0x6ae4 <st_prep_buffer+0xc6a>
    6adc:	96 95       	lsr	r25
    6ade:	87 95       	ror	r24
    6ae0:	77 95       	ror	r23
    6ae2:	67 95       	ror	r22
    6ae4:	0a 94       	dec	r0
    6ae6:	d2 f7       	brpl	.-12     	; 0x6adc <st_prep_buffer+0xc62>
        prep_segment->n_step <<= prep_segment->amass_level;
    6ae8:	49 85       	ldd	r20, Y+9	; 0x09
    6aea:	5a 85       	ldd	r21, Y+10	; 0x0a
    6aec:	02 c0       	rjmp	.+4      	; 0x6af2 <st_prep_buffer+0xc78>
    6aee:	44 0f       	add	r20, r20
    6af0:	55 1f       	adc	r21, r21
    6af2:	2a 95       	dec	r18
    6af4:	e2 f7       	brpl	.-8      	; 0x6aee <st_prep_buffer+0xc74>
    6af6:	51 83       	std	Z+1, r21	; 0x01
    6af8:	40 83       	st	Z, r20
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    6afa:	61 15       	cp	r22, r1
    6afc:	71 05       	cpc	r23, r1
    6afe:	51 e0       	ldi	r21, 0x01	; 1
    6b00:	85 07       	cpc	r24, r21
    6b02:	91 05       	cpc	r25, r1
    6b04:	78 f4       	brcc	.+30     	; 0x6b24 <st_prep_buffer+0xcaa>
    6b06:	e9 a5       	ldd	r30, Y+41	; 0x29
    6b08:	fa a5       	ldd	r31, Y+42	; 0x2a
    6b0a:	ee 0f       	add	r30, r30
    6b0c:	ff 1f       	adc	r31, r31
    6b0e:	a9 a5       	ldd	r26, Y+41	; 0x29
    6b10:	ba a5       	ldd	r27, Y+42	; 0x2a
    6b12:	ea 0f       	add	r30, r26
    6b14:	fb 1f       	adc	r31, r27
    6b16:	ee 0f       	add	r30, r30
    6b18:	ff 1f       	adc	r31, r31
    6b1a:	ee 54       	subi	r30, 0x4E	; 78
    6b1c:	fb 4f       	sbci	r31, 0xFB	; 251
    6b1e:	74 83       	std	Z+4, r23	; 0x04
    6b20:	63 83       	std	Z+3, r22	; 0x03
    6b22:	10 c0       	rjmp	.+32     	; 0x6b44 <st_prep_buffer+0xcca>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    6b24:	e9 a5       	ldd	r30, Y+41	; 0x29
    6b26:	fa a5       	ldd	r31, Y+42	; 0x2a
    6b28:	ee 0f       	add	r30, r30
    6b2a:	ff 1f       	adc	r31, r31
    6b2c:	29 a5       	ldd	r18, Y+41	; 0x29
    6b2e:	3a a5       	ldd	r19, Y+42	; 0x2a
    6b30:	e2 0f       	add	r30, r18
    6b32:	f3 1f       	adc	r31, r19
    6b34:	ee 0f       	add	r30, r30
    6b36:	ff 1f       	adc	r31, r31
    6b38:	ee 54       	subi	r30, 0x4E	; 78
    6b3a:	fb 4f       	sbci	r31, 0xFB	; 251
    6b3c:	4f ef       	ldi	r20, 0xFF	; 255
    6b3e:	5f ef       	ldi	r21, 0xFF	; 255
    6b40:	54 83       	std	Z+4, r21	; 0x04
    6b42:	43 83       	std	Z+3, r20	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    6b44:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <segment_next_head>
    6b48:	80 93 8d 04 	sts	0x048D, r24	; 0x80048d <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    6b4c:	8f 5f       	subi	r24, 0xFF	; 255
    6b4e:	86 30       	cpi	r24, 0x06	; 6
    6b50:	19 f0       	breq	.+6      	; 0x6b58 <st_prep_buffer+0xcde>
    6b52:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <segment_next_head>
    6b56:	02 c0       	rjmp	.+4      	; 0x6b5c <st_prep_buffer+0xce2>
    6b58:	10 92 8c 04 	sts	0x048C, r1	; 0x80048c <segment_next_head>

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    6b5c:	d3 01       	movw	r26, r6
    6b5e:	53 96       	adiw	r26, 0x13	; 19
    6b60:	2d 91       	ld	r18, X+
    6b62:	3d 91       	ld	r19, X+
    6b64:	4d 91       	ld	r20, X+
    6b66:	5c 91       	ld	r21, X
    6b68:	56 97       	sbiw	r26, 0x16	; 22
    6b6a:	6e 2d       	mov	r22, r14
    6b6c:	7f 2d       	mov	r23, r15
    6b6e:	80 2f       	mov	r24, r16
    6b70:	91 2f       	mov	r25, r17
    6b72:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    6b76:	18 16       	cp	r1, r24
    6b78:	c4 f4       	brge	.+48     	; 0x6baa <st_prep_buffer+0xd30>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    6b7a:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <pl_block>
    6b7e:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <pl_block+0x1>
    6b82:	8e 2d       	mov	r24, r14
    6b84:	9f 2d       	mov	r25, r15
    6b86:	a0 2f       	mov	r26, r16
    6b88:	b1 2f       	mov	r27, r17
    6b8a:	85 a3       	std	Z+37, r24	; 0x25
    6b8c:	96 a3       	std	Z+38, r25	; 0x26
    6b8e:	a7 a3       	std	Z+39, r26	; 0x27
    6b90:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    6b92:	29 81       	ldd	r18, Y+1	; 0x01
    6b94:	3a 81       	ldd	r19, Y+2	; 0x02
    6b96:	4b 81       	ldd	r20, Y+3	; 0x03
    6b98:	5c 81       	ldd	r21, Y+4	; 0x04
    6b9a:	d3 01       	movw	r26, r6
    6b9c:	12 96       	adiw	r26, 0x02	; 2
    6b9e:	2d 93       	st	X+, r18
    6ba0:	3d 93       	st	X+, r19
    6ba2:	4d 93       	st	X+, r20
    6ba4:	5c 93       	st	X, r21
    6ba6:	15 97       	sbiw	r26, 0x05	; 5
    6ba8:	41 c0       	rjmp	.+130    	; 0x6c2c <st_prep_buffer+0xdb2>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    6baa:	20 e0       	ldi	r18, 0x00	; 0
    6bac:	30 e0       	ldi	r19, 0x00	; 0
    6bae:	a9 01       	movw	r20, r18
    6bb0:	6e 2d       	mov	r22, r14
    6bb2:	7f 2d       	mov	r23, r15
    6bb4:	80 2f       	mov	r24, r16
    6bb6:	91 2f       	mov	r25, r17
    6bb8:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    6bbc:	18 16       	cp	r1, r24
    6bbe:	3c f5       	brge	.+78     	; 0x6c0e <st_prep_buffer+0xd94>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    6bc0:	ec e5       	ldi	r30, 0x5C	; 92
    6bc2:	f4 e0       	ldi	r31, 0x04	; 4
    6bc4:	17 8a       	std	Z+23, r1	; 0x17
    6bc6:	10 8e       	std	Z+24, r1	; 0x18
    6bc8:	11 8e       	std	Z+25, r1	; 0x19
    6bca:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    6bcc:	16 86       	std	Z+14, r1	; 0x0e
    6bce:	17 86       	std	Z+15, r1	; 0x0f
    6bd0:	10 8a       	std	Z+16, r1	; 0x10
    6bd2:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = ceil(steps_remaining);
    6bd4:	22 82       	std	Z+2, r2	; 0x02
    6bd6:	33 82       	std	Z+3, r3	; 0x03
    6bd8:	44 82       	std	Z+4, r4	; 0x04
    6bda:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    6bdc:	20 91 87 04 	lds	r18, 0x0487	; 0x800487 <pl_block>
    6be0:	30 91 88 04 	lds	r19, 0x0488	; 0x800488 <pl_block+0x1>
    6be4:	3a 83       	std	Y+2, r19	; 0x02
    6be6:	29 83       	std	Y+1, r18	; 0x01
    6be8:	26 81       	ldd	r18, Z+6	; 0x06
    6bea:	37 81       	ldd	r19, Z+7	; 0x07
    6bec:	40 85       	ldd	r20, Z+8	; 0x08
    6bee:	51 85       	ldd	r21, Z+9	; 0x09
    6bf0:	c2 01       	movw	r24, r4
    6bf2:	b1 01       	movw	r22, r2
    6bf4:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
    6bf8:	a9 81       	ldd	r26, Y+1	; 0x01
    6bfa:	ba 81       	ldd	r27, Y+2	; 0x02
    6bfc:	95 96       	adiw	r26, 0x25	; 37
    6bfe:	6d 93       	st	X+, r22
    6c00:	7d 93       	st	X+, r23
    6c02:	8d 93       	st	X+, r24
    6c04:	9c 93       	st	X, r25
    6c06:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    6c08:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <plan_cycle_reinitialize>
        return; // Bail!
    6c0c:	15 c0       	rjmp	.+42     	; 0x6c38 <st_prep_buffer+0xdbe>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    6c0e:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <pl_block+0x1>
    6c12:	10 92 87 04 	sts	0x0487, r1	; 0x800487 <pl_block>
        plan_discard_current_block();
    6c16:	0e 94 e7 1a 	call	0x35ce	; 0x35ce <plan_discard_current_block>
    6c1a:	08 c0       	rjmp	.+16     	; 0x6c2c <st_prep_buffer+0xdb2>
	  }
                      
      //printString("Segment");
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    6c1c:	0f 2e       	mov	r0, r31
    6c1e:	fc e5       	ldi	r31, 0x5C	; 92
    6c20:	6f 2e       	mov	r6, r31
    6c22:	f4 e0       	ldi	r31, 0x04	; 4
    6c24:	7f 2e       	mov	r7, r31
    6c26:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise. 
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    6c28:	b2 e0       	ldi	r27, 0x02	; 2
    6c2a:	b9 af       	std	Y+57, r27	; 0x39
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    6c2c:	90 91 8e 04 	lds	r25, 0x048E	; 0x80048e <segment_buffer_tail>
    6c30:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <segment_next_head>
    6c34:	98 13       	cpse	r25, r24
    6c36:	50 c9       	rjmp	.-3424   	; 0x5ed8 <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    6c38:	ed 96       	adiw	r28, 0x3d	; 61
    6c3a:	0f b6       	in	r0, 0x3f	; 63
    6c3c:	f8 94       	cli
    6c3e:	de bf       	out	0x3e, r29	; 62
    6c40:	0f be       	out	0x3f, r0	; 63
    6c42:	cd bf       	out	0x3d, r28	; 61
    6c44:	df 91       	pop	r29
    6c46:	cf 91       	pop	r28
    6c48:	1f 91       	pop	r17
    6c4a:	0f 91       	pop	r16
    6c4c:	ff 90       	pop	r15
    6c4e:	ef 90       	pop	r14
    6c50:	df 90       	pop	r13
    6c52:	cf 90       	pop	r12
    6c54:	bf 90       	pop	r11
    6c56:	af 90       	pop	r10
    6c58:	9f 90       	pop	r9
    6c5a:	8f 90       	pop	r8
    6c5c:	7f 90       	pop	r7
    6c5e:	6f 90       	pop	r6
    6c60:	5f 90       	pop	r5
    6c62:	4f 90       	pop	r4
    6c64:	3f 90       	pop	r3
    6c66:	2f 90       	pop	r2
    6c68:	08 95       	ret

00006c6a <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    6c6a:	87 b1       	in	r24, 0x07	; 7
    6c6c:	88 7f       	andi	r24, 0xF8	; 248
    6c6e:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    6c70:	88 b1       	in	r24, 0x08	; 8
    6c72:	87 60       	ori	r24, 0x07	; 7
    6c74:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    6c76:	ec e6       	ldi	r30, 0x6C	; 108
    6c78:	f0 e0       	ldi	r31, 0x00	; 0
    6c7a:	80 81       	ld	r24, Z
    6c7c:	87 60       	ori	r24, 0x07	; 7
    6c7e:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    6c80:	e8 e6       	ldi	r30, 0x68	; 104
    6c82:	f0 e0       	ldi	r31, 0x00	; 0
    6c84:	80 81       	ld	r24, Z
    6c86:	82 60       	ori	r24, 0x02	; 2
    6c88:	80 83       	st	Z, r24
    6c8a:	08 95       	ret

00006c8c <__vector_4>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    6c8c:	1f 92       	push	r1
    6c8e:	0f 92       	push	r0
    6c90:	0f b6       	in	r0, 0x3f	; 63
    6c92:	0f 92       	push	r0
    6c94:	11 24       	eor	r1, r1
    6c96:	2f 93       	push	r18
    6c98:	3f 93       	push	r19
    6c9a:	4f 93       	push	r20
    6c9c:	5f 93       	push	r21
    6c9e:	6f 93       	push	r22
    6ca0:	7f 93       	push	r23
    6ca2:	8f 93       	push	r24
    6ca4:	9f 93       	push	r25
    6ca6:	af 93       	push	r26
    6ca8:	bf 93       	push	r27
    6caa:	ef 93       	push	r30
    6cac:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    6cae:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_ALL_CONTROL_PINS
    pin ^= CONTROL_INVERT_MASK;
    6cb0:	80 95       	com	r24
    6cb2:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    6cb4:	a9 f0       	breq	.+42     	; 0x6ce0 <__vector_4+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    6cb6:	80 ff       	sbrs	r24, 0
    6cb8:	03 c0       	rjmp	.+6      	; 0x6cc0 <__vector_4+0x34>
      mc_reset();
    6cba:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
    6cbe:	10 c0       	rjmp	.+32     	; 0x6ce0 <__vector_4+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    6cc0:	98 2f       	mov	r25, r24
    6cc2:	94 70       	andi	r25, 0x04	; 4
    6cc4:	31 f0       	breq	.+12     	; 0x6cd2 <__vector_4+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    6cc6:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    6cca:	82 60       	ori	r24, 0x02	; 2
    6ccc:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
    6cd0:	07 c0       	rjmp	.+14     	; 0x6ce0 <__vector_4+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    6cd2:	81 ff       	sbrs	r24, 1
    6cd4:	05 c0       	rjmp	.+10     	; 0x6ce0 <__vector_4+0x54>
        bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    6cd6:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <sys_rt_exec_state>
    6cda:	88 60       	ori	r24, 0x08	; 8
    6cdc:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <sys_rt_exec_state>
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    6ce0:	ff 91       	pop	r31
    6ce2:	ef 91       	pop	r30
    6ce4:	bf 91       	pop	r27
    6ce6:	af 91       	pop	r26
    6ce8:	9f 91       	pop	r25
    6cea:	8f 91       	pop	r24
    6cec:	7f 91       	pop	r23
    6cee:	6f 91       	pop	r22
    6cf0:	5f 91       	pop	r21
    6cf2:	4f 91       	pop	r20
    6cf4:	3f 91       	pop	r19
    6cf6:	2f 91       	pop	r18
    6cf8:	0f 90       	pop	r0
    6cfa:	0f be       	out	0x3f, r0	; 63
    6cfc:	0f 90       	pop	r0
    6cfe:	1f 90       	pop	r1
    6d00:	18 95       	reti

00006d02 <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    6d02:	80 e0       	ldi	r24, 0x00	; 0
    6d04:	08 95       	ret

00006d06 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    6d06:	0f 93       	push	r16
    6d08:	1f 93       	push	r17
    6d0a:	cf 93       	push	r28
    6d0c:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6d0e:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    6d10:	b8 01       	movw	r22, r16
    6d12:	8c 2f       	mov	r24, r28
    6d14:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <settings_read_startup_line>
    6d18:	81 11       	cpse	r24, r1
    6d1a:	04 c0       	rjmp	.+8      	; 0x6d24 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    6d1c:	87 e0       	ldi	r24, 0x07	; 7
    6d1e:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
    6d22:	0c c0       	rjmp	.+24     	; 0x6d3c <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    6d24:	f8 01       	movw	r30, r16
    6d26:	80 81       	ld	r24, Z
    6d28:	88 23       	and	r24, r24
    6d2a:	41 f0       	breq	.+16     	; 0x6d3c <system_execute_startup+0x36>
        printString(line); // Echo startup line to indicate execution.
    6d2c:	c8 01       	movw	r24, r16
    6d2e:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <printString>
        report_status_message(gc_execute_line(line));
    6d32:	c8 01       	movw	r24, r16
    6d34:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    6d38:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6d3c:	cf 5f       	subi	r28, 0xFF	; 255
    6d3e:	c2 30       	cpi	r28, 0x02	; 2
    6d40:	39 f7       	brne	.-50     	; 0x6d10 <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    6d42:	cf 91       	pop	r28
    6d44:	1f 91       	pop	r17
    6d46:	0f 91       	pop	r16
    6d48:	08 95       	ret

00006d4a <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    6d4a:	8f 92       	push	r8
    6d4c:	9f 92       	push	r9
    6d4e:	af 92       	push	r10
    6d50:	bf 92       	push	r11
    6d52:	cf 92       	push	r12
    6d54:	df 92       	push	r13
    6d56:	ef 92       	push	r14
    6d58:	ff 92       	push	r15
    6d5a:	0f 93       	push	r16
    6d5c:	1f 93       	push	r17
    6d5e:	cf 93       	push	r28
    6d60:	df 93       	push	r29
    6d62:	cd b7       	in	r28, 0x3d	; 61
    6d64:	de b7       	in	r29, 0x3e	; 62
    6d66:	29 97       	sbiw	r28, 0x09	; 9
    6d68:	0f b6       	in	r0, 0x3f	; 63
    6d6a:	f8 94       	cli
    6d6c:	de bf       	out	0x3e, r29	; 62
    6d6e:	0f be       	out	0x3f, r0	; 63
    6d70:	cd bf       	out	0x3d, r28	; 61
    6d72:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1; 
    6d74:	81 e0       	ldi	r24, 0x01	; 1
    6d76:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    6d78:	f8 01       	movw	r30, r16
    6d7a:	81 81       	ldd	r24, Z+1	; 0x01
    6d7c:	83 34       	cpi	r24, 0x43	; 67
    6d7e:	89 f0       	breq	.+34     	; 0x6da2 <system_execute_line+0x58>
    6d80:	30 f4       	brcc	.+12     	; 0x6d8e <system_execute_line+0x44>
    6d82:	88 23       	and	r24, r24
    6d84:	51 f0       	breq	.+20     	; 0x6d9a <system_execute_line+0x50>
    6d86:	84 32       	cpi	r24, 0x24	; 36
    6d88:	09 f0       	breq	.+2      	; 0x6d8c <system_execute_line+0x42>
    6d8a:	48 c0       	rjmp	.+144    	; 0x6e1c <system_execute_line+0xd2>
    6d8c:	0a c0       	rjmp	.+20     	; 0x6da2 <system_execute_line+0x58>
    6d8e:	87 34       	cpi	r24, 0x47	; 71
    6d90:	41 f0       	breq	.+16     	; 0x6da2 <system_execute_line+0x58>
    6d92:	88 35       	cpi	r24, 0x58	; 88
    6d94:	09 f0       	breq	.+2      	; 0x6d98 <system_execute_line+0x4e>
    6d96:	42 c0       	rjmp	.+132    	; 0x6e1c <system_execute_line+0xd2>
    6d98:	04 c0       	rjmp	.+8      	; 0x6da2 <system_execute_line+0x58>
    case 0 : report_grbl_help(); break;
    6d9a:	0e 94 2a 23 	call	0x4654	; 0x4654 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6d9e:	f1 2c       	mov	r15, r1
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    6da0:	b0 c1       	rjmp	.+864    	; 0x7102 <system_execute_line+0x3b8>
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6da2:	f8 01       	movw	r30, r16
    6da4:	92 81       	ldd	r25, Z+2	; 0x02
    6da6:	91 11       	cpse	r25, r1
    6da8:	53 c1       	rjmp	.+678    	; 0x7050 <system_execute_line+0x306>
      switch( line[char_counter] ) {
    6daa:	83 34       	cpi	r24, 0x43	; 67
    6dac:	b1 f0       	breq	.+44     	; 0x6dda <system_execute_line+0x90>
    6dae:	18 f4       	brcc	.+6      	; 0x6db6 <system_execute_line+0x6c>
    6db0:	84 32       	cpi	r24, 0x24	; 36
    6db2:	31 f0       	breq	.+12     	; 0x6dc0 <system_execute_line+0x76>
    6db4:	52 c1       	rjmp	.+676    	; 0x705a <system_execute_line+0x310>
    6db6:	87 34       	cpi	r24, 0x47	; 71
    6db8:	61 f0       	breq	.+24     	; 0x6dd2 <system_execute_line+0x88>
    6dba:	88 35       	cpi	r24, 0x58	; 88
    6dbc:	19 f1       	breq	.+70     	; 0x6e04 <system_execute_line+0xba>
    6dbe:	4d c1       	rjmp	.+666    	; 0x705a <system_execute_line+0x310>
    6dc0:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    6dc4:	88 71       	andi	r24, 0x18	; 24
    6dc6:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    6dc8:	09 f0       	breq	.+2      	; 0x6dcc <system_execute_line+0x82>
    6dca:	49 c1       	rjmp	.+658    	; 0x705e <system_execute_line+0x314>
          else { report_grbl_settings(); }
    6dcc:	0e 94 2f 23 	call	0x465e	; 0x465e <report_grbl_settings>
          break;
    6dd0:	98 c1       	rjmp	.+816    	; 0x7102 <system_execute_line+0x3b8>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    6dd2:	0e 94 04 26 	call	0x4c08	; 0x4c08 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dd6:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;   
    6dd8:	94 c1       	rjmp	.+808    	; 0x7102 <system_execute_line+0x3b8>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
    6dda:	f0 90 a7 05 	lds	r15, 0x05A7	; 0x8005a7 <sys+0x1>
    6dde:	f2 e0       	ldi	r31, 0x02	; 2
    6de0:	ff 12       	cpse	r15, r31
    6de2:	07 c0       	rjmp	.+14     	; 0x6df2 <system_execute_line+0xa8>
            mc_reset(); 
    6de4:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    6de8:	85 e0       	ldi	r24, 0x05	; 5
    6dea:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dee:	f1 2c       	mov	r15, r1
    6df0:	88 c1       	rjmp	.+784    	; 0x7102 <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    6df2:	f1 10       	cpse	r15, r1
    6df4:	38 c1       	rjmp	.+624    	; 0x7066 <system_execute_line+0x31c>
            sys.state = STATE_CHECK_MODE;
    6df6:	82 e0       	ldi	r24, 0x02	; 2
    6df8:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <sys+0x1>
            report_feedback_message(MESSAGE_ENABLED);
    6dfc:	84 e0       	ldi	r24, 0x04	; 4
    6dfe:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
    6e02:	7f c1       	rjmp	.+766    	; 0x7102 <system_execute_line+0x3b8>
          }
          break; 
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) { 
    6e04:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <sys+0x1>
    6e08:	81 30       	cpi	r24, 0x01	; 1
    6e0a:	09 f0       	breq	.+2      	; 0x6e0e <system_execute_line+0xc4>
    6e0c:	30 c1       	rjmp	.+608    	; 0x706e <system_execute_line+0x324>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    6e0e:	83 e0       	ldi	r24, 0x03	; 3
    6e10:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
            sys.state = STATE_IDLE;
    6e14:	10 92 a7 05 	sts	0x05A7, r1	; 0x8005a7 <sys+0x1>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e18:	f1 2c       	mov	r15, r1
    6e1a:	73 c1       	rjmp	.+742    	; 0x7102 <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    6e1c:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <sys+0x1>
    6e20:	92 30       	cpi	r25, 0x02	; 2
    6e22:	08 f0       	brcs	.+2      	; 0x6e26 <system_execute_line+0xdc>
    6e24:	26 c1       	rjmp	.+588    	; 0x7072 <system_execute_line+0x328>
      switch( line[char_counter] ) {
    6e26:	89 34       	cpi	r24, 0x49	; 73
    6e28:	91 f1       	breq	.+100    	; 0x6e8e <system_execute_line+0x144>
    6e2a:	28 f4       	brcc	.+10     	; 0x6e36 <system_execute_line+0xec>
    6e2c:	83 32       	cpi	r24, 0x23	; 35
    6e2e:	51 f0       	breq	.+20     	; 0x6e44 <system_execute_line+0xfa>
    6e30:	88 34       	cpi	r24, 0x48	; 72
    6e32:	91 f0       	breq	.+36     	; 0x6e58 <system_execute_line+0x10e>
    6e34:	9c c0       	rjmp	.+312    	; 0x6f6e <system_execute_line+0x224>
    6e36:	8e 34       	cpi	r24, 0x4E	; 78
    6e38:	09 f4       	brne	.+2      	; 0x6e3c <system_execute_line+0xf2>
    6e3a:	79 c0       	rjmp	.+242    	; 0x6f2e <system_execute_line+0x1e4>
    6e3c:	82 35       	cpi	r24, 0x52	; 82
    6e3e:	09 f4       	brne	.+2      	; 0x6e42 <system_execute_line+0xf8>
    6e40:	49 c0       	rjmp	.+146    	; 0x6ed4 <system_execute_line+0x18a>
    6e42:	95 c0       	rjmp	.+298    	; 0x6f6e <system_execute_line+0x224>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6e44:	82 e0       	ldi	r24, 0x02	; 2
    6e46:	89 83       	std	Y+1, r24	; 0x01
    6e48:	f8 01       	movw	r30, r16
    6e4a:	82 81       	ldd	r24, Z+2	; 0x02
    6e4c:	81 11       	cpse	r24, r1
    6e4e:	15 c1       	rjmp	.+554    	; 0x707a <system_execute_line+0x330>
          else { report_ngc_parameters(); }
    6e50:	0e 94 6e 25 	call	0x4adc	; 0x4adc <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e54:	f1 2c       	mov	r15, r1
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    6e56:	55 c1       	rjmp	.+682    	; 0x7102 <system_execute_line+0x3b8>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    6e58:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x3d>
    6e5c:	84 ff       	sbrs	r24, 4
    6e5e:	12 c1       	rjmp	.+548    	; 0x7084 <system_execute_line+0x33a>
            sys.state = STATE_HOMING; // Set system state variable
    6e60:	0f 2e       	mov	r0, r31
    6e62:	f6 ea       	ldi	r31, 0xA6	; 166
    6e64:	ef 2e       	mov	r14, r31
    6e66:	f5 e0       	ldi	r31, 0x05	; 5
    6e68:	ff 2e       	mov	r15, r31
    6e6a:	f0 2d       	mov	r31, r0
    6e6c:	84 e0       	ldi	r24, 0x04	; 4
    6e6e:	f7 01       	movw	r30, r14
    6e70:	81 83       	std	Z+1, r24	; 0x01
              bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    6e72:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    6e76:	f7 01       	movw	r30, r14
    6e78:	f0 80       	ld	r15, Z
    6e7a:	f1 10       	cpse	r15, r1
    6e7c:	08 c1       	rjmp	.+528    	; 0x708e <system_execute_line+0x344>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    6e7e:	10 92 a7 05 	sts	0x05A7, r1	; 0x8005a7 <sys+0x1>
              st_go_idle(); // Set steppers to the settings idle state before returning.
    6e82:	0e 94 6e 2c 	call	0x58dc	; 0x58dc <st_go_idle>
              system_execute_startup(line); 
    6e86:	c8 01       	movw	r24, r16
    6e88:	0e 94 83 36 	call	0x6d06	; 0x6d06 <system_execute_startup>
    6e8c:	3a c1       	rjmp	.+628    	; 0x7102 <system_execute_line+0x3b8>
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    6e8e:	82 e0       	ldi	r24, 0x02	; 2
    6e90:	89 83       	std	Y+1, r24	; 0x01
    6e92:	f8 01       	movw	r30, r16
    6e94:	82 81       	ldd	r24, Z+2	; 0x02
    6e96:	81 11       	cpse	r24, r1
    6e98:	08 c0       	rjmp	.+16     	; 0x6eaa <system_execute_line+0x160>
            settings_read_build_info(line);
    6e9a:	c8 01       	movw	r24, r16
    6e9c:	0e 94 0d 2a 	call	0x541a	; 0x541a <settings_read_build_info>
            report_build_info(line);
    6ea0:	c8 01       	movw	r24, r16
    6ea2:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6ea6:	f1 2c       	mov	r15, r1
    6ea8:	2c c1       	rjmp	.+600    	; 0x7102 <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6eaa:	8d 33       	cpi	r24, 0x3D	; 61
    6eac:	09 f0       	breq	.+2      	; 0x6eb0 <system_execute_line+0x166>
    6eae:	f1 c0       	rjmp	.+482    	; 0x7092 <system_execute_line+0x348>
    6eb0:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    6eb2:	f8 01       	movw	r30, r16
    6eb4:	e8 0f       	add	r30, r24
    6eb6:	f1 1d       	adc	r31, r1
    6eb8:	90 81       	ld	r25, Z
    6eba:	df 01       	movw	r26, r30
    6ebc:	13 97       	sbiw	r26, 0x03	; 3
    6ebe:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    6ec0:	8f 5f       	subi	r24, 0xFF	; 255
    6ec2:	90 81       	ld	r25, Z
    6ec4:	91 11       	cpse	r25, r1
    6ec6:	f5 cf       	rjmp	.-22     	; 0x6eb2 <system_execute_line+0x168>
    6ec8:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    6eca:	c8 01       	movw	r24, r16
    6ecc:	0e 94 0c 29 	call	0x5218	; 0x5218 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6ed0:	f1 2c       	mov	r15, r1
    6ed2:	17 c1       	rjmp	.+558    	; 0x7102 <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    6ed4:	f8 01       	movw	r30, r16
    6ed6:	82 81       	ldd	r24, Z+2	; 0x02
    6ed8:	83 35       	cpi	r24, 0x53	; 83
    6eda:	09 f0       	breq	.+2      	; 0x6ede <system_execute_line+0x194>
    6edc:	df c0       	rjmp	.+446    	; 0x709c <system_execute_line+0x352>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    6ede:	83 81       	ldd	r24, Z+3	; 0x03
    6ee0:	84 35       	cpi	r24, 0x54	; 84
    6ee2:	09 f0       	breq	.+2      	; 0x6ee6 <system_execute_line+0x19c>
    6ee4:	e0 c0       	rjmp	.+448    	; 0x70a6 <system_execute_line+0x35c>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    6ee6:	84 81       	ldd	r24, Z+4	; 0x04
    6ee8:	8d 33       	cpi	r24, 0x3D	; 61
    6eea:	09 f0       	breq	.+2      	; 0x6eee <system_execute_line+0x1a4>
    6eec:	e1 c0       	rjmp	.+450    	; 0x70b0 <system_execute_line+0x366>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    6eee:	86 81       	ldd	r24, Z+6	; 0x06
    6ef0:	81 11       	cpse	r24, r1
    6ef2:	e3 c0       	rjmp	.+454    	; 0x70ba <system_execute_line+0x370>
          switch (line[++char_counter]) {
    6ef4:	85 e0       	ldi	r24, 0x05	; 5
    6ef6:	89 83       	std	Y+1, r24	; 0x01
    6ef8:	85 81       	ldd	r24, Z+5	; 0x05
    6efa:	84 32       	cpi	r24, 0x24	; 36
    6efc:	31 f0       	breq	.+12     	; 0x6f0a <system_execute_line+0x1c0>
    6efe:	8a 32       	cpi	r24, 0x2A	; 42
    6f00:	61 f0       	breq	.+24     	; 0x6f1a <system_execute_line+0x1d0>
    6f02:	83 32       	cpi	r24, 0x23	; 35
    6f04:	09 f0       	breq	.+2      	; 0x6f08 <system_execute_line+0x1be>
    6f06:	de c0       	rjmp	.+444    	; 0x70c4 <system_execute_line+0x37a>
    6f08:	04 c0       	rjmp	.+8      	; 0x6f12 <system_execute_line+0x1c8>
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    6f0a:	81 e0       	ldi	r24, 0x01	; 1
    6f0c:	0e 94 2c 29 	call	0x5258	; 0x5258 <settings_restore>
    6f10:	07 c0       	rjmp	.+14     	; 0x6f20 <system_execute_line+0x1d6>
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    6f12:	82 e0       	ldi	r24, 0x02	; 2
    6f14:	0e 94 2c 29 	call	0x5258	; 0x5258 <settings_restore>
    6f18:	03 c0       	rjmp	.+6      	; 0x6f20 <system_execute_line+0x1d6>
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    6f1a:	8f ef       	ldi	r24, 0xFF	; 255
    6f1c:	0e 94 2c 29 	call	0x5258	; 0x5258 <settings_restore>
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    6f20:	88 e0       	ldi	r24, 0x08	; 8
    6f22:	0e 94 e7 22 	call	0x45ce	; 0x45ce <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    6f26:	0e 94 3d 18 	call	0x307a	; 0x307a <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6f2a:	f1 2c       	mov	r15, r1
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    6f2c:	ea c0       	rjmp	.+468    	; 0x7102 <system_execute_line+0x3b8>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    6f2e:	82 e0       	ldi	r24, 0x02	; 2
    6f30:	89 83       	std	Y+1, r24	; 0x01
    6f32:	f8 01       	movw	r30, r16
    6f34:	82 81       	ldd	r24, Z+2	; 0x02
    6f36:	81 11       	cpse	r24, r1
    6f38:	15 c0       	rjmp	.+42     	; 0x6f64 <system_execute_line+0x21a>
    6f3a:	f1 2c       	mov	r15, r1
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    6f3c:	b8 01       	movw	r22, r16
    6f3e:	8f 2d       	mov	r24, r15
    6f40:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <settings_read_startup_line>
    6f44:	81 11       	cpse	r24, r1
    6f46:	04 c0       	rjmp	.+8      	; 0x6f50 <system_execute_line+0x206>
                report_status_message(STATUS_SETTING_READ_FAIL);
    6f48:	87 e0       	ldi	r24, 0x07	; 7
    6f4a:	0e 94 46 22 	call	0x448c	; 0x448c <report_status_message>
    6f4e:	04 c0       	rjmp	.+8      	; 0x6f58 <system_execute_line+0x20e>
              } else {
                report_startup_line(helper_var,line);
    6f50:	b8 01       	movw	r22, r16
    6f52:	8f 2d       	mov	r24, r15
    6f54:	0e 94 e1 26 	call	0x4dc2	; 0x4dc2 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    6f58:	f3 94       	inc	r15
    6f5a:	f2 e0       	ldi	r31, 0x02	; 2
    6f5c:	ff 12       	cpse	r15, r31
    6f5e:	ee cf       	rjmp	.-36     	; 0x6f3c <system_execute_line+0x1f2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6f60:	f1 2c       	mov	r15, r1
    6f62:	cf c0       	rjmp	.+414    	; 0x7102 <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    6f64:	91 11       	cpse	r25, r1
    6f66:	b3 c0       	rjmp	.+358    	; 0x70ce <system_execute_line+0x384>
            helper_var = true;  // Set helper_var to flag storing method. 
    6f68:	ff 24       	eor	r15, r15
    6f6a:	f3 94       	inc	r15
    6f6c:	01 c0       	rjmp	.+2      	; 0x6f70 <system_execute_line+0x226>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    6f6e:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6f70:	ae 01       	movw	r20, r28
    6f72:	4e 5f       	subi	r20, 0xFE	; 254
    6f74:	5f 4f       	sbci	r21, 0xFF	; 255
    6f76:	be 01       	movw	r22, r28
    6f78:	6f 5f       	subi	r22, 0xFF	; 255
    6f7a:	7f 4f       	sbci	r23, 0xFF	; 255
    6f7c:	c8 01       	movw	r24, r16
    6f7e:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <read_float>
    6f82:	88 23       	and	r24, r24
    6f84:	09 f4       	brne	.+2      	; 0x6f88 <system_execute_line+0x23e>
    6f86:	a7 c0       	rjmp	.+334    	; 0x70d6 <system_execute_line+0x38c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6f88:	89 81       	ldd	r24, Y+1	; 0x01
    6f8a:	41 e0       	ldi	r20, 0x01	; 1
    6f8c:	48 0f       	add	r20, r24
    6f8e:	49 83       	std	Y+1, r20	; 0x01
    6f90:	f8 01       	movw	r30, r16
    6f92:	e8 0f       	add	r30, r24
    6f94:	f1 1d       	adc	r31, r1
    6f96:	80 81       	ld	r24, Z
    6f98:	8d 33       	cpi	r24, 0x3D	; 61
    6f9a:	09 f0       	breq	.+2      	; 0x6f9e <system_execute_line+0x254>
    6f9c:	a0 c0       	rjmp	.+320    	; 0x70de <system_execute_line+0x394>
          if (helper_var) { // Store startup line
    6f9e:	ff 20       	and	r15, r15
    6fa0:	31 f1       	breq	.+76     	; 0x6fee <system_execute_line+0x2a4>
    6fa2:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    6fa4:	50 e0       	ldi	r21, 0x00	; 0
    6fa6:	82 2f       	mov	r24, r18
    6fa8:	90 e0       	ldi	r25, 0x00	; 0
    6faa:	d8 01       	movw	r26, r16
    6fac:	a8 0f       	add	r26, r24
    6fae:	b9 1f       	adc	r27, r25
    6fb0:	3c 91       	ld	r19, X
    6fb2:	84 1b       	sub	r24, r20
    6fb4:	95 0b       	sbc	r25, r21
    6fb6:	f8 01       	movw	r30, r16
    6fb8:	e8 0f       	add	r30, r24
    6fba:	f9 1f       	adc	r31, r25
    6fbc:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    6fbe:	2f 5f       	subi	r18, 0xFF	; 255
    6fc0:	8c 91       	ld	r24, X
    6fc2:	81 11       	cpse	r24, r1
    6fc4:	f0 cf       	rjmp	.-32     	; 0x6fa6 <system_execute_line+0x25c>
    6fc6:	29 83       	std	Y+1, r18	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    6fc8:	c8 01       	movw	r24, r16
    6fca:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    6fce:	f8 2e       	mov	r15, r24
            if (helper_var) { return(helper_var); }
    6fd0:	81 11       	cpse	r24, r1
    6fd2:	97 c0       	rjmp	.+302    	; 0x7102 <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    6fd4:	6a 81       	ldd	r22, Y+2	; 0x02
    6fd6:	7b 81       	ldd	r23, Y+3	; 0x03
    6fd8:	8c 81       	ldd	r24, Y+4	; 0x04
    6fda:	9d 81       	ldd	r25, Y+5	; 0x05
    6fdc:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <trunc>
              settings_store_startup_line(helper_var,line);
    6fe0:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    6fe4:	86 2f       	mov	r24, r22
    6fe6:	b8 01       	movw	r22, r16
    6fe8:	0e 94 02 29 	call	0x5204	; 0x5204 <settings_store_startup_line>
    6fec:	8a c0       	rjmp	.+276    	; 0x7102 <system_execute_line+0x3b8>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6fee:	ae 01       	movw	r20, r28
    6ff0:	4a 5f       	subi	r20, 0xFA	; 250
    6ff2:	5f 4f       	sbci	r21, 0xFF	; 255
    6ff4:	be 01       	movw	r22, r28
    6ff6:	6f 5f       	subi	r22, 0xFF	; 255
    6ff8:	7f 4f       	sbci	r23, 0xFF	; 255
    6ffa:	c8 01       	movw	r24, r16
    6ffc:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <read_float>
    7000:	88 23       	and	r24, r24
    7002:	09 f4       	brne	.+2      	; 0x7006 <system_execute_line+0x2bc>
    7004:	71 c0       	rjmp	.+226    	; 0x70e8 <system_execute_line+0x39e>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7006:	89 81       	ldd	r24, Y+1	; 0x01
    7008:	f8 01       	movw	r30, r16
    700a:	e8 0f       	add	r30, r24
    700c:	f1 1d       	adc	r31, r1
    700e:	80 81       	ld	r24, Z
    7010:	81 11       	cpse	r24, r1
    7012:	6e c0       	rjmp	.+220    	; 0x70f0 <system_execute_line+0x3a6>
    7014:	ca 80       	ldd	r12, Y+2	; 0x02
    7016:	db 80       	ldd	r13, Y+3	; 0x03
    7018:	ec 80       	ldd	r14, Y+4	; 0x04
    701a:	fd 80       	ldd	r15, Y+5	; 0x05
    701c:	20 e0       	ldi	r18, 0x00	; 0
    701e:	30 e0       	ldi	r19, 0x00	; 0
    7020:	4f e7       	ldi	r20, 0x7F	; 127
    7022:	53 e4       	ldi	r21, 0x43	; 67
    7024:	c7 01       	movw	r24, r14
    7026:	b6 01       	movw	r22, r12
    7028:	0e 94 e4 3b 	call	0x77c8	; 0x77c8 <__gesf2>
    702c:	18 16       	cp	r1, r24
    702e:	0c f4       	brge	.+2      	; 0x7032 <system_execute_line+0x2e8>
    7030:	64 c0       	rjmp	.+200    	; 0x70fa <system_execute_line+0x3b0>
            return(settings_store_global_setting((uint8_t)parameter, value));
    7032:	8e 80       	ldd	r8, Y+6	; 0x06
    7034:	9f 80       	ldd	r9, Y+7	; 0x07
    7036:	a8 84       	ldd	r10, Y+8	; 0x08
    7038:	b9 84       	ldd	r11, Y+9	; 0x09
    703a:	c7 01       	movw	r24, r14
    703c:	b6 01       	movw	r22, r12
    703e:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    7042:	86 2f       	mov	r24, r22
    7044:	b5 01       	movw	r22, r10
    7046:	a4 01       	movw	r20, r8
    7048:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <settings_store_global_setting>
    704c:	f8 2e       	mov	r15, r24
    704e:	59 c0       	rjmp	.+178    	; 0x7102 <system_execute_line+0x3b8>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7050:	0f 2e       	mov	r0, r31
    7052:	f3 e0       	ldi	r31, 0x03	; 3
    7054:	ff 2e       	mov	r15, r31
    7056:	f0 2d       	mov	r31, r0
    7058:	54 c0       	rjmp	.+168    	; 0x7102 <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    705a:	f1 2c       	mov	r15, r1
    705c:	52 c0       	rjmp	.+164    	; 0x7102 <system_execute_line+0x3b8>
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    705e:	68 94       	set
    7060:	ff 24       	eor	r15, r15
    7062:	f3 f8       	bld	r15, 3
    7064:	4e c0       	rjmp	.+156    	; 0x7102 <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7066:	68 94       	set
    7068:	ff 24       	eor	r15, r15
    706a:	f3 f8       	bld	r15, 3
    706c:	4a c0       	rjmp	.+148    	; 0x7102 <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    706e:	f1 2c       	mov	r15, r1
    7070:	48 c0       	rjmp	.+144    	; 0x7102 <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7072:	68 94       	set
    7074:	ff 24       	eor	r15, r15
    7076:	f3 f8       	bld	r15, 3
    7078:	44 c0       	rjmp	.+136    	; 0x7102 <system_execute_line+0x3b8>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    707a:	0f 2e       	mov	r0, r31
    707c:	f3 e0       	ldi	r31, 0x03	; 3
    707e:	ff 2e       	mov	r15, r31
    7080:	f0 2d       	mov	r31, r0
    7082:	3f c0       	rjmp	.+126    	; 0x7102 <system_execute_line+0x3b8>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    7084:	0f 2e       	mov	r0, r31
    7086:	f5 e0       	ldi	r31, 0x05	; 5
    7088:	ff 2e       	mov	r15, r31
    708a:	f0 2d       	mov	r31, r0
    708c:	3a c0       	rjmp	.+116    	; 0x7102 <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    708e:	f1 2c       	mov	r15, r1
    7090:	38 c0       	rjmp	.+112    	; 0x7102 <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7092:	0f 2e       	mov	r0, r31
    7094:	f3 e0       	ldi	r31, 0x03	; 3
    7096:	ff 2e       	mov	r15, r31
    7098:	f0 2d       	mov	r31, r0
    709a:	33 c0       	rjmp	.+102    	; 0x7102 <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    709c:	0f 2e       	mov	r0, r31
    709e:	f3 e0       	ldi	r31, 0x03	; 3
    70a0:	ff 2e       	mov	r15, r31
    70a2:	f0 2d       	mov	r31, r0
    70a4:	2e c0       	rjmp	.+92     	; 0x7102 <system_execute_line+0x3b8>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    70a6:	0f 2e       	mov	r0, r31
    70a8:	f3 e0       	ldi	r31, 0x03	; 3
    70aa:	ff 2e       	mov	r15, r31
    70ac:	f0 2d       	mov	r31, r0
    70ae:	29 c0       	rjmp	.+82     	; 0x7102 <system_execute_line+0x3b8>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    70b0:	0f 2e       	mov	r0, r31
    70b2:	f3 e0       	ldi	r31, 0x03	; 3
    70b4:	ff 2e       	mov	r15, r31
    70b6:	f0 2d       	mov	r31, r0
    70b8:	24 c0       	rjmp	.+72     	; 0x7102 <system_execute_line+0x3b8>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    70ba:	0f 2e       	mov	r0, r31
    70bc:	f3 e0       	ldi	r31, 0x03	; 3
    70be:	ff 2e       	mov	r15, r31
    70c0:	f0 2d       	mov	r31, r0
    70c2:	1f c0       	rjmp	.+62     	; 0x7102 <system_execute_line+0x3b8>
          switch (line[++char_counter]) {
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
    70c4:	0f 2e       	mov	r0, r31
    70c6:	f3 e0       	ldi	r31, 0x03	; 3
    70c8:	ff 2e       	mov	r15, r31
    70ca:	f0 2d       	mov	r31, r0
    70cc:	1a c0       	rjmp	.+52     	; 0x7102 <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    70ce:	68 94       	set
    70d0:	ff 24       	eor	r15, r15
    70d2:	f3 f8       	bld	r15, 3
    70d4:	16 c0       	rjmp	.+44     	; 0x7102 <system_execute_line+0x3b8>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    70d6:	68 94       	set
    70d8:	ff 24       	eor	r15, r15
    70da:	f1 f8       	bld	r15, 1
    70dc:	12 c0       	rjmp	.+36     	; 0x7102 <system_execute_line+0x3b8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    70de:	0f 2e       	mov	r0, r31
    70e0:	f3 e0       	ldi	r31, 0x03	; 3
    70e2:	ff 2e       	mov	r15, r31
    70e4:	f0 2d       	mov	r31, r0
    70e6:	0d c0       	rjmp	.+26     	; 0x7102 <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    70e8:	68 94       	set
    70ea:	ff 24       	eor	r15, r15
    70ec:	f1 f8       	bld	r15, 1
    70ee:	09 c0       	rjmp	.+18     	; 0x7102 <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    70f0:	0f 2e       	mov	r0, r31
    70f2:	f3 e0       	ldi	r31, 0x03	; 3
    70f4:	ff 2e       	mov	r15, r31
    70f6:	f0 2d       	mov	r31, r0
    70f8:	04 c0       	rjmp	.+8      	; 0x7102 <system_execute_line+0x3b8>
    70fa:	0f 2e       	mov	r0, r31
    70fc:	f3 e0       	ldi	r31, 0x03	; 3
    70fe:	ff 2e       	mov	r15, r31
    7100:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7102:	8f 2d       	mov	r24, r15
    7104:	29 96       	adiw	r28, 0x09	; 9
    7106:	0f b6       	in	r0, 0x3f	; 63
    7108:	f8 94       	cli
    710a:	de bf       	out	0x3e, r29	; 62
    710c:	0f be       	out	0x3f, r0	; 63
    710e:	cd bf       	out	0x3d, r28	; 61
    7110:	df 91       	pop	r29
    7112:	cf 91       	pop	r28
    7114:	1f 91       	pop	r17
    7116:	0f 91       	pop	r16
    7118:	ff 90       	pop	r15
    711a:	ef 90       	pop	r14
    711c:	df 90       	pop	r13
    711e:	cf 90       	pop	r12
    7120:	bf 90       	pop	r11
    7122:	af 90       	pop	r10
    7124:	9f 90       	pop	r9
    7126:	8f 90       	pop	r8
    7128:	08 95       	ret

0000712a <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    712a:	cf 93       	push	r28
    712c:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    712e:	c6 2f       	mov	r28, r22
    7130:	d0 e0       	ldi	r29, 0x00	; 0
    7132:	cc 0f       	add	r28, r28
    7134:	dd 1f       	adc	r29, r29
    7136:	cc 0f       	add	r28, r28
    7138:	dd 1f       	adc	r29, r29
    713a:	8c 0f       	add	r24, r28
    713c:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    713e:	fc 01       	movw	r30, r24
    7140:	60 81       	ld	r22, Z
    7142:	71 81       	ldd	r23, Z+1	; 0x01
    7144:	82 81       	ldd	r24, Z+2	; 0x02
    7146:	93 81       	ldd	r25, Z+3	; 0x03
    7148:	0e 94 76 3a 	call	0x74ec	; 0x74ec <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    714c:	cb 57       	subi	r28, 0x7B	; 123
    714e:	d9 4f       	sbci	r29, 0xF9	; 249
  #endif
  return(pos);
    7150:	28 81       	ld	r18, Y
    7152:	39 81       	ldd	r19, Y+1	; 0x01
    7154:	4a 81       	ldd	r20, Y+2	; 0x02
    7156:	5b 81       	ldd	r21, Y+3	; 0x03
    7158:	0e 94 cc 39 	call	0x7398	; 0x7398 <__divsf3>
}
    715c:	df 91       	pop	r29
    715e:	cf 91       	pop	r28
    7160:	08 95       	ret

00007162 <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    7162:	ef 92       	push	r14
    7164:	ff 92       	push	r15
    7166:	0f 93       	push	r16
    7168:	1f 93       	push	r17
    716a:	cf 93       	push	r28
    716c:	7b 01       	movw	r14, r22
    716e:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7170:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    7172:	6c 2f       	mov	r22, r28
    7174:	c7 01       	movw	r24, r14
    7176:	0e 94 95 38 	call	0x712a	; 0x712a <system_convert_axis_steps_to_mpos>
    717a:	f8 01       	movw	r30, r16
    717c:	61 93       	st	Z+, r22
    717e:	71 93       	st	Z+, r23
    7180:	81 93       	st	Z+, r24
    7182:	91 93       	st	Z+, r25
    7184:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7186:	cf 5f       	subi	r28, 0xFF	; 255
    7188:	c3 30       	cpi	r28, 0x03	; 3
    718a:	99 f7       	brne	.-26     	; 0x7172 <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    718c:	cf 91       	pop	r28
    718e:	1f 91       	pop	r17
    7190:	0f 91       	pop	r16
    7192:	ff 90       	pop	r15
    7194:	ef 90       	pop	r14
    7196:	08 95       	ret

00007198 <__subsf3>:
    7198:	50 58       	subi	r21, 0x80	; 128

0000719a <__addsf3>:
    719a:	bb 27       	eor	r27, r27
    719c:	aa 27       	eor	r26, r26
    719e:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <__addsf3x>
    71a2:	0c 94 7e 3b 	jmp	0x76fc	; 0x76fc <__fp_round>
    71a6:	0e 94 45 3b 	call	0x768a	; 0x768a <__fp_pscA>
    71aa:	38 f0       	brcs	.+14     	; 0x71ba <__addsf3+0x20>
    71ac:	0e 94 4c 3b 	call	0x7698	; 0x7698 <__fp_pscB>
    71b0:	20 f0       	brcs	.+8      	; 0x71ba <__addsf3+0x20>
    71b2:	39 f4       	brne	.+14     	; 0x71c2 <__addsf3+0x28>
    71b4:	9f 3f       	cpi	r25, 0xFF	; 255
    71b6:	19 f4       	brne	.+6      	; 0x71be <__addsf3+0x24>
    71b8:	26 f4       	brtc	.+8      	; 0x71c2 <__addsf3+0x28>
    71ba:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>
    71be:	0e f4       	brtc	.+2      	; 0x71c2 <__addsf3+0x28>
    71c0:	e0 95       	com	r30
    71c2:	e7 fb       	bst	r30, 7
    71c4:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_inf>

000071c8 <__addsf3x>:
    71c8:	e9 2f       	mov	r30, r25
    71ca:	0e 94 a3 3b 	call	0x7746	; 0x7746 <__fp_split3>
    71ce:	58 f3       	brcs	.-42     	; 0x71a6 <__addsf3+0xc>
    71d0:	ba 17       	cp	r27, r26
    71d2:	62 07       	cpc	r22, r18
    71d4:	73 07       	cpc	r23, r19
    71d6:	84 07       	cpc	r24, r20
    71d8:	95 07       	cpc	r25, r21
    71da:	20 f0       	brcs	.+8      	; 0x71e4 <__addsf3x+0x1c>
    71dc:	79 f4       	brne	.+30     	; 0x71fc <__addsf3x+0x34>
    71de:	a6 f5       	brtc	.+104    	; 0x7248 <__addsf3x+0x80>
    71e0:	0c 94 dd 3b 	jmp	0x77ba	; 0x77ba <__fp_zero>
    71e4:	0e f4       	brtc	.+2      	; 0x71e8 <__addsf3x+0x20>
    71e6:	e0 95       	com	r30
    71e8:	0b 2e       	mov	r0, r27
    71ea:	ba 2f       	mov	r27, r26
    71ec:	a0 2d       	mov	r26, r0
    71ee:	0b 01       	movw	r0, r22
    71f0:	b9 01       	movw	r22, r18
    71f2:	90 01       	movw	r18, r0
    71f4:	0c 01       	movw	r0, r24
    71f6:	ca 01       	movw	r24, r20
    71f8:	a0 01       	movw	r20, r0
    71fa:	11 24       	eor	r1, r1
    71fc:	ff 27       	eor	r31, r31
    71fe:	59 1b       	sub	r21, r25
    7200:	99 f0       	breq	.+38     	; 0x7228 <__addsf3x+0x60>
    7202:	59 3f       	cpi	r21, 0xF9	; 249
    7204:	50 f4       	brcc	.+20     	; 0x721a <__addsf3x+0x52>
    7206:	50 3e       	cpi	r21, 0xE0	; 224
    7208:	68 f1       	brcs	.+90     	; 0x7264 <__addsf3x+0x9c>
    720a:	1a 16       	cp	r1, r26
    720c:	f0 40       	sbci	r31, 0x00	; 0
    720e:	a2 2f       	mov	r26, r18
    7210:	23 2f       	mov	r18, r19
    7212:	34 2f       	mov	r19, r20
    7214:	44 27       	eor	r20, r20
    7216:	58 5f       	subi	r21, 0xF8	; 248
    7218:	f3 cf       	rjmp	.-26     	; 0x7200 <__addsf3x+0x38>
    721a:	46 95       	lsr	r20
    721c:	37 95       	ror	r19
    721e:	27 95       	ror	r18
    7220:	a7 95       	ror	r26
    7222:	f0 40       	sbci	r31, 0x00	; 0
    7224:	53 95       	inc	r21
    7226:	c9 f7       	brne	.-14     	; 0x721a <__addsf3x+0x52>
    7228:	7e f4       	brtc	.+30     	; 0x7248 <__addsf3x+0x80>
    722a:	1f 16       	cp	r1, r31
    722c:	ba 0b       	sbc	r27, r26
    722e:	62 0b       	sbc	r22, r18
    7230:	73 0b       	sbc	r23, r19
    7232:	84 0b       	sbc	r24, r20
    7234:	ba f0       	brmi	.+46     	; 0x7264 <__addsf3x+0x9c>
    7236:	91 50       	subi	r25, 0x01	; 1
    7238:	a1 f0       	breq	.+40     	; 0x7262 <__addsf3x+0x9a>
    723a:	ff 0f       	add	r31, r31
    723c:	bb 1f       	adc	r27, r27
    723e:	66 1f       	adc	r22, r22
    7240:	77 1f       	adc	r23, r23
    7242:	88 1f       	adc	r24, r24
    7244:	c2 f7       	brpl	.-16     	; 0x7236 <__addsf3x+0x6e>
    7246:	0e c0       	rjmp	.+28     	; 0x7264 <__addsf3x+0x9c>
    7248:	ba 0f       	add	r27, r26
    724a:	62 1f       	adc	r22, r18
    724c:	73 1f       	adc	r23, r19
    724e:	84 1f       	adc	r24, r20
    7250:	48 f4       	brcc	.+18     	; 0x7264 <__addsf3x+0x9c>
    7252:	87 95       	ror	r24
    7254:	77 95       	ror	r23
    7256:	67 95       	ror	r22
    7258:	b7 95       	ror	r27
    725a:	f7 95       	ror	r31
    725c:	9e 3f       	cpi	r25, 0xFE	; 254
    725e:	08 f0       	brcs	.+2      	; 0x7262 <__addsf3x+0x9a>
    7260:	b0 cf       	rjmp	.-160    	; 0x71c2 <__addsf3+0x28>
    7262:	93 95       	inc	r25
    7264:	88 0f       	add	r24, r24
    7266:	08 f0       	brcs	.+2      	; 0x726a <__addsf3x+0xa2>
    7268:	99 27       	eor	r25, r25
    726a:	ee 0f       	add	r30, r30
    726c:	97 95       	ror	r25
    726e:	87 95       	ror	r24
    7270:	08 95       	ret
    7272:	0e 94 45 3b 	call	0x768a	; 0x768a <__fp_pscA>
    7276:	60 f0       	brcs	.+24     	; 0x7290 <__addsf3x+0xc8>
    7278:	80 e8       	ldi	r24, 0x80	; 128
    727a:	91 e0       	ldi	r25, 0x01	; 1
    727c:	09 f4       	brne	.+2      	; 0x7280 <__addsf3x+0xb8>
    727e:	9e ef       	ldi	r25, 0xFE	; 254
    7280:	0e 94 4c 3b 	call	0x7698	; 0x7698 <__fp_pscB>
    7284:	28 f0       	brcs	.+10     	; 0x7290 <__addsf3x+0xc8>
    7286:	40 e8       	ldi	r20, 0x80	; 128
    7288:	51 e0       	ldi	r21, 0x01	; 1
    728a:	71 f4       	brne	.+28     	; 0x72a8 <atan2+0x10>
    728c:	5e ef       	ldi	r21, 0xFE	; 254
    728e:	0c c0       	rjmp	.+24     	; 0x72a8 <atan2+0x10>
    7290:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>
    7294:	0c 94 dd 3b 	jmp	0x77ba	; 0x77ba <__fp_zero>

00007298 <atan2>:
    7298:	e9 2f       	mov	r30, r25
    729a:	e0 78       	andi	r30, 0x80	; 128
    729c:	0e 94 a3 3b 	call	0x7746	; 0x7746 <__fp_split3>
    72a0:	40 f3       	brcs	.-48     	; 0x7272 <__addsf3x+0xaa>
    72a2:	09 2e       	mov	r0, r25
    72a4:	05 2a       	or	r0, r21
    72a6:	b1 f3       	breq	.-20     	; 0x7294 <__addsf3x+0xcc>
    72a8:	26 17       	cp	r18, r22
    72aa:	37 07       	cpc	r19, r23
    72ac:	48 07       	cpc	r20, r24
    72ae:	59 07       	cpc	r21, r25
    72b0:	38 f0       	brcs	.+14     	; 0x72c0 <atan2+0x28>
    72b2:	0e 2e       	mov	r0, r30
    72b4:	07 f8       	bld	r0, 7
    72b6:	e0 25       	eor	r30, r0
    72b8:	69 f0       	breq	.+26     	; 0x72d4 <atan2+0x3c>
    72ba:	e0 25       	eor	r30, r0
    72bc:	e0 64       	ori	r30, 0x40	; 64
    72be:	0a c0       	rjmp	.+20     	; 0x72d4 <atan2+0x3c>
    72c0:	ef 63       	ori	r30, 0x3F	; 63
    72c2:	07 f8       	bld	r0, 7
    72c4:	00 94       	com	r0
    72c6:	07 fa       	bst	r0, 7
    72c8:	db 01       	movw	r26, r22
    72ca:	b9 01       	movw	r22, r18
    72cc:	9d 01       	movw	r18, r26
    72ce:	dc 01       	movw	r26, r24
    72d0:	ca 01       	movw	r24, r20
    72d2:	ad 01       	movw	r20, r26
    72d4:	ef 93       	push	r30
    72d6:	0e 94 e3 39 	call	0x73c6	; 0x73c6 <__divsf3_pse>
    72da:	0e 94 7e 3b 	call	0x76fc	; 0x76fc <__fp_round>
    72de:	0e 94 7c 39 	call	0x72f8	; 0x72f8 <atan>
    72e2:	5f 91       	pop	r21
    72e4:	55 23       	and	r21, r21
    72e6:	39 f0       	breq	.+14     	; 0x72f6 <atan2+0x5e>
    72e8:	2b ed       	ldi	r18, 0xDB	; 219
    72ea:	3f e0       	ldi	r19, 0x0F	; 15
    72ec:	49 e4       	ldi	r20, 0x49	; 73
    72ee:	50 fd       	sbrc	r21, 0
    72f0:	49 ec       	ldi	r20, 0xC9	; 201
    72f2:	0c 94 cd 38 	jmp	0x719a	; 0x719a <__addsf3>
    72f6:	08 95       	ret

000072f8 <atan>:
    72f8:	df 93       	push	r29
    72fa:	dd 27       	eor	r29, r29
    72fc:	b9 2f       	mov	r27, r25
    72fe:	bf 77       	andi	r27, 0x7F	; 127
    7300:	40 e8       	ldi	r20, 0x80	; 128
    7302:	5f e3       	ldi	r21, 0x3F	; 63
    7304:	16 16       	cp	r1, r22
    7306:	17 06       	cpc	r1, r23
    7308:	48 07       	cpc	r20, r24
    730a:	5b 07       	cpc	r21, r27
    730c:	18 f4       	brcc	.+6      	; 0x7314 <atan+0x1c>
    730e:	d9 2f       	mov	r29, r25
    7310:	0e 94 e9 3b 	call	0x77d2	; 0x77d2 <inverse>
    7314:	9f 93       	push	r25
    7316:	8f 93       	push	r24
    7318:	7f 93       	push	r23
    731a:	6f 93       	push	r22
    731c:	0e 94 03 3d 	call	0x7a06	; 0x7a06 <square>
    7320:	e4 ea       	ldi	r30, 0xA4	; 164
    7322:	f2 e0       	ldi	r31, 0x02	; 2
    7324:	0e 94 1e 3b 	call	0x763c	; 0x763c <__fp_powser>
    7328:	0e 94 7e 3b 	call	0x76fc	; 0x76fc <__fp_round>
    732c:	2f 91       	pop	r18
    732e:	3f 91       	pop	r19
    7330:	4f 91       	pop	r20
    7332:	5f 91       	pop	r21
    7334:	0e 94 37 3c 	call	0x786e	; 0x786e <__mulsf3x>
    7338:	dd 23       	and	r29, r29
    733a:	51 f0       	breq	.+20     	; 0x7350 <atan+0x58>
    733c:	90 58       	subi	r25, 0x80	; 128
    733e:	a2 ea       	ldi	r26, 0xA2	; 162
    7340:	2a ed       	ldi	r18, 0xDA	; 218
    7342:	3f e0       	ldi	r19, 0x0F	; 15
    7344:	49 ec       	ldi	r20, 0xC9	; 201
    7346:	5f e3       	ldi	r21, 0x3F	; 63
    7348:	d0 78       	andi	r29, 0x80	; 128
    734a:	5d 27       	eor	r21, r29
    734c:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <__addsf3x>
    7350:	df 91       	pop	r29
    7352:	0c 94 7e 3b 	jmp	0x76fc	; 0x76fc <__fp_round>

00007356 <ceil>:
    7356:	0e 94 c5 3b 	call	0x778a	; 0x778a <__fp_trunc>
    735a:	90 f0       	brcs	.+36     	; 0x7380 <ceil+0x2a>
    735c:	9f 37       	cpi	r25, 0x7F	; 127
    735e:	48 f4       	brcc	.+18     	; 0x7372 <ceil+0x1c>
    7360:	91 11       	cpse	r25, r1
    7362:	16 f4       	brtc	.+4      	; 0x7368 <ceil+0x12>
    7364:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7368:	60 e0       	ldi	r22, 0x00	; 0
    736a:	70 e0       	ldi	r23, 0x00	; 0
    736c:	80 e8       	ldi	r24, 0x80	; 128
    736e:	9f e3       	ldi	r25, 0x3F	; 63
    7370:	08 95       	ret
    7372:	26 f0       	brts	.+8      	; 0x737c <ceil+0x26>
    7374:	1b 16       	cp	r1, r27
    7376:	61 1d       	adc	r22, r1
    7378:	71 1d       	adc	r23, r1
    737a:	81 1d       	adc	r24, r1
    737c:	0c 94 f2 3a 	jmp	0x75e4	; 0x75e4 <__fp_mintl>
    7380:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__fp_mpack>

00007384 <__cmpsf2>:
    7384:	0e 94 c8 3a 	call	0x7590	; 0x7590 <__fp_cmp>
    7388:	08 f4       	brcc	.+2      	; 0x738c <__cmpsf2+0x8>
    738a:	81 e0       	ldi	r24, 0x01	; 1
    738c:	08 95       	ret

0000738e <cos>:
    738e:	0e 94 55 3b 	call	0x76aa	; 0x76aa <__fp_rempio2>
    7392:	e3 95       	inc	r30
    7394:	0c 94 8f 3b 	jmp	0x771e	; 0x771e <__fp_sinus>

00007398 <__divsf3>:
    7398:	0e 94 e0 39 	call	0x73c0	; 0x73c0 <__divsf3x>
    739c:	0c 94 7e 3b 	jmp	0x76fc	; 0x76fc <__fp_round>
    73a0:	0e 94 4c 3b 	call	0x7698	; 0x7698 <__fp_pscB>
    73a4:	58 f0       	brcs	.+22     	; 0x73bc <__divsf3+0x24>
    73a6:	0e 94 45 3b 	call	0x768a	; 0x768a <__fp_pscA>
    73aa:	40 f0       	brcs	.+16     	; 0x73bc <__divsf3+0x24>
    73ac:	29 f4       	brne	.+10     	; 0x73b8 <__divsf3+0x20>
    73ae:	5f 3f       	cpi	r21, 0xFF	; 255
    73b0:	29 f0       	breq	.+10     	; 0x73bc <__divsf3+0x24>
    73b2:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_inf>
    73b6:	51 11       	cpse	r21, r1
    73b8:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    73bc:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>

000073c0 <__divsf3x>:
    73c0:	0e 94 a3 3b 	call	0x7746	; 0x7746 <__fp_split3>
    73c4:	68 f3       	brcs	.-38     	; 0x73a0 <__divsf3+0x8>

000073c6 <__divsf3_pse>:
    73c6:	99 23       	and	r25, r25
    73c8:	b1 f3       	breq	.-20     	; 0x73b6 <__divsf3+0x1e>
    73ca:	55 23       	and	r21, r21
    73cc:	91 f3       	breq	.-28     	; 0x73b2 <__divsf3+0x1a>
    73ce:	95 1b       	sub	r25, r21
    73d0:	55 0b       	sbc	r21, r21
    73d2:	bb 27       	eor	r27, r27
    73d4:	aa 27       	eor	r26, r26
    73d6:	62 17       	cp	r22, r18
    73d8:	73 07       	cpc	r23, r19
    73da:	84 07       	cpc	r24, r20
    73dc:	38 f0       	brcs	.+14     	; 0x73ec <__divsf3_pse+0x26>
    73de:	9f 5f       	subi	r25, 0xFF	; 255
    73e0:	5f 4f       	sbci	r21, 0xFF	; 255
    73e2:	22 0f       	add	r18, r18
    73e4:	33 1f       	adc	r19, r19
    73e6:	44 1f       	adc	r20, r20
    73e8:	aa 1f       	adc	r26, r26
    73ea:	a9 f3       	breq	.-22     	; 0x73d6 <__divsf3_pse+0x10>
    73ec:	35 d0       	rcall	.+106    	; 0x7458 <__divsf3_pse+0x92>
    73ee:	0e 2e       	mov	r0, r30
    73f0:	3a f0       	brmi	.+14     	; 0x7400 <__divsf3_pse+0x3a>
    73f2:	e0 e8       	ldi	r30, 0x80	; 128
    73f4:	32 d0       	rcall	.+100    	; 0x745a <__divsf3_pse+0x94>
    73f6:	91 50       	subi	r25, 0x01	; 1
    73f8:	50 40       	sbci	r21, 0x00	; 0
    73fa:	e6 95       	lsr	r30
    73fc:	00 1c       	adc	r0, r0
    73fe:	ca f7       	brpl	.-14     	; 0x73f2 <__divsf3_pse+0x2c>
    7400:	2b d0       	rcall	.+86     	; 0x7458 <__divsf3_pse+0x92>
    7402:	fe 2f       	mov	r31, r30
    7404:	29 d0       	rcall	.+82     	; 0x7458 <__divsf3_pse+0x92>
    7406:	66 0f       	add	r22, r22
    7408:	77 1f       	adc	r23, r23
    740a:	88 1f       	adc	r24, r24
    740c:	bb 1f       	adc	r27, r27
    740e:	26 17       	cp	r18, r22
    7410:	37 07       	cpc	r19, r23
    7412:	48 07       	cpc	r20, r24
    7414:	ab 07       	cpc	r26, r27
    7416:	b0 e8       	ldi	r27, 0x80	; 128
    7418:	09 f0       	breq	.+2      	; 0x741c <__divsf3_pse+0x56>
    741a:	bb 0b       	sbc	r27, r27
    741c:	80 2d       	mov	r24, r0
    741e:	bf 01       	movw	r22, r30
    7420:	ff 27       	eor	r31, r31
    7422:	93 58       	subi	r25, 0x83	; 131
    7424:	5f 4f       	sbci	r21, 0xFF	; 255
    7426:	3a f0       	brmi	.+14     	; 0x7436 <__divsf3_pse+0x70>
    7428:	9e 3f       	cpi	r25, 0xFE	; 254
    742a:	51 05       	cpc	r21, r1
    742c:	78 f0       	brcs	.+30     	; 0x744c <__divsf3_pse+0x86>
    742e:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_inf>
    7432:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7436:	5f 3f       	cpi	r21, 0xFF	; 255
    7438:	e4 f3       	brlt	.-8      	; 0x7432 <__divsf3_pse+0x6c>
    743a:	98 3e       	cpi	r25, 0xE8	; 232
    743c:	d4 f3       	brlt	.-12     	; 0x7432 <__divsf3_pse+0x6c>
    743e:	86 95       	lsr	r24
    7440:	77 95       	ror	r23
    7442:	67 95       	ror	r22
    7444:	b7 95       	ror	r27
    7446:	f7 95       	ror	r31
    7448:	9f 5f       	subi	r25, 0xFF	; 255
    744a:	c9 f7       	brne	.-14     	; 0x743e <__divsf3_pse+0x78>
    744c:	88 0f       	add	r24, r24
    744e:	91 1d       	adc	r25, r1
    7450:	96 95       	lsr	r25
    7452:	87 95       	ror	r24
    7454:	97 f9       	bld	r25, 7
    7456:	08 95       	ret
    7458:	e1 e0       	ldi	r30, 0x01	; 1
    745a:	66 0f       	add	r22, r22
    745c:	77 1f       	adc	r23, r23
    745e:	88 1f       	adc	r24, r24
    7460:	bb 1f       	adc	r27, r27
    7462:	62 17       	cp	r22, r18
    7464:	73 07       	cpc	r23, r19
    7466:	84 07       	cpc	r24, r20
    7468:	ba 07       	cpc	r27, r26
    746a:	20 f0       	brcs	.+8      	; 0x7474 <__divsf3_pse+0xae>
    746c:	62 1b       	sub	r22, r18
    746e:	73 0b       	sbc	r23, r19
    7470:	84 0b       	sbc	r24, r20
    7472:	ba 0b       	sbc	r27, r26
    7474:	ee 1f       	adc	r30, r30
    7476:	88 f7       	brcc	.-30     	; 0x745a <__divsf3_pse+0x94>
    7478:	e0 95       	com	r30
    747a:	08 95       	ret

0000747c <__fixsfsi>:
    747c:	0e 94 45 3a 	call	0x748a	; 0x748a <__fixunssfsi>
    7480:	68 94       	set
    7482:	b1 11       	cpse	r27, r1
    7484:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7488:	08 95       	ret

0000748a <__fixunssfsi>:
    748a:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    748e:	88 f0       	brcs	.+34     	; 0x74b2 <__fixunssfsi+0x28>
    7490:	9f 57       	subi	r25, 0x7F	; 127
    7492:	98 f0       	brcs	.+38     	; 0x74ba <__fixunssfsi+0x30>
    7494:	b9 2f       	mov	r27, r25
    7496:	99 27       	eor	r25, r25
    7498:	b7 51       	subi	r27, 0x17	; 23
    749a:	b0 f0       	brcs	.+44     	; 0x74c8 <__fixunssfsi+0x3e>
    749c:	e1 f0       	breq	.+56     	; 0x74d6 <__fixunssfsi+0x4c>
    749e:	66 0f       	add	r22, r22
    74a0:	77 1f       	adc	r23, r23
    74a2:	88 1f       	adc	r24, r24
    74a4:	99 1f       	adc	r25, r25
    74a6:	1a f0       	brmi	.+6      	; 0x74ae <__fixunssfsi+0x24>
    74a8:	ba 95       	dec	r27
    74aa:	c9 f7       	brne	.-14     	; 0x749e <__fixunssfsi+0x14>
    74ac:	14 c0       	rjmp	.+40     	; 0x74d6 <__fixunssfsi+0x4c>
    74ae:	b1 30       	cpi	r27, 0x01	; 1
    74b0:	91 f0       	breq	.+36     	; 0x74d6 <__fixunssfsi+0x4c>
    74b2:	0e 94 dd 3b 	call	0x77ba	; 0x77ba <__fp_zero>
    74b6:	b1 e0       	ldi	r27, 0x01	; 1
    74b8:	08 95       	ret
    74ba:	0c 94 dd 3b 	jmp	0x77ba	; 0x77ba <__fp_zero>
    74be:	67 2f       	mov	r22, r23
    74c0:	78 2f       	mov	r23, r24
    74c2:	88 27       	eor	r24, r24
    74c4:	b8 5f       	subi	r27, 0xF8	; 248
    74c6:	39 f0       	breq	.+14     	; 0x74d6 <__fixunssfsi+0x4c>
    74c8:	b9 3f       	cpi	r27, 0xF9	; 249
    74ca:	cc f3       	brlt	.-14     	; 0x74be <__fixunssfsi+0x34>
    74cc:	86 95       	lsr	r24
    74ce:	77 95       	ror	r23
    74d0:	67 95       	ror	r22
    74d2:	b3 95       	inc	r27
    74d4:	d9 f7       	brne	.-10     	; 0x74cc <__fixunssfsi+0x42>
    74d6:	3e f4       	brtc	.+14     	; 0x74e6 <__fixunssfsi+0x5c>
    74d8:	90 95       	com	r25
    74da:	80 95       	com	r24
    74dc:	70 95       	com	r23
    74de:	61 95       	neg	r22
    74e0:	7f 4f       	sbci	r23, 0xFF	; 255
    74e2:	8f 4f       	sbci	r24, 0xFF	; 255
    74e4:	9f 4f       	sbci	r25, 0xFF	; 255
    74e6:	08 95       	ret

000074e8 <__floatunsisf>:
    74e8:	e8 94       	clt
    74ea:	09 c0       	rjmp	.+18     	; 0x74fe <__floatsisf+0x12>

000074ec <__floatsisf>:
    74ec:	97 fb       	bst	r25, 7
    74ee:	3e f4       	brtc	.+14     	; 0x74fe <__floatsisf+0x12>
    74f0:	90 95       	com	r25
    74f2:	80 95       	com	r24
    74f4:	70 95       	com	r23
    74f6:	61 95       	neg	r22
    74f8:	7f 4f       	sbci	r23, 0xFF	; 255
    74fa:	8f 4f       	sbci	r24, 0xFF	; 255
    74fc:	9f 4f       	sbci	r25, 0xFF	; 255
    74fe:	99 23       	and	r25, r25
    7500:	a9 f0       	breq	.+42     	; 0x752c <__floatsisf+0x40>
    7502:	f9 2f       	mov	r31, r25
    7504:	96 e9       	ldi	r25, 0x96	; 150
    7506:	bb 27       	eor	r27, r27
    7508:	93 95       	inc	r25
    750a:	f6 95       	lsr	r31
    750c:	87 95       	ror	r24
    750e:	77 95       	ror	r23
    7510:	67 95       	ror	r22
    7512:	b7 95       	ror	r27
    7514:	f1 11       	cpse	r31, r1
    7516:	f8 cf       	rjmp	.-16     	; 0x7508 <__floatsisf+0x1c>
    7518:	fa f4       	brpl	.+62     	; 0x7558 <__floatsisf+0x6c>
    751a:	bb 0f       	add	r27, r27
    751c:	11 f4       	brne	.+4      	; 0x7522 <__floatsisf+0x36>
    751e:	60 ff       	sbrs	r22, 0
    7520:	1b c0       	rjmp	.+54     	; 0x7558 <__floatsisf+0x6c>
    7522:	6f 5f       	subi	r22, 0xFF	; 255
    7524:	7f 4f       	sbci	r23, 0xFF	; 255
    7526:	8f 4f       	sbci	r24, 0xFF	; 255
    7528:	9f 4f       	sbci	r25, 0xFF	; 255
    752a:	16 c0       	rjmp	.+44     	; 0x7558 <__floatsisf+0x6c>
    752c:	88 23       	and	r24, r24
    752e:	11 f0       	breq	.+4      	; 0x7534 <__floatsisf+0x48>
    7530:	96 e9       	ldi	r25, 0x96	; 150
    7532:	11 c0       	rjmp	.+34     	; 0x7556 <__floatsisf+0x6a>
    7534:	77 23       	and	r23, r23
    7536:	21 f0       	breq	.+8      	; 0x7540 <__floatsisf+0x54>
    7538:	9e e8       	ldi	r25, 0x8E	; 142
    753a:	87 2f       	mov	r24, r23
    753c:	76 2f       	mov	r23, r22
    753e:	05 c0       	rjmp	.+10     	; 0x754a <__floatsisf+0x5e>
    7540:	66 23       	and	r22, r22
    7542:	71 f0       	breq	.+28     	; 0x7560 <__floatsisf+0x74>
    7544:	96 e8       	ldi	r25, 0x86	; 134
    7546:	86 2f       	mov	r24, r22
    7548:	70 e0       	ldi	r23, 0x00	; 0
    754a:	60 e0       	ldi	r22, 0x00	; 0
    754c:	2a f0       	brmi	.+10     	; 0x7558 <__floatsisf+0x6c>
    754e:	9a 95       	dec	r25
    7550:	66 0f       	add	r22, r22
    7552:	77 1f       	adc	r23, r23
    7554:	88 1f       	adc	r24, r24
    7556:	da f7       	brpl	.-10     	; 0x754e <__floatsisf+0x62>
    7558:	88 0f       	add	r24, r24
    755a:	96 95       	lsr	r25
    755c:	87 95       	ror	r24
    755e:	97 f9       	bld	r25, 7
    7560:	08 95       	ret

00007562 <floor>:
    7562:	0e 94 c5 3b 	call	0x778a	; 0x778a <__fp_trunc>
    7566:	90 f0       	brcs	.+36     	; 0x758c <floor+0x2a>
    7568:	9f 37       	cpi	r25, 0x7F	; 127
    756a:	48 f4       	brcc	.+18     	; 0x757e <floor+0x1c>
    756c:	91 11       	cpse	r25, r1
    756e:	16 f0       	brts	.+4      	; 0x7574 <floor+0x12>
    7570:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7574:	60 e0       	ldi	r22, 0x00	; 0
    7576:	70 e0       	ldi	r23, 0x00	; 0
    7578:	80 e8       	ldi	r24, 0x80	; 128
    757a:	9f eb       	ldi	r25, 0xBF	; 191
    757c:	08 95       	ret
    757e:	26 f4       	brtc	.+8      	; 0x7588 <floor+0x26>
    7580:	1b 16       	cp	r1, r27
    7582:	61 1d       	adc	r22, r1
    7584:	71 1d       	adc	r23, r1
    7586:	81 1d       	adc	r24, r1
    7588:	0c 94 f2 3a 	jmp	0x75e4	; 0x75e4 <__fp_mintl>
    758c:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__fp_mpack>

00007590 <__fp_cmp>:
    7590:	99 0f       	add	r25, r25
    7592:	00 08       	sbc	r0, r0
    7594:	55 0f       	add	r21, r21
    7596:	aa 0b       	sbc	r26, r26
    7598:	e0 e8       	ldi	r30, 0x80	; 128
    759a:	fe ef       	ldi	r31, 0xFE	; 254
    759c:	16 16       	cp	r1, r22
    759e:	17 06       	cpc	r1, r23
    75a0:	e8 07       	cpc	r30, r24
    75a2:	f9 07       	cpc	r31, r25
    75a4:	c0 f0       	brcs	.+48     	; 0x75d6 <__fp_cmp+0x46>
    75a6:	12 16       	cp	r1, r18
    75a8:	13 06       	cpc	r1, r19
    75aa:	e4 07       	cpc	r30, r20
    75ac:	f5 07       	cpc	r31, r21
    75ae:	98 f0       	brcs	.+38     	; 0x75d6 <__fp_cmp+0x46>
    75b0:	62 1b       	sub	r22, r18
    75b2:	73 0b       	sbc	r23, r19
    75b4:	84 0b       	sbc	r24, r20
    75b6:	95 0b       	sbc	r25, r21
    75b8:	39 f4       	brne	.+14     	; 0x75c8 <__fp_cmp+0x38>
    75ba:	0a 26       	eor	r0, r26
    75bc:	61 f0       	breq	.+24     	; 0x75d6 <__fp_cmp+0x46>
    75be:	23 2b       	or	r18, r19
    75c0:	24 2b       	or	r18, r20
    75c2:	25 2b       	or	r18, r21
    75c4:	21 f4       	brne	.+8      	; 0x75ce <__fp_cmp+0x3e>
    75c6:	08 95       	ret
    75c8:	0a 26       	eor	r0, r26
    75ca:	09 f4       	brne	.+2      	; 0x75ce <__fp_cmp+0x3e>
    75cc:	a1 40       	sbci	r26, 0x01	; 1
    75ce:	a6 95       	lsr	r26
    75d0:	8f ef       	ldi	r24, 0xFF	; 255
    75d2:	81 1d       	adc	r24, r1
    75d4:	81 1d       	adc	r24, r1
    75d6:	08 95       	ret

000075d8 <__fp_inf>:
    75d8:	97 f9       	bld	r25, 7
    75da:	9f 67       	ori	r25, 0x7F	; 127
    75dc:	80 e8       	ldi	r24, 0x80	; 128
    75de:	70 e0       	ldi	r23, 0x00	; 0
    75e0:	60 e0       	ldi	r22, 0x00	; 0
    75e2:	08 95       	ret

000075e4 <__fp_mintl>:
    75e4:	88 23       	and	r24, r24
    75e6:	71 f4       	brne	.+28     	; 0x7604 <__fp_mintl+0x20>
    75e8:	77 23       	and	r23, r23
    75ea:	21 f0       	breq	.+8      	; 0x75f4 <__fp_mintl+0x10>
    75ec:	98 50       	subi	r25, 0x08	; 8
    75ee:	87 2b       	or	r24, r23
    75f0:	76 2f       	mov	r23, r22
    75f2:	07 c0       	rjmp	.+14     	; 0x7602 <__fp_mintl+0x1e>
    75f4:	66 23       	and	r22, r22
    75f6:	11 f4       	brne	.+4      	; 0x75fc <__fp_mintl+0x18>
    75f8:	99 27       	eor	r25, r25
    75fa:	0d c0       	rjmp	.+26     	; 0x7616 <__fp_mintl+0x32>
    75fc:	90 51       	subi	r25, 0x10	; 16
    75fe:	86 2b       	or	r24, r22
    7600:	70 e0       	ldi	r23, 0x00	; 0
    7602:	60 e0       	ldi	r22, 0x00	; 0
    7604:	2a f0       	brmi	.+10     	; 0x7610 <__fp_mintl+0x2c>
    7606:	9a 95       	dec	r25
    7608:	66 0f       	add	r22, r22
    760a:	77 1f       	adc	r23, r23
    760c:	88 1f       	adc	r24, r24
    760e:	da f7       	brpl	.-10     	; 0x7606 <__fp_mintl+0x22>
    7610:	88 0f       	add	r24, r24
    7612:	96 95       	lsr	r25
    7614:	87 95       	ror	r24
    7616:	97 f9       	bld	r25, 7
    7618:	08 95       	ret

0000761a <__fp_mpack>:
    761a:	9f 3f       	cpi	r25, 0xFF	; 255
    761c:	31 f0       	breq	.+12     	; 0x762a <__fp_mpack_finite+0xc>

0000761e <__fp_mpack_finite>:
    761e:	91 50       	subi	r25, 0x01	; 1
    7620:	20 f4       	brcc	.+8      	; 0x762a <__fp_mpack_finite+0xc>
    7622:	87 95       	ror	r24
    7624:	77 95       	ror	r23
    7626:	67 95       	ror	r22
    7628:	b7 95       	ror	r27
    762a:	88 0f       	add	r24, r24
    762c:	91 1d       	adc	r25, r1
    762e:	96 95       	lsr	r25
    7630:	87 95       	ror	r24
    7632:	97 f9       	bld	r25, 7
    7634:	08 95       	ret

00007636 <__fp_nan>:
    7636:	9f ef       	ldi	r25, 0xFF	; 255
    7638:	80 ec       	ldi	r24, 0xC0	; 192
    763a:	08 95       	ret

0000763c <__fp_powser>:
    763c:	df 93       	push	r29
    763e:	cf 93       	push	r28
    7640:	1f 93       	push	r17
    7642:	0f 93       	push	r16
    7644:	ff 92       	push	r15
    7646:	ef 92       	push	r14
    7648:	df 92       	push	r13
    764a:	7b 01       	movw	r14, r22
    764c:	8c 01       	movw	r16, r24
    764e:	68 94       	set
    7650:	06 c0       	rjmp	.+12     	; 0x765e <__fp_powser+0x22>
    7652:	da 2e       	mov	r13, r26
    7654:	ef 01       	movw	r28, r30
    7656:	0e 94 37 3c 	call	0x786e	; 0x786e <__mulsf3x>
    765a:	fe 01       	movw	r30, r28
    765c:	e8 94       	clt
    765e:	a5 91       	lpm	r26, Z+
    7660:	25 91       	lpm	r18, Z+
    7662:	35 91       	lpm	r19, Z+
    7664:	45 91       	lpm	r20, Z+
    7666:	55 91       	lpm	r21, Z+
    7668:	a6 f3       	brts	.-24     	; 0x7652 <__fp_powser+0x16>
    766a:	ef 01       	movw	r28, r30
    766c:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <__addsf3x>
    7670:	fe 01       	movw	r30, r28
    7672:	97 01       	movw	r18, r14
    7674:	a8 01       	movw	r20, r16
    7676:	da 94       	dec	r13
    7678:	69 f7       	brne	.-38     	; 0x7654 <__fp_powser+0x18>
    767a:	df 90       	pop	r13
    767c:	ef 90       	pop	r14
    767e:	ff 90       	pop	r15
    7680:	0f 91       	pop	r16
    7682:	1f 91       	pop	r17
    7684:	cf 91       	pop	r28
    7686:	df 91       	pop	r29
    7688:	08 95       	ret

0000768a <__fp_pscA>:
    768a:	00 24       	eor	r0, r0
    768c:	0a 94       	dec	r0
    768e:	16 16       	cp	r1, r22
    7690:	17 06       	cpc	r1, r23
    7692:	18 06       	cpc	r1, r24
    7694:	09 06       	cpc	r0, r25
    7696:	08 95       	ret

00007698 <__fp_pscB>:
    7698:	00 24       	eor	r0, r0
    769a:	0a 94       	dec	r0
    769c:	12 16       	cp	r1, r18
    769e:	13 06       	cpc	r1, r19
    76a0:	14 06       	cpc	r1, r20
    76a2:	05 06       	cpc	r0, r21
    76a4:	08 95       	ret
    76a6:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>

000076aa <__fp_rempio2>:
    76aa:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    76ae:	d8 f3       	brcs	.-10     	; 0x76a6 <__fp_pscB+0xe>
    76b0:	e8 94       	clt
    76b2:	e0 e0       	ldi	r30, 0x00	; 0
    76b4:	bb 27       	eor	r27, r27
    76b6:	9f 57       	subi	r25, 0x7F	; 127
    76b8:	f0 f0       	brcs	.+60     	; 0x76f6 <__fp_rempio2+0x4c>
    76ba:	2a ed       	ldi	r18, 0xDA	; 218
    76bc:	3f e0       	ldi	r19, 0x0F	; 15
    76be:	49 ec       	ldi	r20, 0xC9	; 201
    76c0:	06 c0       	rjmp	.+12     	; 0x76ce <__fp_rempio2+0x24>
    76c2:	ee 0f       	add	r30, r30
    76c4:	bb 0f       	add	r27, r27
    76c6:	66 1f       	adc	r22, r22
    76c8:	77 1f       	adc	r23, r23
    76ca:	88 1f       	adc	r24, r24
    76cc:	28 f0       	brcs	.+10     	; 0x76d8 <__fp_rempio2+0x2e>
    76ce:	b2 3a       	cpi	r27, 0xA2	; 162
    76d0:	62 07       	cpc	r22, r18
    76d2:	73 07       	cpc	r23, r19
    76d4:	84 07       	cpc	r24, r20
    76d6:	28 f0       	brcs	.+10     	; 0x76e2 <__fp_rempio2+0x38>
    76d8:	b2 5a       	subi	r27, 0xA2	; 162
    76da:	62 0b       	sbc	r22, r18
    76dc:	73 0b       	sbc	r23, r19
    76de:	84 0b       	sbc	r24, r20
    76e0:	e3 95       	inc	r30
    76e2:	9a 95       	dec	r25
    76e4:	72 f7       	brpl	.-36     	; 0x76c2 <__fp_rempio2+0x18>
    76e6:	80 38       	cpi	r24, 0x80	; 128
    76e8:	30 f4       	brcc	.+12     	; 0x76f6 <__fp_rempio2+0x4c>
    76ea:	9a 95       	dec	r25
    76ec:	bb 0f       	add	r27, r27
    76ee:	66 1f       	adc	r22, r22
    76f0:	77 1f       	adc	r23, r23
    76f2:	88 1f       	adc	r24, r24
    76f4:	d2 f7       	brpl	.-12     	; 0x76ea <__fp_rempio2+0x40>
    76f6:	90 48       	sbci	r25, 0x80	; 128
    76f8:	0c 94 0f 3b 	jmp	0x761e	; 0x761e <__fp_mpack_finite>

000076fc <__fp_round>:
    76fc:	09 2e       	mov	r0, r25
    76fe:	03 94       	inc	r0
    7700:	00 0c       	add	r0, r0
    7702:	11 f4       	brne	.+4      	; 0x7708 <__fp_round+0xc>
    7704:	88 23       	and	r24, r24
    7706:	52 f0       	brmi	.+20     	; 0x771c <__fp_round+0x20>
    7708:	bb 0f       	add	r27, r27
    770a:	40 f4       	brcc	.+16     	; 0x771c <__fp_round+0x20>
    770c:	bf 2b       	or	r27, r31
    770e:	11 f4       	brne	.+4      	; 0x7714 <__fp_round+0x18>
    7710:	60 ff       	sbrs	r22, 0
    7712:	04 c0       	rjmp	.+8      	; 0x771c <__fp_round+0x20>
    7714:	6f 5f       	subi	r22, 0xFF	; 255
    7716:	7f 4f       	sbci	r23, 0xFF	; 255
    7718:	8f 4f       	sbci	r24, 0xFF	; 255
    771a:	9f 4f       	sbci	r25, 0xFF	; 255
    771c:	08 95       	ret

0000771e <__fp_sinus>:
    771e:	ef 93       	push	r30
    7720:	e0 ff       	sbrs	r30, 0
    7722:	07 c0       	rjmp	.+14     	; 0x7732 <__fp_sinus+0x14>
    7724:	a2 ea       	ldi	r26, 0xA2	; 162
    7726:	2a ed       	ldi	r18, 0xDA	; 218
    7728:	3f e0       	ldi	r19, 0x0F	; 15
    772a:	49 ec       	ldi	r20, 0xC9	; 201
    772c:	5f eb       	ldi	r21, 0xBF	; 191
    772e:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <__addsf3x>
    7732:	0e 94 7e 3b 	call	0x76fc	; 0x76fc <__fp_round>
    7736:	0f 90       	pop	r0
    7738:	03 94       	inc	r0
    773a:	01 fc       	sbrc	r0, 1
    773c:	90 58       	subi	r25, 0x80	; 128
    773e:	e1 ed       	ldi	r30, 0xD1	; 209
    7740:	f2 e0       	ldi	r31, 0x02	; 2
    7742:	0c 94 19 3d 	jmp	0x7a32	; 0x7a32 <__fp_powsodd>

00007746 <__fp_split3>:
    7746:	57 fd       	sbrc	r21, 7
    7748:	90 58       	subi	r25, 0x80	; 128
    774a:	44 0f       	add	r20, r20
    774c:	55 1f       	adc	r21, r21
    774e:	59 f0       	breq	.+22     	; 0x7766 <__fp_splitA+0x10>
    7750:	5f 3f       	cpi	r21, 0xFF	; 255
    7752:	71 f0       	breq	.+28     	; 0x7770 <__fp_splitA+0x1a>
    7754:	47 95       	ror	r20

00007756 <__fp_splitA>:
    7756:	88 0f       	add	r24, r24
    7758:	97 fb       	bst	r25, 7
    775a:	99 1f       	adc	r25, r25
    775c:	61 f0       	breq	.+24     	; 0x7776 <__fp_splitA+0x20>
    775e:	9f 3f       	cpi	r25, 0xFF	; 255
    7760:	79 f0       	breq	.+30     	; 0x7780 <__fp_splitA+0x2a>
    7762:	87 95       	ror	r24
    7764:	08 95       	ret
    7766:	12 16       	cp	r1, r18
    7768:	13 06       	cpc	r1, r19
    776a:	14 06       	cpc	r1, r20
    776c:	55 1f       	adc	r21, r21
    776e:	f2 cf       	rjmp	.-28     	; 0x7754 <__fp_split3+0xe>
    7770:	46 95       	lsr	r20
    7772:	f1 df       	rcall	.-30     	; 0x7756 <__fp_splitA>
    7774:	08 c0       	rjmp	.+16     	; 0x7786 <__fp_splitA+0x30>
    7776:	16 16       	cp	r1, r22
    7778:	17 06       	cpc	r1, r23
    777a:	18 06       	cpc	r1, r24
    777c:	99 1f       	adc	r25, r25
    777e:	f1 cf       	rjmp	.-30     	; 0x7762 <__fp_splitA+0xc>
    7780:	86 95       	lsr	r24
    7782:	71 05       	cpc	r23, r1
    7784:	61 05       	cpc	r22, r1
    7786:	08 94       	sec
    7788:	08 95       	ret

0000778a <__fp_trunc>:
    778a:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    778e:	a0 f0       	brcs	.+40     	; 0x77b8 <__fp_trunc+0x2e>
    7790:	be e7       	ldi	r27, 0x7E	; 126
    7792:	b9 17       	cp	r27, r25
    7794:	88 f4       	brcc	.+34     	; 0x77b8 <__fp_trunc+0x2e>
    7796:	bb 27       	eor	r27, r27
    7798:	9f 38       	cpi	r25, 0x8F	; 143
    779a:	60 f4       	brcc	.+24     	; 0x77b4 <__fp_trunc+0x2a>
    779c:	16 16       	cp	r1, r22
    779e:	b1 1d       	adc	r27, r1
    77a0:	67 2f       	mov	r22, r23
    77a2:	78 2f       	mov	r23, r24
    77a4:	88 27       	eor	r24, r24
    77a6:	98 5f       	subi	r25, 0xF8	; 248
    77a8:	f7 cf       	rjmp	.-18     	; 0x7798 <__fp_trunc+0xe>
    77aa:	86 95       	lsr	r24
    77ac:	77 95       	ror	r23
    77ae:	67 95       	ror	r22
    77b0:	b1 1d       	adc	r27, r1
    77b2:	93 95       	inc	r25
    77b4:	96 39       	cpi	r25, 0x96	; 150
    77b6:	c8 f3       	brcs	.-14     	; 0x77aa <__fp_trunc+0x20>
    77b8:	08 95       	ret

000077ba <__fp_zero>:
    77ba:	e8 94       	clt

000077bc <__fp_szero>:
    77bc:	bb 27       	eor	r27, r27
    77be:	66 27       	eor	r22, r22
    77c0:	77 27       	eor	r23, r23
    77c2:	cb 01       	movw	r24, r22
    77c4:	97 f9       	bld	r25, 7
    77c6:	08 95       	ret

000077c8 <__gesf2>:
    77c8:	0e 94 c8 3a 	call	0x7590	; 0x7590 <__fp_cmp>
    77cc:	08 f4       	brcc	.+2      	; 0x77d0 <__gesf2+0x8>
    77ce:	8f ef       	ldi	r24, 0xFF	; 255
    77d0:	08 95       	ret

000077d2 <inverse>:
    77d2:	9b 01       	movw	r18, r22
    77d4:	ac 01       	movw	r20, r24
    77d6:	60 e0       	ldi	r22, 0x00	; 0
    77d8:	70 e0       	ldi	r23, 0x00	; 0
    77da:	80 e8       	ldi	r24, 0x80	; 128
    77dc:	9f e3       	ldi	r25, 0x3F	; 63
    77de:	0c 94 cc 39 	jmp	0x7398	; 0x7398 <__divsf3>

000077e2 <lround>:
    77e2:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    77e6:	58 f1       	brcs	.+86     	; 0x783e <lround+0x5c>
    77e8:	9e 57       	subi	r25, 0x7E	; 126
    77ea:	60 f1       	brcs	.+88     	; 0x7844 <lround+0x62>
    77ec:	98 51       	subi	r25, 0x18	; 24
    77ee:	a0 f0       	brcs	.+40     	; 0x7818 <lround+0x36>
    77f0:	e9 f0       	breq	.+58     	; 0x782c <lround+0x4a>
    77f2:	98 30       	cpi	r25, 0x08	; 8
    77f4:	20 f5       	brcc	.+72     	; 0x783e <lround+0x5c>
    77f6:	09 2e       	mov	r0, r25
    77f8:	99 27       	eor	r25, r25
    77fa:	66 0f       	add	r22, r22
    77fc:	77 1f       	adc	r23, r23
    77fe:	88 1f       	adc	r24, r24
    7800:	99 1f       	adc	r25, r25
    7802:	0a 94       	dec	r0
    7804:	d1 f7       	brne	.-12     	; 0x77fa <lround+0x18>
    7806:	12 c0       	rjmp	.+36     	; 0x782c <lround+0x4a>
    7808:	06 2e       	mov	r0, r22
    780a:	67 2f       	mov	r22, r23
    780c:	78 2f       	mov	r23, r24
    780e:	88 27       	eor	r24, r24
    7810:	98 5f       	subi	r25, 0xF8	; 248
    7812:	11 f4       	brne	.+4      	; 0x7818 <lround+0x36>
    7814:	00 0c       	add	r0, r0
    7816:	07 c0       	rjmp	.+14     	; 0x7826 <lround+0x44>
    7818:	99 3f       	cpi	r25, 0xF9	; 249
    781a:	b4 f3       	brlt	.-20     	; 0x7808 <lround+0x26>
    781c:	86 95       	lsr	r24
    781e:	77 95       	ror	r23
    7820:	67 95       	ror	r22
    7822:	93 95       	inc	r25
    7824:	d9 f7       	brne	.-10     	; 0x781c <lround+0x3a>
    7826:	61 1d       	adc	r22, r1
    7828:	71 1d       	adc	r23, r1
    782a:	81 1d       	adc	r24, r1
    782c:	3e f4       	brtc	.+14     	; 0x783c <lround+0x5a>
    782e:	90 95       	com	r25
    7830:	80 95       	com	r24
    7832:	70 95       	com	r23
    7834:	61 95       	neg	r22
    7836:	7f 4f       	sbci	r23, 0xFF	; 255
    7838:	8f 4f       	sbci	r24, 0xFF	; 255
    783a:	9f 4f       	sbci	r25, 0xFF	; 255
    783c:	08 95       	ret
    783e:	68 94       	set
    7840:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7844:	0c 94 dd 3b 	jmp	0x77ba	; 0x77ba <__fp_zero>

00007848 <__mulsf3>:
    7848:	0e 94 37 3c 	call	0x786e	; 0x786e <__mulsf3x>
    784c:	0c 94 7e 3b 	jmp	0x76fc	; 0x76fc <__fp_round>
    7850:	0e 94 45 3b 	call	0x768a	; 0x768a <__fp_pscA>
    7854:	38 f0       	brcs	.+14     	; 0x7864 <__mulsf3+0x1c>
    7856:	0e 94 4c 3b 	call	0x7698	; 0x7698 <__fp_pscB>
    785a:	20 f0       	brcs	.+8      	; 0x7864 <__mulsf3+0x1c>
    785c:	95 23       	and	r25, r21
    785e:	11 f0       	breq	.+4      	; 0x7864 <__mulsf3+0x1c>
    7860:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_inf>
    7864:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>
    7868:	11 24       	eor	r1, r1
    786a:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>

0000786e <__mulsf3x>:
    786e:	0e 94 a3 3b 	call	0x7746	; 0x7746 <__fp_split3>
    7872:	70 f3       	brcs	.-36     	; 0x7850 <__mulsf3+0x8>

00007874 <__mulsf3_pse>:
    7874:	95 9f       	mul	r25, r21
    7876:	c1 f3       	breq	.-16     	; 0x7868 <__mulsf3+0x20>
    7878:	95 0f       	add	r25, r21
    787a:	50 e0       	ldi	r21, 0x00	; 0
    787c:	55 1f       	adc	r21, r21
    787e:	62 9f       	mul	r22, r18
    7880:	f0 01       	movw	r30, r0
    7882:	72 9f       	mul	r23, r18
    7884:	bb 27       	eor	r27, r27
    7886:	f0 0d       	add	r31, r0
    7888:	b1 1d       	adc	r27, r1
    788a:	63 9f       	mul	r22, r19
    788c:	aa 27       	eor	r26, r26
    788e:	f0 0d       	add	r31, r0
    7890:	b1 1d       	adc	r27, r1
    7892:	aa 1f       	adc	r26, r26
    7894:	64 9f       	mul	r22, r20
    7896:	66 27       	eor	r22, r22
    7898:	b0 0d       	add	r27, r0
    789a:	a1 1d       	adc	r26, r1
    789c:	66 1f       	adc	r22, r22
    789e:	82 9f       	mul	r24, r18
    78a0:	22 27       	eor	r18, r18
    78a2:	b0 0d       	add	r27, r0
    78a4:	a1 1d       	adc	r26, r1
    78a6:	62 1f       	adc	r22, r18
    78a8:	73 9f       	mul	r23, r19
    78aa:	b0 0d       	add	r27, r0
    78ac:	a1 1d       	adc	r26, r1
    78ae:	62 1f       	adc	r22, r18
    78b0:	83 9f       	mul	r24, r19
    78b2:	a0 0d       	add	r26, r0
    78b4:	61 1d       	adc	r22, r1
    78b6:	22 1f       	adc	r18, r18
    78b8:	74 9f       	mul	r23, r20
    78ba:	33 27       	eor	r19, r19
    78bc:	a0 0d       	add	r26, r0
    78be:	61 1d       	adc	r22, r1
    78c0:	23 1f       	adc	r18, r19
    78c2:	84 9f       	mul	r24, r20
    78c4:	60 0d       	add	r22, r0
    78c6:	21 1d       	adc	r18, r1
    78c8:	82 2f       	mov	r24, r18
    78ca:	76 2f       	mov	r23, r22
    78cc:	6a 2f       	mov	r22, r26
    78ce:	11 24       	eor	r1, r1
    78d0:	9f 57       	subi	r25, 0x7F	; 127
    78d2:	50 40       	sbci	r21, 0x00	; 0
    78d4:	9a f0       	brmi	.+38     	; 0x78fc <__mulsf3_pse+0x88>
    78d6:	f1 f0       	breq	.+60     	; 0x7914 <__mulsf3_pse+0xa0>
    78d8:	88 23       	and	r24, r24
    78da:	4a f0       	brmi	.+18     	; 0x78ee <__mulsf3_pse+0x7a>
    78dc:	ee 0f       	add	r30, r30
    78de:	ff 1f       	adc	r31, r31
    78e0:	bb 1f       	adc	r27, r27
    78e2:	66 1f       	adc	r22, r22
    78e4:	77 1f       	adc	r23, r23
    78e6:	88 1f       	adc	r24, r24
    78e8:	91 50       	subi	r25, 0x01	; 1
    78ea:	50 40       	sbci	r21, 0x00	; 0
    78ec:	a9 f7       	brne	.-22     	; 0x78d8 <__mulsf3_pse+0x64>
    78ee:	9e 3f       	cpi	r25, 0xFE	; 254
    78f0:	51 05       	cpc	r21, r1
    78f2:	80 f0       	brcs	.+32     	; 0x7914 <__mulsf3_pse+0xa0>
    78f4:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_inf>
    78f8:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    78fc:	5f 3f       	cpi	r21, 0xFF	; 255
    78fe:	e4 f3       	brlt	.-8      	; 0x78f8 <__mulsf3_pse+0x84>
    7900:	98 3e       	cpi	r25, 0xE8	; 232
    7902:	d4 f3       	brlt	.-12     	; 0x78f8 <__mulsf3_pse+0x84>
    7904:	86 95       	lsr	r24
    7906:	77 95       	ror	r23
    7908:	67 95       	ror	r22
    790a:	b7 95       	ror	r27
    790c:	f7 95       	ror	r31
    790e:	e7 95       	ror	r30
    7910:	9f 5f       	subi	r25, 0xFF	; 255
    7912:	c1 f7       	brne	.-16     	; 0x7904 <__mulsf3_pse+0x90>
    7914:	fe 2b       	or	r31, r30
    7916:	88 0f       	add	r24, r24
    7918:	91 1d       	adc	r25, r1
    791a:	96 95       	lsr	r25
    791c:	87 95       	ror	r24
    791e:	97 f9       	bld	r25, 7
    7920:	08 95       	ret

00007922 <round>:
    7922:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    7926:	e8 f0       	brcs	.+58     	; 0x7962 <round+0x40>
    7928:	9e 37       	cpi	r25, 0x7E	; 126
    792a:	e8 f0       	brcs	.+58     	; 0x7966 <round+0x44>
    792c:	96 39       	cpi	r25, 0x96	; 150
    792e:	b8 f4       	brcc	.+46     	; 0x795e <round+0x3c>
    7930:	9e 38       	cpi	r25, 0x8E	; 142
    7932:	48 f4       	brcc	.+18     	; 0x7946 <round+0x24>
    7934:	67 2f       	mov	r22, r23
    7936:	78 2f       	mov	r23, r24
    7938:	88 27       	eor	r24, r24
    793a:	98 5f       	subi	r25, 0xF8	; 248
    793c:	f9 cf       	rjmp	.-14     	; 0x7930 <round+0xe>
    793e:	86 95       	lsr	r24
    7940:	77 95       	ror	r23
    7942:	67 95       	ror	r22
    7944:	93 95       	inc	r25
    7946:	95 39       	cpi	r25, 0x95	; 149
    7948:	d0 f3       	brcs	.-12     	; 0x793e <round+0x1c>
    794a:	b6 2f       	mov	r27, r22
    794c:	b1 70       	andi	r27, 0x01	; 1
    794e:	6b 0f       	add	r22, r27
    7950:	71 1d       	adc	r23, r1
    7952:	81 1d       	adc	r24, r1
    7954:	20 f4       	brcc	.+8      	; 0x795e <round+0x3c>
    7956:	87 95       	ror	r24
    7958:	77 95       	ror	r23
    795a:	67 95       	ror	r22
    795c:	93 95       	inc	r25
    795e:	0c 94 f2 3a 	jmp	0x75e4	; 0x75e4 <__fp_mintl>
    7962:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__fp_mpack>
    7966:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>

0000796a <sin>:
    796a:	9f 93       	push	r25
    796c:	0e 94 55 3b 	call	0x76aa	; 0x76aa <__fp_rempio2>
    7970:	0f 90       	pop	r0
    7972:	07 fc       	sbrc	r0, 7
    7974:	ee 5f       	subi	r30, 0xFE	; 254
    7976:	0c 94 8f 3b 	jmp	0x771e	; 0x771e <__fp_sinus>
    797a:	19 f4       	brne	.+6      	; 0x7982 <sin+0x18>
    797c:	16 f4       	brtc	.+4      	; 0x7982 <sin+0x18>
    797e:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <__fp_nan>
    7982:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__fp_mpack>

00007986 <sqrt>:
    7986:	0e 94 ab 3b 	call	0x7756	; 0x7756 <__fp_splitA>
    798a:	b8 f3       	brcs	.-18     	; 0x797a <sin+0x10>
    798c:	99 23       	and	r25, r25
    798e:	c9 f3       	breq	.-14     	; 0x7982 <sin+0x18>
    7990:	b6 f3       	brts	.-20     	; 0x797e <sin+0x14>
    7992:	9f 57       	subi	r25, 0x7F	; 127
    7994:	55 0b       	sbc	r21, r21
    7996:	87 ff       	sbrs	r24, 7
    7998:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <__fp_norm2>
    799c:	00 24       	eor	r0, r0
    799e:	a0 e6       	ldi	r26, 0x60	; 96
    79a0:	40 ea       	ldi	r20, 0xA0	; 160
    79a2:	90 01       	movw	r18, r0
    79a4:	80 58       	subi	r24, 0x80	; 128
    79a6:	56 95       	lsr	r21
    79a8:	97 95       	ror	r25
    79aa:	28 f4       	brcc	.+10     	; 0x79b6 <sqrt+0x30>
    79ac:	80 5c       	subi	r24, 0xC0	; 192
    79ae:	66 0f       	add	r22, r22
    79b0:	77 1f       	adc	r23, r23
    79b2:	88 1f       	adc	r24, r24
    79b4:	20 f0       	brcs	.+8      	; 0x79be <sqrt+0x38>
    79b6:	26 17       	cp	r18, r22
    79b8:	37 07       	cpc	r19, r23
    79ba:	48 07       	cpc	r20, r24
    79bc:	30 f4       	brcc	.+12     	; 0x79ca <sqrt+0x44>
    79be:	62 1b       	sub	r22, r18
    79c0:	73 0b       	sbc	r23, r19
    79c2:	84 0b       	sbc	r24, r20
    79c4:	20 29       	or	r18, r0
    79c6:	31 29       	or	r19, r1
    79c8:	4a 2b       	or	r20, r26
    79ca:	a6 95       	lsr	r26
    79cc:	17 94       	ror	r1
    79ce:	07 94       	ror	r0
    79d0:	20 25       	eor	r18, r0
    79d2:	31 25       	eor	r19, r1
    79d4:	4a 27       	eor	r20, r26
    79d6:	58 f7       	brcc	.-42     	; 0x79ae <sqrt+0x28>
    79d8:	66 0f       	add	r22, r22
    79da:	77 1f       	adc	r23, r23
    79dc:	88 1f       	adc	r24, r24
    79de:	20 f0       	brcs	.+8      	; 0x79e8 <sqrt+0x62>
    79e0:	26 17       	cp	r18, r22
    79e2:	37 07       	cpc	r19, r23
    79e4:	48 07       	cpc	r20, r24
    79e6:	30 f4       	brcc	.+12     	; 0x79f4 <sqrt+0x6e>
    79e8:	62 0b       	sbc	r22, r18
    79ea:	73 0b       	sbc	r23, r19
    79ec:	84 0b       	sbc	r24, r20
    79ee:	20 0d       	add	r18, r0
    79f0:	31 1d       	adc	r19, r1
    79f2:	41 1d       	adc	r20, r1
    79f4:	a0 95       	com	r26
    79f6:	81 f7       	brne	.-32     	; 0x79d8 <sqrt+0x52>
    79f8:	b9 01       	movw	r22, r18
    79fa:	84 2f       	mov	r24, r20
    79fc:	91 58       	subi	r25, 0x81	; 129
    79fe:	88 0f       	add	r24, r24
    7a00:	96 95       	lsr	r25
    7a02:	87 95       	ror	r24
    7a04:	08 95       	ret

00007a06 <square>:
    7a06:	9b 01       	movw	r18, r22
    7a08:	ac 01       	movw	r20, r24
    7a0a:	0c 94 24 3c 	jmp	0x7848	; 0x7848 <__mulsf3>

00007a0e <trunc>:
    7a0e:	0e 94 c5 3b 	call	0x778a	; 0x778a <__fp_trunc>
    7a12:	30 f0       	brcs	.+12     	; 0x7a20 <trunc+0x12>
    7a14:	9f 37       	cpi	r25, 0x7F	; 127
    7a16:	10 f4       	brcc	.+4      	; 0x7a1c <trunc+0xe>
    7a18:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__fp_szero>
    7a1c:	0c 94 f2 3a 	jmp	0x75e4	; 0x75e4 <__fp_mintl>
    7a20:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__fp_mpack>

00007a24 <__fp_norm2>:
    7a24:	91 50       	subi	r25, 0x01	; 1
    7a26:	50 40       	sbci	r21, 0x00	; 0
    7a28:	66 0f       	add	r22, r22
    7a2a:	77 1f       	adc	r23, r23
    7a2c:	88 1f       	adc	r24, r24
    7a2e:	d2 f7       	brpl	.-12     	; 0x7a24 <__fp_norm2>
    7a30:	08 95       	ret

00007a32 <__fp_powsodd>:
    7a32:	9f 93       	push	r25
    7a34:	8f 93       	push	r24
    7a36:	7f 93       	push	r23
    7a38:	6f 93       	push	r22
    7a3a:	ff 93       	push	r31
    7a3c:	ef 93       	push	r30
    7a3e:	9b 01       	movw	r18, r22
    7a40:	ac 01       	movw	r20, r24
    7a42:	0e 94 24 3c 	call	0x7848	; 0x7848 <__mulsf3>
    7a46:	ef 91       	pop	r30
    7a48:	ff 91       	pop	r31
    7a4a:	0e 94 1e 3b 	call	0x763c	; 0x763c <__fp_powser>
    7a4e:	2f 91       	pop	r18
    7a50:	3f 91       	pop	r19
    7a52:	4f 91       	pop	r20
    7a54:	5f 91       	pop	r21
    7a56:	0c 94 24 3c 	jmp	0x7848	; 0x7848 <__mulsf3>

00007a5a <__udivmodqi4>:
    7a5a:	99 1b       	sub	r25, r25
    7a5c:	79 e0       	ldi	r23, 0x09	; 9
    7a5e:	04 c0       	rjmp	.+8      	; 0x7a68 <__udivmodqi4_ep>

00007a60 <__udivmodqi4_loop>:
    7a60:	99 1f       	adc	r25, r25
    7a62:	96 17       	cp	r25, r22
    7a64:	08 f0       	brcs	.+2      	; 0x7a68 <__udivmodqi4_ep>
    7a66:	96 1b       	sub	r25, r22

00007a68 <__udivmodqi4_ep>:
    7a68:	88 1f       	adc	r24, r24
    7a6a:	7a 95       	dec	r23
    7a6c:	c9 f7       	brne	.-14     	; 0x7a60 <__udivmodqi4_loop>
    7a6e:	80 95       	com	r24
    7a70:	08 95       	ret

00007a72 <__udivmodsi4>:
    7a72:	a1 e2       	ldi	r26, 0x21	; 33
    7a74:	1a 2e       	mov	r1, r26
    7a76:	aa 1b       	sub	r26, r26
    7a78:	bb 1b       	sub	r27, r27
    7a7a:	fd 01       	movw	r30, r26
    7a7c:	0d c0       	rjmp	.+26     	; 0x7a98 <__udivmodsi4_ep>

00007a7e <__udivmodsi4_loop>:
    7a7e:	aa 1f       	adc	r26, r26
    7a80:	bb 1f       	adc	r27, r27
    7a82:	ee 1f       	adc	r30, r30
    7a84:	ff 1f       	adc	r31, r31
    7a86:	a2 17       	cp	r26, r18
    7a88:	b3 07       	cpc	r27, r19
    7a8a:	e4 07       	cpc	r30, r20
    7a8c:	f5 07       	cpc	r31, r21
    7a8e:	20 f0       	brcs	.+8      	; 0x7a98 <__udivmodsi4_ep>
    7a90:	a2 1b       	sub	r26, r18
    7a92:	b3 0b       	sbc	r27, r19
    7a94:	e4 0b       	sbc	r30, r20
    7a96:	f5 0b       	sbc	r31, r21

00007a98 <__udivmodsi4_ep>:
    7a98:	66 1f       	adc	r22, r22
    7a9a:	77 1f       	adc	r23, r23
    7a9c:	88 1f       	adc	r24, r24
    7a9e:	99 1f       	adc	r25, r25
    7aa0:	1a 94       	dec	r1
    7aa2:	69 f7       	brne	.-38     	; 0x7a7e <__udivmodsi4_loop>
    7aa4:	60 95       	com	r22
    7aa6:	70 95       	com	r23
    7aa8:	80 95       	com	r24
    7aaa:	90 95       	com	r25
    7aac:	9b 01       	movw	r18, r22
    7aae:	ac 01       	movw	r20, r24
    7ab0:	bd 01       	movw	r22, r26
    7ab2:	cf 01       	movw	r24, r30
    7ab4:	08 95       	ret

00007ab6 <__tablejump2__>:
    7ab6:	ee 0f       	add	r30, r30
    7ab8:	ff 1f       	adc	r31, r31
    7aba:	05 90       	lpm	r0, Z+
    7abc:	f4 91       	lpm	r31, Z
    7abe:	e0 2d       	mov	r30, r0
    7ac0:	09 94       	ijmp

00007ac2 <_exit>:
    7ac2:	f8 94       	cli

00007ac4 <__stop_program>:
    7ac4:	ff cf       	rjmp	.-2      	; 0x7ac4 <__stop_program>
